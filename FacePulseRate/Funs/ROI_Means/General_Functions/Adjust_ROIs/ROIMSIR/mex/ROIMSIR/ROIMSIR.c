/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * ROIMSIR.c
 *
 * Code generation for function 'ROIMSIR'
 *
 */

/* Include files */
#include "ROIMSIR.h"
#include "ROIMSIR_data.h"
#include "ROIMSIR_emxutil.h"
#include "ROIMSIR_types.h"
#include "allOrAny.h"
#include "any.h"
#include "colon.h"
#include "movmedian.h"
#include "repmat.h"
#include "rt_nonfinite.h"
#include "sort.h"
#include "sprintf.h"
#include "mwmathutil.h"
#include <string.h>

/* Variable Definitions */
static emlrtMCInfo emlrtMCI = { 505,   /* lineNo */
  9,                                   /* colNo */
  "ROIMSIR",                           /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR.m"/* pName */
};

static emlrtMCInfo b_emlrtMCI = { 548, /* lineNo */
  9,                                   /* colNo */
  "ROIMSIR",                           /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR.m"/* pName */
};

static emlrtMCInfo c_emlrtMCI = { 109, /* lineNo */
  5,                                   /* colNo */
  "ROIMSIR_Optimize",                  /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_Optimize.m"/* pName */
};

static emlrtMCInfo f_emlrtMCI = { 355, /* lineNo */
  17,                                  /* colNo */
  "ROIMSIR_MatchSize",                 /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_MatchSize.m"/* pName */
};

static emlrtMCInfo g_emlrtMCI = { 383, /* lineNo */
  9,                                   /* colNo */
  "ROIMSIR_MatchSize",                 /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_MatchSize.m"/* pName */
};

static emlrtMCInfo h_emlrtMCI = { 414, /* lineNo */
  17,                                  /* colNo */
  "ROIMSIR_MatchSize",                 /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_MatchSize.m"/* pName */
};

static emlrtMCInfo i_emlrtMCI = { 438, /* lineNo */
  9,                                   /* colNo */
  "ROIMSIR_MatchSize",                 /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_MatchSize.m"/* pName */
};

static emlrtMCInfo j_emlrtMCI = { 461, /* lineNo */
  17,                                  /* colNo */
  "ROIMSIR_DetectionSmooth",           /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_DetectionSmooth.m"/* pName */
};

static emlrtMCInfo k_emlrtMCI = { 490, /* lineNo */
  9,                                   /* colNo */
  "ROIMSIR_DetectionSmooth",           /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_DetectionSmooth.m"/* pName */
};

static emlrtMCInfo l_emlrtMCI = { 521, /* lineNo */
  17,                                  /* colNo */
  "ROIMSIR_DetectionSmooth",           /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_DetectionSmooth.m"/* pName */
};

static emlrtMCInfo m_emlrtMCI = { 545, /* lineNo */
  9,                                   /* colNo */
  "ROIMSIR_DetectionSmooth",           /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_DetectionSmooth.m"/* pName */
};

static emlrtMCInfo n_emlrtMCI = { 230, /* lineNo */
  9,                                   /* colNo */
  "ROIMSIR_Interpolate",               /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_Interpolate.m"/* pName */
};

static emlrtMCInfo o_emlrtMCI = { 254, /* lineNo */
  9,                                   /* colNo */
  "ROIMSIR_Interpolate",               /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_Interpolate.m"/* pName */
};

static emlrtMCInfo p_emlrtMCI = { 293, /* lineNo */
  9,                                   /* colNo */
  "ROIMSIR_Interpolate",               /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_Interpolate.m"/* pName */
};

static emlrtMCInfo q_emlrtMCI = { 315, /* lineNo */
  9,                                   /* colNo */
  "ROIMSIR_Interpolate",               /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_Interpolate.m"/* pName */
};

static emlrtMCInfo r_emlrtMCI = { 398, /* lineNo */
  9,                                   /* colNo */
  "ROIMSIR_FrameByFrameSmooth",        /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_FrameByFrameSmooth.m"/* pName */
};

static emlrtMCInfo s_emlrtMCI = { 424, /* lineNo */
  9,                                   /* colNo */
  "ROIMSIR_FrameByFrameSmooth",        /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_FrameByFrameSmooth.m"/* pName */
};

static emlrtMCInfo t_emlrtMCI = { 156, /* lineNo */
  17,                                  /* colNo */
  "ROIMSIR_FrameByFrameSmooth_InterpFR",/* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_FrameByFrameSmooth_InterpFR.m"/* pName */
};

static emlrtMCInfo u_emlrtMCI = { 186, /* lineNo */
  9,                                   /* colNo */
  "ROIMSIR_FrameByFrameSmooth_InterpFR",/* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_FrameByFrameSmooth_InterpFR.m"/* pName */
};

static emlrtMCInfo v_emlrtMCI = { 58,  /* lineNo */
  5,                                   /* colNo */
  "ROIMSIR_FrameByFrameSmooth_SmoothFR",/* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_FrameByFrameSmooth_SmoothFR.m"/* pName */
};

static emlrtMCInfo w_emlrtMCI = { 182, /* lineNo */
  9,                                   /* colNo */
  "ROIMSIR_FrameByFrameSmooth_SmoothFR",/* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_FrameByFrameSmooth_SmoothFR.m"/* pName */
};

static emlrtMCInfo x_emlrtMCI = { 209, /* lineNo */
  5,                                   /* colNo */
  "ROIMSIR_FrameByFrameSmooth_SmoothFR",/* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_FrameByFrameSmooth_SmoothFR.m"/* pName */
};

static emlrtMCInfo y_emlrtMCI = { 468, /* lineNo */
  9,                                   /* colNo */
  "ROIMSIR_FrameByFrameSmooth",        /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_FrameByFrameSmooth.m"/* pName */
};

static emlrtMCInfo ab_emlrtMCI = { 58, /* lineNo */
  9,                                   /* colNo */
  "ROIMSIR_OutputValidate",            /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_OutputValidate.m"/* pName */
};

static emlrtMCInfo bb_emlrtMCI = { 128,/* lineNo */
  9,                                   /* colNo */
  "ROIMSIR_OutputValidate",            /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_OutputValidate.m"/* pName */
};

static emlrtMCInfo cb_emlrtMCI = { 82, /* lineNo */
  9,                                   /* colNo */
  "ROIMSIR_OutputValidate",            /* fName */
  "G:\\My Drive\\Articles\\topics\\physio\\Articles Chapters\\Measures\\Autonomic NS (GSR HR)\\HR\\HR webcam\\McDuff Github\\My work\\FacePulse"
  "Rate\\Helper_Funs\\ROI_Means\\General_Functions\\Adjust_ROIs\\ROIMSIR\\ROIMSIR_OutputValidate.m"/* pName */
};

/* Function Declarations */
static const mxArray *b_emlrt_marshallOut(const emxArray_char_T *u);
static const mxArray *c_emlrt_marshallOut(const char_T u[133]);
static const mxArray *e_emlrt_marshallOut(const char_T u[243]);
static const mxArray *emlrt_marshallOut(const char_T u[23]);
static void error(const mxArray *b, const mxArray *c, emlrtMCInfo *location);
static const mxArray *f_emlrt_marshallOut(const char_T u[296]);
static const mxArray *g_emlrt_marshallOut(const char_T u[253]);
static const mxArray *h_emlrt_marshallOut(const char_T u[302]);
static const mxArray *i_emlrt_marshallOut(const char_T u[249]);
static const mxArray *j_emlrt_marshallOut(const char_T u[298]);
static const mxArray *k_emlrt_marshallOut(const char_T u[464]);
static const mxArray *l_emlrt_marshallOut(const char_T u[305]);
static const mxArray *m_emlrt_marshallOut(const char_T u[300]);
static void warning(const mxArray *b, const mxArray *c, emlrtMCInfo *location);

/* Function Definitions */
static const mxArray *b_emlrt_marshallOut(const emxArray_char_T *u)
{
  const mxArray *m;
  const mxArray *y;
  int32_T iv[2];
  y = NULL;
  iv[0] = u->size[0];
  iv[1] = u->size[1];
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, u->size[1], m, &u->data[0]);
  emlrtAssign(&y, m);
  return y;
}

static const mxArray *c_emlrt_marshallOut(const char_T u[133])
{
  static const int32_T iv[2] = { 1, 133 };

  const mxArray *m;
  const mxArray *y;
  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 133, m, &u[0]);
  emlrtAssign(&y, m);
  return y;
}

static const mxArray *e_emlrt_marshallOut(const char_T u[243])
{
  static const int32_T iv[2] = { 1, 243 };

  const mxArray *m;
  const mxArray *y;
  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 243, m, &u[0]);
  emlrtAssign(&y, m);
  return y;
}

static const mxArray *emlrt_marshallOut(const char_T u[23])
{
  static const int32_T iv[2] = { 1, 23 };

  const mxArray *m;
  const mxArray *y;
  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 23, m, &u[0]);
  emlrtAssign(&y, m);
  return y;
}

static void error(const mxArray *b, const mxArray *c, emlrtMCInfo *location)
{
  const mxArray *pArrays[2];
  pArrays[0] = b;
  pArrays[1] = c;
  emlrtCallMATLABR2012b(emlrtRootTLSGlobal, 0, NULL, 2, pArrays, "error", true,
                        location);
}

static const mxArray *f_emlrt_marshallOut(const char_T u[296])
{
  static const int32_T iv[2] = { 1, 296 };

  const mxArray *m;
  const mxArray *y;
  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 296, m, &u[0]);
  emlrtAssign(&y, m);
  return y;
}

static const mxArray *g_emlrt_marshallOut(const char_T u[253])
{
  static const int32_T iv[2] = { 1, 253 };

  const mxArray *m;
  const mxArray *y;
  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 253, m, &u[0]);
  emlrtAssign(&y, m);
  return y;
}

static const mxArray *h_emlrt_marshallOut(const char_T u[302])
{
  static const int32_T iv[2] = { 1, 302 };

  const mxArray *m;
  const mxArray *y;
  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 302, m, &u[0]);
  emlrtAssign(&y, m);
  return y;
}

static const mxArray *i_emlrt_marshallOut(const char_T u[249])
{
  static const int32_T iv[2] = { 1, 249 };

  const mxArray *m;
  const mxArray *y;
  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 249, m, &u[0]);
  emlrtAssign(&y, m);
  return y;
}

static const mxArray *j_emlrt_marshallOut(const char_T u[298])
{
  static const int32_T iv[2] = { 1, 298 };

  const mxArray *m;
  const mxArray *y;
  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 298, m, &u[0]);
  emlrtAssign(&y, m);
  return y;
}

static const mxArray *k_emlrt_marshallOut(const char_T u[464])
{
  static const int32_T iv[2] = { 2, 232 };

  const mxArray *m;
  const mxArray *y;
  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 464, m, &u[0]);
  emlrtAssign(&y, m);
  return y;
}

static const mxArray *l_emlrt_marshallOut(const char_T u[305])
{
  static const int32_T iv[2] = { 1, 305 };

  const mxArray *m;
  const mxArray *y;
  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 305, m, &u[0]);
  emlrtAssign(&y, m);
  return y;
}

static const mxArray *m_emlrt_marshallOut(const char_T u[300])
{
  static const int32_T iv[2] = { 1, 300 };

  const mxArray *m;
  const mxArray *y;
  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a(emlrtRootTLSGlobal, 300, m, &u[0]);
  emlrtAssign(&y, m);
  return y;
}

static void warning(const mxArray *b, const mxArray *c, emlrtMCInfo *location)
{
  const mxArray *pArrays[2];
  pArrays[0] = b;
  pArrays[1] = c;
  emlrtCallMATLABR2012b(emlrtRootTLSGlobal, 0, NULL, 2, pArrays, "warning", true,
                        location);
}

void ROIMSIR(const emxArray_int32_T *BlockFullLinIdx_In, emxArray_int16_T *ROI,
             emxArray_real32_T *Timestamp, struct0_T *HasROI_TF, int16_T
             c_ROIGeneralConfig_ROIMSIR_Diff, int16_T
             d_ROIGeneralConfig_ROIMSIR_Diff, real_T
             c_ROIGeneralConfig_ROIWidthResi, real_T
             c_ROIGeneralConfig_ROIHeightRes, real_T
             c_FaceDetectConfig_ROIFaceSmoot, boolean_T
             c_FaceDetectConfig_ROIFaceSecon, boolean_T
             d_FaceDetectConfig_ROIFaceSecon, real_T
             c_SkinDetectConfig_ROISkinSmoot, const int32_T
             c_ROIGeneralConfig_ROIFinalSmoo[2], int16_T VidObjWidth, int16_T
             VidObjHeight, boolean_T ExpectedBehaviorTestTF, boolean_T
             FirstReadTF, boolean_T FirstCallTF, emxArray_int32_T
             *VideoReadConfig_FrameIdx_FR, int32_T RowToReturnFullLinIdx_FR,
             int32_T ROIMSIR_FirstFrameLinIdx_FR, emxArray_int16_T *ROINoMods,
             emxArray_int16_T *ROINoResize, struct1_T *ROIMatchSizeData,
             boolean_T SecondReadPostProcessingTF, int16_T ROIOut_FR[4],
             emxArray_int16_T *ROIOut_SR, int32_T *InterpolatedLinIdx_FR,
             emxArray_int32_T *InterpolatedLinIdx_SR, int16_T
             c_ROIOutBeforeFrameByFrameSmoot[4], emxArray_int16_T
             *d_ROIOutBeforeFrameByFrameSmoot, int16_T ROIOutNoResize_FR[4])
{
  static const int32_T iv[1] = { 458 };

  static const char_T cv42[305] = { 'P', 'o', 't', 'e', 'n', 't', 'i', 'a', 'l',
    ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'E', 'r', 'r', 'o', 'r',
    ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',', ' ', 'c', 'o', 'd', 'e',
    ' ', '2', '7', ')', ':', ' ', 'R', 'O', 'I', '-', 'm', 'o', 'd', 'i', 'f',
    'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i',
    'o', 'n', 's', ' ', 'a', 's', 's', 'i', 'g', 'n', 'e', 'd', ' ', 'a', ' ',
    's', 'i', 'z', 'e', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'f', 'o', 'r', ' ',
    'a', 'n', ' ', 'R', 'O', 'I', ' ', 't', 'h', 'a', 't', ' ', 'i', 's', ' ',
    'b', 'e', 'l', 'o', 'w', ' ', '2', '0', ' ', 'p', 'i', 'x', 'e', 'l', 's',
    ',', ' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'l', 'i', 'k', 'e',
    'l', 'y', ' ', 'i', 'n', 'a', 'c', 'c', 'u', 'r', 'a', 't', 'e', '.', ' ',
    'R', 'O', 'I', ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c', 'y', ' ', 'm', 'a',
    'y', ' ', 'b', 'e', ' ', 'a', 'f', 'f', 'e', 'c', 't', 'e', 'd', '.', ' ',
    'O', 'c', 'c', 'u', 'r', 'r', 'e', 'd', ' ', 'd', 'u', 'r', 'i', 'n', 'g',
    ' ', 't', 'h', 'e', ' ', 's', 'e', 'c', 'o', 'n', 'd', '-', 'r', 'e', 'a',
    'd', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 's', '.', ' ', 'D',
    'e', 't', 'e', 'c', 't', 'e', 'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ',
    'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I',
    'R', ' ', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R',
    'O', 'I', 'M', 'S', 'I', 'R', '_', 'F', 'r', 'a', 'm', 'e', 'B', 'y', 'F',
    'r', 'a', 'm', 'e', 'S', 'm', 'o', 'o', 't', 'h', '.' };

  static const char_T cv25[302] = { 'P', 'o', 't', 'e', 'n', 't', 'i', 'a', 'l',
    ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'E', 'r', 'r', 'o', 'r',
    ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',', ' ', 'c', 'o', 'd', 'e',
    ' ', '1', '3', ')', ':', ' ', 'R', 'O', 'I', '-', 'm', 'o', 'd', 'i', 'f',
    'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i',
    'o', 'n', 's', ' ', 'a', 's', 's', 'i', 'g', 'n', 'e', 'd', ' ', 'a', ' ',
    's', 'i', 'z', 'e', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'f', 'o', 'r', ' ',
    'a', 'n', ' ', 'R', 'O', 'I', ' ', 't', 'h', 'a', 't', ' ', 'i', 's', ' ',
    'b', 'e', 'l', 'o', 'w', ' ', '2', '0', ' ', 'p', 'i', 'x', 'e', 'l', 's',
    ',', ' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'l', 'i', 'k', 'e',
    'l', 'y', ' ', 'i', 'n', 'a', 'c', 'c', 'u', 'r', 'a', 't', 'e', '.', ' ',
    'R', 'O', 'I', ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c', 'y', ' ', 'm', 'a',
    'y', ' ', 'b', 'e', ' ', 'a', 'f', 'f', 'e', 'c', 't', 'e', 'd', '.', ' ',
    'O', 'c', 'c', 'u', 'r', 'r', 'e', 'd', ' ', 'd', 'u', 'r', 'i', 'n', 'g',
    ' ', 't', 'h', 'e', ' ', 's', 'e', 'c', 'o', 'n', 'd', '-', 'r', 'e', 'a',
    'd', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 's', '.', ' ', 'D',
    'e', 't', 'e', 'c', 't', 'e', 'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ',
    'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I',
    'R', ' ', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R',
    'O', 'I', 'M', 'S', 'I', 'R', '_', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o',
    'n', 'S', 'm', 'o', 'o', 't', 'h', '.' };

  static const char_T cv39[300] = { 'P', 'o', 't', 'e', 'n', 't', 'i', 'a', 'l',
    ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'E', 'r', 'r', 'o', 'r',
    ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',', ' ', 'c', 'o', 'd', 'e',
    ' ', '3', '2', ')', ':', ' ', 'R', 'O', 'I', '-', 'm', 'o', 'd', 'i', 'f',
    'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i',
    'o', 'n', 's', ' ', 'a', 's', 's', 'i', 'g', 'n', 'e', 'd', ' ', 'a', ' ',
    's', 'i', 'z', 'e', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'f', 'o', 'r', ' ',
    'a', 'n', ' ', 'R', 'O', 'I', ' ', 't', 'h', 'a', 't', ' ', 'i', 's', ' ',
    'b', 'e', 'l', 'o', 'w', ' ', '2', '0', ' ', 'p', 'i', 'x', 'e', 'l', 's',
    ',', ' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'l', 'i', 'k', 'e',
    'l', 'y', ' ', 'i', 'n', 'a', 'c', 'c', 'u', 'r', 'a', 't', 'e', '.', ' ',
    'R', 'O', 'I', ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c', 'y', ' ', 'm', 'a',
    'y', ' ', 'b', 'e', ' ', 'a', 'f', 'f', 'e', 'c', 't', 'e', 'd', '.', ' ',
    'O', 'c', 'c', 'u', 'r', 'r', 'e', 'd', ' ', 'd', 'u', 'r', 'i', 'n', 'g',
    ' ', 't', 'h', 'e', ' ', 's', 'e', 'c', 'o', 'n', 'd', '-', 'r', 'e', 'a',
    'd', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 's', '.', ' ', 'D',
    'e', 't', 'e', 'c', 't', 'e', 'd', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'f',
    'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R',
    ' ', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O',
    'I', 'M', 'S', 'I', 'R', '_', 'O', 'u', 't', 'p', 'u', 't', 'V', 'a', 'l',
    'i', 'd', 'a', 't', 'e', '.' };

  static const char_T cv37[298] = { 'P', 'o', 't', 'e', 'n', 't', 'i', 'a', 'l',
    ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'E', 'r', 'r', 'o', 'r',
    ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',', ' ', 'c', 'o', 'd', 'e',
    ' ', '1', '8', ')', ':', ' ', 'R', 'O', 'I', '-', 'm', 'o', 'd', 'i', 'f',
    'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i',
    'o', 'n', 's', ' ', 'a', 's', 's', 'i', 'g', 'n', 'e', 'd', ' ', 'a', ' ',
    's', 'i', 'z', 'e', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'f', 'o', 'r', ' ',
    'a', 'n', ' ', 'R', 'O', 'I', ' ', 't', 'h', 'a', 't', ' ', 'i', 's', ' ',
    'b', 'e', 'l', 'o', 'w', ' ', '2', '0', ' ', 'p', 'i', 'x', 'e', 'l', 's',
    ',', ' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'l', 'i', 'k', 'e',
    'l', 'y', ' ', 'i', 'n', 'a', 'c', 'c', 'u', 'r', 'a', 't', 'e', '.', ' ',
    'R', 'O', 'I', ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c', 'y', ' ', 'm', 'a',
    'y', ' ', 'b', 'e', ' ', 'a', 'f', 'f', 'e', 'c', 't', 'e', 'd', '.', ' ',
    'O', 'c', 'c', 'u', 'r', 'r', 'e', 'd', ' ', 'd', 'u', 'r', 'i', 'n', 'g',
    ' ', 't', 'h', 'e', ' ', 's', 'e', 'c', 'o', 'n', 'd', '-', 'r', 'e', 'a',
    'd', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 's', '.', ' ', 'D',
    'e', 't', 'e', 'c', 't', 'e', 'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ',
    'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I',
    'R', ' ', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R',
    'O', 'I', 'M', 'S', 'I', 'R', '_', 'I', 'n', 't', 'e', 'r', 'p', 'o', 'l',
    'a', 't', 'e', '.' };

  static const char_T cv14[296] = { 'P', 'o', 't', 'e', 'n', 't', 'i', 'a', 'l',
    ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'E', 'r', 'r', 'o', 'r',
    ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',', ' ', 'c', 'o', 'd', 'e',
    ' ', '9', ')', ':', ' ', 'R', 'O', 'I', '-', 'm', 'o', 'd', 'i', 'f', 'i',
    'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o',
    'n', 's', ' ', 'a', 's', 's', 'i', 'g', 'n', 'e', 'd', ' ', 'a', ' ', 's',
    'i', 'z', 'e', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'f', 'o', 'r', ' ', 'a',
    'n', ' ', 'R', 'O', 'I', ' ', 't', 'h', 'a', 't', ' ', 'i', 's', ' ', 'b',
    'e', 'l', 'o', 'w', ' ', '2', '0', ' ', 'p', 'i', 'x', 'e', 'l', 's', ',',
    ' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'l', 'i', 'k', 'e', 'l',
    'y', ' ', ' ', 'i', 'n', 'a', 'c', 'c', 'u', 'r', 'a', 't', 'e', '.', ' ',
    'R', 'O', 'I', ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c', 'y', ' ', 'm', 'a',
    'y', ' ', 'b', 'e', ' ', 'a', 'f', 'f', 'e', 'c', 't', 'e', 'd', '.', ' ',
    'O', 'c', 'c', 'u', 'r', 'r', 'e', 'd', ' ', 'd', 'u', 'r', 'i', 'n', 'g',
    ' ', 't', 'h', 'e', ' ', 's', 'e', 'c', 'o', 'n', 'd', '-', 'r', 'e', 'a',
    'd', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 's', '.', ' ', 'D',
    'e', 't', 'e', 'c', 't', 'e', 'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ',
    'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I',
    'R', ' ', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R',
    'O', 'I', 'M', 'S', 'I', 'R', '_', 'M', 'a', 't', 'c', 'h', 'S', 'i', 'z',
    'e', '.' };

  static const char_T cv20[253] = { 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ',
    'E', 'r', 'r', 'o', 'r', ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',',
    ' ', 'c', 'o', 'd', 'e', ' ', '1', '2', ')', ':', ' ', 'R', 'O', 'I', '-',
    'm', 'o', 'd', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p',
    'e', 'r', 'a', 't', 'i', 'o', 'n', 's', ' ', 'a', 's', 's', 'i', 'g', 'n',
    'e', 'd', ' ', 'a', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'o', 'f', ' ', 'z',
    'e', 'r', 'o', ' ', 'f', 'o', 'r', ' ', 'a', 'n', ' ', 'R', 'O', 'I', '.',
    ' ', 'R', 'O', 'I', ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c', 'y', ' ', 'm',
    'a', 'y', ' ', 'b', 'e', ' ', 'a', 'f', 'f', 'e', 'c', 't', 'e', 'd', '.',
    ' ', 'T', 'h', 'e', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'o', 'c', 'c', 'u',
    'r', 'r', 'e', 'd', ' ', 'd', 'u', 'r', 'i', 'n', 'g', ' ', 't', 'h', 'e',
    ' ', 's', 'e', 'c', 'o', 'n', 'd', '-', 'r', 'e', 'a', 'd', ' ', 'o', 'p',
    'e', 'r', 'a', 't', 'i', 'o', 'n', 's', '.', ' ', 'D', 'e', 't', 'e', 'c',
    't', 'e', 'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'f', 'u', 'n', 'c',
    't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ' ', 'i', 'n',
    ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S',
    'I', 'R', '_', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', 'S', 'm', 'o',
    'o', 't', 'h', '.' };

  static const char_T cv36[249] = { 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ',
    'E', 'r', 'r', 'o', 'r', ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',',
    ' ', 'c', 'o', 'd', 'e', ' ', '1', '7', ')', ':', ' ', 'R', 'O', 'I', '-',
    'm', 'o', 'd', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p',
    'e', 'r', 'a', 't', 'i', 'o', 'n', 's', ' ', 'a', 's', 's', 'i', 'g', 'n',
    'e', 'd', ' ', 'a', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'o', 'f', ' ', 'z',
    'e', 'r', 'o', ' ', 'f', 'o', 'r', ' ', 'a', 'n', ' ', 'R', 'O', 'I', '.',
    ' ', 'R', 'O', 'I', ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c', 'y', ' ', 'm',
    'a', 'y', ' ', 'b', 'e', ' ', 'a', 'f', 'f', 'e', 'c', 't', 'e', 'd', '.',
    ' ', 'T', 'h', 'e', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'o', 'c', 'c', 'u',
    'r', 'r', 'e', 'd', ' ', 'd', 'u', 'r', 'i', 'n', 'g', ' ', 't', 'h', 'e',
    ' ', 's', 'e', 'c', 'o', 'n', 'd', '-', 'r', 'e', 'a', 'd', ' ', 'o', 'p',
    'e', 'r', 'a', 't', 'i', 'o', 'n', 's', '.', ' ', 'D', 'e', 't', 'e', 'c',
    't', 'e', 'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'f', 'u', 'n', 'c',
    't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ' ', 'i', 'n',
    ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S',
    'I', 'R', '_', 'I', 'n', 't', 'e', 'r', 'p', 'o', 'l', 'a', 't', 'e', '.' };

  static const char_T cv9[243] = { 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ',
    'E', 'r', 'r', 'o', 'r', ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',',
    ' ', 'c', 'o', 'd', 'e', ' ', '8', ')', ':', ' ', 'S', 'i', 'z', 'e', '-',
    'm', 'a', 't', 'c', 'h', 'i', 'n', 'g', ' ', 'o', 'p', 'e', 'r', 'a', 't',
    'i', 'o', 'n', 's', ' ', 'a', 's', 's', 'i', 'g', 'n', 'e', 'd', ' ', 'a',
    ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'o', 'f', ' ', 'z', 'e', 'r', 'o', ' ',
    'f', 'o', 'r', ' ', 'a', 'n', ' ', 'R', 'O', 'I', '.', ' ', 'R', 'O', 'I',
    ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c', 'y', ' ', 'm', 'a', 'y', ' ', 'b',
    'e', ' ', 'a', 'f', 'f', 'e', 'c', 't', 'e', 'd', '.', ' ', 'T', 'h', 'e',
    ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'o', 'c', 'c', 'u', 'r', 'r', 'e', 'd',
    ' ', 'd', 'u', 'r', 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 's', 'e', 'c',
    'o', 'n', 'd', '-', 'r', 'e', 'a', 'd', ' ', 'o', 'p', 'e', 'r', 'a', 't',
    'i', 'o', 'n', 's', '.', ' ', 'D', 'e', 't', 'e', 'c', 't', 'e', 'd', ' ',
    'w', 'i', 't', 'h', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n',
    ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ' ', 'i', 'n', ' ', 'f', 'u', 'n',
    'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', '_', 'M',
    'a', 't', 'c', 'h', 'S', 'i', 'z', 'e', '.' };

  static const char_T cv55[232] = { 'P', 'o', 't', 'e', 'n', 't', 'i', 'a', 'l',
    ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'E', 'r', 'r', 'o', 'r',
    ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',', ' ', 'c', 'o', 'd', 'e',
    ' ', '2', '5', ')', ':', ' ', 'R', 'O', 'I', '-', 'm', 'o', 'd', 'i', 'f',
    'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i',
    'o', 'n', 's', ' ', 'a', 's', 's', 'i', 'g', 'n', 'e', 'd', ' ', 'a', ' ',
    's', 'i', 'z', 'e', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'f', 'o', 'r', ' ',
    'a', 'n', ' ', 'R', 'O', 'I', ' ', 't', 'h', 'a', 't', ' ', 'i', 's', ' ',
    'b', 'e', 'l', 'o', 'w', ' ', '2', '0', ' ', 'p', 'i', 'x', 'e', 'l', 's',
    ',', ' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'l', 'i', 'k', 'e',
    'l', 'y', ' ', 'i', 'n', 'a', 'c', 'c', 'u', 'r', 'a', 't', 'e', '.', ' ',
    'R', 'O', 'I', ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c', 'y', ' ', 'm', 'a',
    'y', ' ', 'b', 'e', ' ', 'a', 'f', 'f', 'e', 'c', 't', 'e', 'd', '.', ' ',
    'T', 'h', 'e', ' ', 'f', 'r', 'a', 'm', 'e', ' ', 'i', 'n', 'd', 'e', 'x',
    ' ', 'o', 'f', ' ', 'c', 'o', 'r', 'r', 'e', 's', 'p', 'o', 'n', 'd', 'i',
    'n', 'g', ' ', 'f', 'r', 'a', 'm', 'e', ' ', 'i', 's', ':', ' ' };

  static const char_T cv5[133] = { 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ',
    'E', 'r', 'r', 'o', 'r', ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',',
    ' ', 'c', 'o', 'd', 'e', ' ', '5', ')', ':', ' ', 'B', 'l', 'o', 'c', 'k',
    'F', 'u', 'l', 'l', 'L', 'i', 'n', 'I', 'd', 'x', '_', 'I', 'n', ' ', 'n',
    'o', 't', ' ', 'c', 'o', 'r', 'r', 'e', 'c', 't', ' ', 's', 'i', 'z', 'e',
    '.', ' ', 'D', 'e', 't', 'e', 'c', 't', 'e', 'd', ' ', 'w', 'i', 't', 'h',
    'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I',
    'M', 'S', 'I', 'R', ' ', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o',
    'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', '_', 'O', 'p', 't', 'i', 'm',
    'i', 'z', 'e', '.' };

  static const char_T cv66[83] = { '.', ' ', 'D', 'e', 't', 'e', 'c', 't', 'e',
    'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i',
    'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ' ', 'i', 'n', ' ', 'f',
    'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R',
    '_', 'F', 'r', 'a', 'm', 'e', 'B', 'y', 'F', 'r', 'a', 'm', 'e', 'S', 'm',
    'o', 'o', 't', 'h', '_', 'S', 'm', 'o', 'o', 't', 'h', 'F', 'R', '.' };

  static const char_T cv47[82] = { 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ',
    'E', 'r', 'r', 'o', 'r', ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',',
    ' ', 'c', 'o', 'd', 'e', ' ', '2', '1', '.', '5', ')', ':', ' ', 'T', 'h',
    'e', ' ', 'b', 'l', 'o', 'c', 'k', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'o',
    'f', ' ', 't', 'h', 'e', ' ', 'r', 'o', 'w', '-', 't', 'o', '-', 'r', 'e',
    't', 'u', 'r', 'n', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't' };

  static const char_T cv52[82] = { '.', ' ', 'S', 'm', 'o', 'o', 't', 'h', 'i',
    'n', 'g', ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c', 'y', ' ', 'm', 'a', 'y',
    ' ', 'b', 'e', ' ', 'a', 'f', 'f', 'e', 'c', 't', 'e', 'd', '.', ' ', 'D',
    'e', 't', 'e', 'c', 't', 'e', 'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ',
    'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I',
    'R', ' ', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n' };

  static const char_T cv15[80] = { 'P', 'o', 't', 'e', 'n', 't', 'i', 'a', 'l',
    ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'E', 'r', 'r', 'o', 'r',
    ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',', ' ', 'c', 'o', 'd', 'e',
    ' ', '7', ')', ':', ' ', 'R', 'O', 'I', '-', 'm', 'o', 'd', 'i', 'f', 'i',
    'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o',
    'n', 's', ' ', 'a', 's', 's', 'i', 'g', 'n', 'e', 'd' };

  static const char_T cv63[80] = { 'P', 'o', 't', 'e', 'n', 't', 'i', 'a', 'l',
    ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'E', 'r', 'r', 'o', 'r',
    ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',', ' ', 'c', 'o', 'd', 'e',
    ' ', '2', '3', ')', ':', ' ', 'S', 'm', 'o', 'o', 't', 'h', 'i', 'n', 'g',
    ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 's', ' ', 'c', 'o', 'n',
    'd', 'u', 'c', 't', 'e', 'd', ' ', 'w', 'i', 't', 'h' };

  static const char_T cv64[80] = { ' ', 'R', 'O', 'I', 's', ' ', 'w', 'i', 't',
    'h', ' ', 's', 'i', 'z', 'e', ' ', 'v', 'a', 'l', 'u', 'e', 's', ' ', 'b',
    'e', 'l', 'o', 'w', ' ', '2', '0', ' ', 'p', 'i', 'x', 'e', 'l', 's', ',',
    ' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'l', 'i', 'k', 'e', 'l',
    'y', ' ', 'i', 'n', 'a', 'c', 'c', 'u', 'r', 'a', 't', 'e', '.', ' ', 'R',
    'O', 'I', ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c', 'y' };

  static const char_T cv28[79] = { ' ', 'i', 'n', 'a', 'c', 'c', 'u', 'r', 'a',
    't', 'e', '.', ' ', 'R', 'O', 'I', ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c',
    'y', ' ', 'm', 'a', 'y', ' ', 'b', 'e', ' ', 'a', 'f', 'f', 'e', 'c', 't',
    'e', 'd', '.', ' ', 'T', 'h', 'e', ' ', 'f', 'r', 'a', 'm', 'e', ' ', 'i',
    'n', 'd', 'e', 'x', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'r',
    'r', 'e', 's', 'p', 'o', 'n', 'd', 'i', 'n', 'g' };

  static const char_T cv30[79] = { 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ',
    'E', 'r', 'r', 'o', 'r', ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',',
    ' ', 'c', 'o', 'd', 'e', ' ', '1', '4', ')', ':', ' ', 'R', 'O', 'I', '-',
    'm', 'o', 'd', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p',
    'e', 'r', 'a', 't', 'i', 'o', 'n', 's', ' ', 'a', 's', 's', 'i', 'g', 'n',
    'e', 'd', ' ', 'a', ' ', 'v', 'a', 'l', 'u', 'e' };

  static const char_T cv38[79] = { 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ',
    'E', 'r', 'r', 'o', 'r', ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',',
    ' ', 'c', 'o', 'd', 'e', ' ', '2', '9', ')', ':', ' ', 'R', 'O', 'I', '-',
    'm', 'o', 'd', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p',
    'e', 'r', 'a', 't', 'i', 'o', 'n', 's', ' ', 'a', 's', 's', 'i', 'g', 'n',
    'e', 'd', ' ', 'a', ' ', 'v', 'a', 'l', 'u', 'e' };

  static const char_T cv56[79] = { 'P', 'o', 't', 'e', 'n', 't', 'i', 'a', 'l',
    ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'E', 'r', 'r', 'o', 'r',
    ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',', ' ', 'c', 'o', 'd', 'e',
    ' ', '2', '1', ')', ':', ' ', 'I', 'n', 't', 'e', 'r', 'p', 'o', 'l', 'a',
    't', 'i', 'o', 'n', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 's',
    ' ', 'c', 'o', 'n', 'd', 'u', 'c', 't', 'e', 'd' };

  static const char_T cv6[79] = { 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ',
    'E', 'r', 'r', 'o', 'r', ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',',
    ' ', 'c', 'o', 'd', 'e', ' ', '3', ')', ':', ' ', 'T', 'h', 'e', ' ', 'c',
    'u', 'r', 'r', 'e', 'n', 't', ' ', 'f', 'r', 'a', 'm', 'e', ' ', 'a', 'p',
    'p', 'e', 'a', 'r', 's', ' ', 't', 'o', ' ', 'h', 'a', 'v', 'e', ' ', 'a',
    ' ', 'd', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n' };

  static const char_T cv7[79] = { ' ', 'b', 'u', 't', ' ', 't', 'h', 'e', ' ',
    'R', 'O', 'I', 'N', 'o', 'M', 'o', 'd', 's', ' ', 'i', 'n', 'p', 'u', 't',
    ' ', 'c', 'o', 'r', 'r', 'e', 's', 'p', 'o', 'n', 'd', 'i', 'n', 'g', ' ',
    't', 'o', ' ', 't', 'h', 'e', ' ', 'c', 'u', 'r', 'r', 'e', 'n', 't', ' ',
    'f', 'r', 'a', 'm', 'e', ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ',
    'a', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'o', 'f' };

  static const char_T cv[77] = { 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ',
    'E', 'r', 'r', 'o', 'r', ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',',
    ' ', 'c', 'o', 'd', 'e', ' ', '2', '.', '5', ')', ':', ' ', 'T', 'h', 'e',
    ' ', 'b', 'l', 'o', 'c', 'k', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'o', 'f',
    ' ', 't', 'h', 'e', ' ', 'r', 'o', 'w', '-', 't', 'o', '-', 'r', 'e', 't',
    'u', 'r', 'n', ' ', 'd', 'o', 'e', 's' };

  static const char_T cv16[77] = { ' ', 'a', ' ', 's', 'i', 'z', 'e', ' ', 'v',
    'a', 'l', 'u', 'e', ' ', 'f', 'o', 'r', ' ', 'a', 'n', ' ', 'R', 'O', 'I',
    ' ', 't', 'h', 'a', 't', ' ', 'i', 's', ' ', 'b', 'e', 'l', 'o', 'w', ' ',
    '2', '0', ' ', 'p', 'i', 'x', 'e', 'l', 's', ',', ' ', 'w', 'h', 'i', 'c',
    'h', ' ', 'i', 's', ' ', 'l', 'i', 'k', 'e', 'l', 'y', ' ', 'i', 'n', 'a',
    'c', 'c', 'u', 'r', 'a', 't', 'e', '.' };

  static const char_T cv35[75] = { ' ', 'i', 'n', 'a', 'c', 'c', 'u', 'r', 'a',
    't', 'e', '.', ' ', 'R', 'O', 'I', ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c',
    'y', ' ', 'm', 'a', 'y', ' ', 'b', 'e', ' ', 'a', 'f', 'f', 'e', 'c', 't',
    'e', 'd', '.', ' ', 'T', 'h', 'e', ' ', 'f', 'r', 'a', 'm', 'e', ' ', 'i',
    'n', 'd', 'e', 'x', ' ', 'o', 'f', ' ', 'c', 'o', 'r', 'r', 'e', 's', 'p',
    'o', 'n', 'd', 'i', 'n', 'g' };

  static const char_T cv45[75] = { ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'o', 'f',
    ' ', 'z', 'e', 'r', 'o', ' ', 'f', 'o', 'r', ' ', 'a', 'n', ' ', 'R', 'O',
    'I', '.', ' ', 'R', 'O', 'I', ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c', 'y',
    ' ', 'm', 'a', 'y', ' ', 'b', 'e', ' ', 'a', 'f', 'f', 'e', 'c', 't', 'e',
    'd', '.', ' ', 'T', 'h', 'e', ' ', 'f', 'r', 'a', 'm', 'e', ' ', 'i', 'n',
    'd', 'e', 'x', ' ', 'o', 'f' };

  static const char_T cv17[74] = { ' ', 'R', 'O', 'I', ' ', 'a', 'c', 'c', 'u',
    'r', 'a', 'c', 'y', ' ', 'm', 'a', 'y', ' ', 'b', 'e', ' ', 'a', 'f', 'f',
    'e', 'c', 't', 'e', 'd', '.', ' ', 'T', 'h', 'e', ' ', 'f', 'r', 'a', 'm',
    'e', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'o', 'f', ' ', 'c', 'o', 'r', 'r',
    'e', 's', 'p', 'o', 'n', 'd', 'i', 'n', 'g', ' ', 'f', 'r', 'a', 'm', 'e',
    ' ', 'i', 's', ':', ' ' };

  static const char_T cv27[74] = { ' ', 'a', 's', 's', 'i', 'g', 'n', 'e', 'd',
    ' ', 'a', ' ', 's', 'i', 'z', 'e', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'f',
    'o', 'r', ' ', 'a', 'n', ' ', 'R', 'O', 'I', ' ', 't', 'h', 'a', 't', ' ',
    'i', 's', ' ', 'b', 'e', 'l', 'o', 'w', ' ', '2', '0', ' ', 'p', 'i', 'x',
    'e', 'l', 's', ',', ' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'l',
    'i', 'k', 'e', 'l', 'y' };

  static const char_T cv50[74] = { '.', ' ', 'D', 'e', 't', 'e', 'c', 't', 'e',
    'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i',
    'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ' ', 'i', 'n', ' ', 'f',
    'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R',
    '_', 'F', 'r', 'a', 'm', 'e', 'B', 'y', 'F', 'r', 'a', 'm', 'e', 'S', 'm',
    'o', 'o', 't', 'h', '.' };

  static const char_T cv59[74] = { 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ',
    'E', 'r', 'r', 'o', 'r', ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',',
    ' ', 'c', 'o', 'd', 'e', ' ', '2', '2', ')', ':', ' ', 'S', 'm', 'o', 'o',
    't', 'h', 'i', 'n', 'g', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n',
    ' ', 'c', 'o', 'n', 'd', 'u', 'c', 't', 'e', 'd', ' ', 'w', 'i', 't', 'h',
    ' ', 'R', 'O', 'I', 's' };

  static const char_T cv43[73] = { 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ',
    'E', 'r', 'r', 'o', 'r', ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',',
    ' ', 'c', 'o', 'd', 'e', ' ', '2', '4', ')', ':', ' ', 'R', 'O', 'I', '-',
    'm', 'o', 'd', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p',
    'e', 'r', 'a', 't', 'i', 'o', 'n', 's', ' ', 'a', 's', 's', 'i', 'g', 'n',
    'e', 'd', ' ', 'a' };

  static const char_T cv61[73] = { '.', ' ', 'S', 'm', 'o', 'o', 't', 'h', 'i',
    'n', 'g', ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c', 'y', ' ', 'm', 'a', 'y',
    ' ', 'b', 'e', ' ', 'a', 'f', 'f', 'e', 'c', 't', 'e', 'd', '.', ' ', 'D',
    'e', 't', 'e', 'c', 't', 'e', 'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ',
    'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I',
    'R', ' ', 'i', 'n' };

  static const char_T cv26[72] = { 'P', 'o', 't', 'e', 'n', 't', 'i', 'a', 'l',
    ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'E', 'r', 'r', 'o', 'r',
    ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',', ' ', 'c', 'o', 'd', 'e',
    ' ', '1', '1', ')', ':', ' ', 'R', 'O', 'I', '-', 'm', 'o', 'd', 'i', 'f',
    'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i',
    'o', 'n', 's' };

  static const char_T cv34[72] = { 'P', 'o', 't', 'e', 'n', 't', 'i', 'a', 'l',
    ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'E', 'r', 'r', 'o', 'r',
    ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',', ' ', 'c', 'o', 'd', 'e',
    ' ', '1', '5', ')', ':', ' ', 'R', 'O', 'I', '-', 'm', 'o', 'd', 'i', 'f',
    'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i',
    'o', 'n', 's' };

  static const char_T cv41[72] = { 'P', 'o', 't', 'e', 'n', 't', 'i', 'a', 'l',
    ' ', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'E', 'r', 'r', 'o', 'r',
    ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',', ' ', 'c', 'o', 'd', 'e',
    ' ', '3', '0', ')', ':', ' ', 'R', 'O', 'I', '-', 'm', 'o', 'd', 'i', 'f',
    'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i',
    'o', 'n', 's' };

  static const char_T cv57[72] = { ' ', 'w', 'i', 't', 'h', ' ', 'R', 'O', 'I',
    's', ' ', 'w', 'i', 't', 'h', ' ', 's', 'i', 'z', 'e', ' ', 'v', 'a', 'l',
    'u', 'e', 's', ' ', 'b', 'e', 'l', 'o', 'w', ' ', '2', '0', ' ', 'p', 'i',
    'x', 'e', 'l', 's', ',', ' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ',
    'l', 'i', 'k', 'e', 'l', 'y', ' ', 'i', 'n', 'a', 'c', 'c', 'u', 'r', 'a',
    't', 'e', '.' };

  static const char_T cv22[71] = { ' ', 'a', 's', 's', 'i', 'g', 'n', 'e', 'd',
    ' ', 'a', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'o', 'f', ' ', 'z', 'e', 'r',
    'o', ' ', 'f', 'o', 'r', ' ', 'a', 'n', ' ', 'R', 'O', 'I', '.', ' ', 'R',
    'O', 'I', ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c', 'y', ' ', 'm', 'a', 'y',
    ' ', 'b', 'e', ' ', 'a', 'f', 'f', 'e', 'c', 't', 'e', 'd', '.', ' ', 'T',
    'h', 'e' };

  static const char_T cv24[71] = { '.', ' ', 'D', 'e', 't', 'e', 'c', 't', 'e',
    'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i',
    'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ' ', 'i', 'n', ' ', 'f',
    'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R',
    '_', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', 'S', 'm', 'o', 'o', 't',
    'h', '.' };

  static const char_T cv49[71] = { '.', ' ', 'S', 'm', 'o', 'o', 't', 'h', 'i',
    'n', 'g', ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c', 'y', ' ', 'm', 'a', 'y',
    ' ', 'b', 'e', ' ', 'a', 'f', 'f', 'e', 'c', 't', 'e', 'd', '.', ' ', 'D',
    'e', 't', 'e', 'c', 't', 'e', 'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ',
    'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I',
    'R', ' ' };

  static const char_T cv10[70] = { 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ',
    'E', 'r', 'r', 'o', 'r', ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',',
    ' ', 'c', 'o', 'd', 'e', ' ', '6', ')', ':', ' ', 'R', 'O', 'I', '-', 'm',
    'o', 'd', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p', 'e',
    'r', 'a', 't', 'i', 'o', 'n', 's', ' ', 'a', 's', 's', 'i', 'g', 'n', 'e',
    'd' };

  static const char_T cv40[70] = { '.', ' ', 'D', 'e', 't', 'e', 'c', 't', 'e',
    'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i',
    'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ' ', 'i', 'n', ' ', 'f',
    'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R',
    '_', 'O', 'u', 't', 'p', 'u', 't', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e',
    '.' };

  static const char_T cv31[69] = { ' ', 'o', 'f', ' ', 'z', 'e', 'r', 'o', ' ',
    'f', 'o', 'r', ' ', 'a', 'n', ' ', 'R', 'O', 'I', '.', ' ', 'R', 'O', 'I',
    ' ', 'a', 'c', 'c', 'u', 'r', 'a', 'c', 'y', ' ', 'm', 'a', 'y', ' ', 'b',
    'e', ' ', 'a', 'f', 'f', 'e', 'c', 't', 'e', 'd', '.', ' ', 'T', 'h', 'e',
    ' ', 'f', 'r', 'a', 'm', 'e', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'o', 'f' };

  static const char_T cv11[68] = { ' ', 'a', ' ', 'v', 'a', 'l', 'u', 'e', ' ',
    'o', 'f', ' ', 'z', 'e', 'r', 'o', ' ', 'f', 'o', 'r', ' ', 'a', 'n', ' ',
    'R', 'O', 'I', '.', ' ', 'R', 'O', 'I', ' ', 'a', 'c', 'c', 'u', 'r', 'a',
    'c', 'y', ' ', 'm', 'a', 'y', ' ', 'b', 'e', ' ', 'a', 'f', 'f', 'e', 'c',
    't', 'e', 'd', '.', ' ', 'T', 'h', 'e', ' ', 'f', 'r', 'a', 'm', 'e' };

  static const char_T cv44[68] = { 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ',
    'E', 'r', 'r', 'o', 'r', ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',',
    ' ', 'c', 'o', 'd', 'e', ' ', '2', '0', ')', ':', ' ', 'I', 'n', 't', 'e',
    'r', 'p', 'o', 'l', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p', 'e', 'r', 'a',
    't', 'i', 'o', 'n', ' ', 'c', 'o', 'n', 'd', 'u', 'c', 't', 'e', 'd' };

  static const char_T cv33[67] = { '.', ' ', 'D', 'e', 't', 'e', 'c', 't', 'e',
    'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i',
    'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ' ', 'i', 'n', ' ', 'f',
    'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R',
    '_', 'I', 'n', 't', 'e', 'r', 'p', 'o', 'l', 'a', 't', 'e', '.' };

  static const char_T cv13[65] = { '.', ' ', 'D', 'e', 't', 'e', 'c', 't', 'e',
    'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i',
    'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ' ', 'i', 'n', ' ', 'f',
    'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R',
    '_', 'M', 'a', 't', 'c', 'h', 'S', 'i', 'z', 'e', '.' };

  static const char_T cv21[62] = { 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ',
    'E', 'r', 'r', 'o', 'r', ' ', '(', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ',',
    ' ', 'c', 'o', 'd', 'e', ' ', '1', '0', ')', ':', ' ', 'R', 'O', 'I', '-',
    'm', 'o', 'd', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'p',
    'e', 'r', 'a', 't', 'i', 'o', 'n', 's' };

  static const char_T cv65[61] = { ' ', 'm', 'a', 'y', ' ', 'b', 'e', ' ', 'a',
    'f', 'f', 'e', 'c', 't', 'e', 'd', '.', ' ', 'T', 'h', 'e', ' ', 'f', 'r',
    'a', 'm', 'e', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'o', 'f', ' ', 'c', 'o',
    'r', 'r', 'e', 's', 'p', 'o', 'n', 'd', 'i', 'n', 'g', ' ', 'f', 'r', 'a',
    'm', 'e', ' ', 'i', 's', ':', ' ' };

  static const char_T cv51[47] = { ' ', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't',
    'i', 'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', '_', 'F', 'r', 'a',
    'm', 'e', 'B', 'y', 'F', 'r', 'a', 'm', 'e', 'S', 'm', 'o', 'o', 't', 'h',
    '_', 'I', 'n', 't', 'e', 'r', 'p', '.' };

  static const char_T cv18[46] = { '.', ' ', 'D', 'e', 't', 'e', 'c', 't', 'e',
    'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i',
    'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', ' ', 'i', 'n', ' ', 'f',
    'u', 'n', 'c', 't', 'i', 'o', 'n' };

  static const char_T cv62[46] = { ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n',
    ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', '_', 'F', 'r', 'a', 'm', 'e', 'B',
    'y', 'F', 'r', 'a', 'm', 'e', 'S', 'm', 'o', 'o', 't', 'h', '_', 'S', 'm',
    'o', 'o', 't', 'h', 'F', 'R', '.' };

  static const char_T cv48[45] = { ' ', 'e', 'q', 'u', 'a', 'l', ' ', '1', '1',
    '5', '.', ' ', 'T', 'h', 'e', ' ', 'f', 'r', 'a', 'm', 'e', ' ', 'i', 'n',
    'd', 'e', 'x', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'f', 'r', 'a', 'm',
    'e', ' ', 'i', 's', ':', ' ' };

  static const char_T cv23[44] = { ' ', 'f', 'r', 'a', 'm', 'e', ' ', 'i', 'n',
    'd', 'e', 'x', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'r', 'r',
    'e', 's', 'p', 'o', 'n', 'd', 'i', 'n', 'g', ' ', 'f', 'r', 'a', 'm', 'e',
    ' ', 'i', 's', ':', ' ' };

  static const char_T cv8[40] = { ' ', 'z', 'e', 'r', 'o', '.', ' ', 'T', 'h',
    'e', ' ', 'f', 'r', 'a', 'm', 'e', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'o',
    'f', ' ', 't', 'h', 'e', ' ', 'f', 'r', 'a', 'm', 'e', ' ', 'i', 's', ':',
    ' ' };

  static const char_T cv46[39] = { ' ', 'w', 'i', 't', 'h', ' ', 'R', 'O', 'I',
    's', ' ', 't', 'h', 'a', 't', ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', ' ',
    'z', 'e', 'r', 'o', 's', ' ', 'a', 't', ' ', 'f', 'r', 'a', 'm', 'e', ' ' };

  static const char_T cv53[37] = { ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', '_',
    'F', 'r', 'a', 'm', 'e', 'B', 'y', 'F', 'r', 'a', 'm', 'e', 'S', 'm', 'o',
    'o', 't', 'h', '_', 'S', 'm', 'o', 'o', 't', 'h', 'F', 'R', '.' };

  static const char_T cv4[35] = { '.', ' ', 'D', 'e', 't', 'e', 'c', 't', 'e',
    'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i',
    'o', 'n', ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', '.' };

  static const char_T cv58[35] = { ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', '_',
    'F', 'r', 'a', 'm', 'e', 'B', 'y', 'F', 'r', 'a', 'm', 'e', 'S', 'm', 'o',
    'o', 't', 'h', '_', 'I', 'n', 't', 'e', 'r', 'p', '.' };

  static const char_T cv12[34] = { ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'o', 'f',
    ' ', 'c', 'o', 'r', 'r', 'e', 's', 'p', 'o', 'n', 'd', 'i', 'n', 'g', ' ',
    'f', 'r', 'a', 'm', 'e', ' ', 'i', 's', ':', ' ' };

  static const char_T cv2[34] = { ' ', 'T', 'h', 'e', ' ', 'f', 'r', 'a', 'm',
    'e', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ',
    'f', 'r', 'a', 'm', 'e', ' ', 'i', 's', ':', ' ' };

  static const char_T cv60[29] = { ' ', 't', 'h', 'a', 't', ' ', 'c', 'o', 'n',
    't', 'a', 'i', 'n', ' ', 'z', 'e', 'r', 'o', 's', ' ', 'a', 't', ' ', 'f',
    'r', 'a', 'm', 'e', ' ' };

  static const char_T cv32[25] = { ' ', 'c', 'o', 'r', 'r', 'e', 's', 'p', 'o',
    'n', 'd', 'i', 'n', 'g', ' ', 'f', 'r', 'a', 'm', 'e', ' ', 'i', 's', ':',
    ' ' };

  static const char_T cv3[23] = { 'C', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't',
    ':', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', 'E', 'r', 'r', 'o', 'r' };

  static const char_T cv19[19] = { ' ', 'R', 'O', 'I', 'M', 'S', 'I', 'R', '_',
    'M', 'a', 't', 'c', 'h', 'S', 'i', 'z', 'e', '.' };

  static const char_T cv1[16] = { ' ', ' ', 'n', 'o', 't', ' ', 'e', 'q', 'u',
    'a', 'l', ' ', '1', '1', '5', '.' };

  static const char_T cv29[11] = { ' ', 'f', 'r', 'a', 'm', 'e', ' ', 'i', 's',
    ':', ' ' };

  emxArray_boolean_T c_x;
  emxArray_boolean_T *b_HasROI_TF;
  emxArray_boolean_T *b_x;
  emxArray_boolean_T *x;
  emxArray_char_T *r1;
  emxArray_char_T *varargin_2;
  emxArray_int16_T *ROIBlockFaceSkin_Temp;
  emxArray_int16_T *ROINoPrevCallsBlock_SR;
  emxArray_int16_T *ROIWidthHeightPreSmooth;
  emxArray_int16_T *SmoothedXYColumn;
  emxArray_int16_T *c_NoPrevCallsBlock_ROIDetection;
  emxArray_int16_T *r;
  emxArray_int32_T *BlockFullLinIdx_SR;
  emxArray_int32_T *FramesToAdjust;
  emxArray_int32_T *ROIBlockDetectionFaceLinIdx_SR;
  emxArray_int32_T *ROIBlockDetectionSkinLinIdx_SR;
  emxArray_int32_T *SkinIdxFit;
  emxArray_int32_T *c_ROIBlockDetectionFaceSkinLinI;
  emxArray_real32_T *TimestampBlockDetections_SR;
  emxArray_real32_T *TimestampBlock_SR;
  emxArray_real32_T *r2;
  emxArray_real32_T *y;
  int32_T BlockFullLinIdx_FR[229];
  int32_T c_ROIBlockDetectionSkinLinIdx_F[229];
  int32_T f_ROIBlockNoDetectionFaceSkinLi[229];
  int32_T g_ROIBlockNoDetectionFaceSkinLi[229];
  int32_T ROIBlockFaceSkin_Temp_size[2];
  int32_T ROIWidthHeightPreSmooth_size[2];
  int32_T HasROI_TF_size[1];
  int32_T b_VideoReadConfig_FrameIdx_FR[1];
  int32_T c_VideoReadConfig_FrameIdx_FR[1];
  int32_T d_VideoReadConfig_FrameIdx_FR[1];
  int32_T e_VideoReadConfig_FrameIdx_FR[1];
  int32_T f_VideoReadConfig_FrameIdx_FR[1];
  int32_T g_VideoReadConfig_FrameIdx_FR[1];
  int32_T FrameByFrameSmoothingWin_WHHalf;
  int32_T Idx;
  int32_T NDetectionsFaceSkin_FR;
  int32_T NDetectionsFaceSkin_SR;
  int32_T NDetectionsFace_FR;
  int32_T NDetectionsFace_SR;
  int32_T NDetectionsSkin_FR;
  int32_T NDetectionsSkin_SR;
  int32_T NNoDetectionsFaceSkin_FR;
  int32_T NNoDetectionsFaceSkin_SR;
  int32_T RowToReturnBlockLinIdx_FR;
  int32_T Start;
  int32_T Sum;
  int32_T VideoReadConfig_FrameIdx_Length;
  int32_T b_i;
  int32_T c_ROIBlockNoDetectionFaceSkinLi;
  int32_T c_TimestampBlockDetections_FR_s;
  int32_T d_NoPrevCallsBlock_ROIDetection;
  int32_T d_ROIBlockDetectionFaceSkinLinI;
  int32_T d_ROIBlockNoDetectionFaceSkinLi;
  int32_T exitg2;
  int32_T i;
  int32_T i1;
  int32_T j;
  int32_T n;
  int32_T winNew;
  int32_T z;
  real32_T TimestampBlock_FR[229];
  real32_T c_TimestampBlockDetections_FR_d[229];
  real32_T HeightRatio_Single;
  real32_T WidthRatio_Single;
  real32_T b_r;
  real32_T x_after;
  real32_T xi_ith_tmp;
  uint32_T b_y;
  uint32_T d_x;
  uint32_T q;
  int16_T ROIBlockFaceSkin_Temp_data[916];
  int16_T ROIBlock_FR[916];
  int16_T ROINoPrevCallsBlock_FR[916];
  int16_T ROINoResizeBlock_FR[916];
  int16_T e_NoPrevCallsBlock_ROIDetection[916];
  int16_T ROIWidthHeightPreSmooth_data[458];
  int16_T yi_ith[4];
  int16_T HeightNew_ith;
  int16_T Height_ith;
  int16_T WidthNew_ith;
  int16_T Width_ith;
  uint16_T b_q;
  uint16_T e_x;
  char_T cv54[464];
  uint8_T InterpTheseLinIdx_data[458];
  uint8_T ROIBlockDetectionSkinLinIdx[229];
  uint8_T c_ROIBlockBeforeFirstCallDetect[229];
  uint8_T c_ROIBlockDetectionFaceLinIdx_F[229];
  uint8_T e_ROIBlockDetectionFaceSkinLinI[229];
  uint8_T e_ROIBlockNoDetectionFaceSkinLi[229];
  uint8_T f_ROIBlockDetectionFaceSkinLinI[229];
  uint8_T u;
  boolean_T HasROI_TF_data[458];
  boolean_T FaceOrSkinTF;
  boolean_T MatchTF;
  boolean_T exitg1;
  boolean_T guard1 = false;
  boolean_T guard2 = false;
  boolean_T guard3 = false;
  emlrtHeapReferenceStackEnterFcnR2012b(emlrtRootTLSGlobal);
  emxInit_int32_T(&BlockFullLinIdx_SR, 1, true);
  emxInit_real32_T(&TimestampBlock_SR, 1, true);
  emxInit_real32_T(&TimestampBlockDetections_SR, 1, true);
  emxInit_int16_T(&ROINoPrevCallsBlock_SR, 2, true);
  emxInit_int16_T(&c_NoPrevCallsBlock_ROIDetection, 2, true);
  emxInit_int32_T(&ROIBlockDetectionFaceLinIdx_SR, 1, true);
  emxInit_int32_T(&ROIBlockDetectionSkinLinIdx_SR, 1, true);
  emxInit_int32_T(&c_ROIBlockDetectionFaceSkinLinI, 1, true);

  /* ROIMSIR   Modify ROI(s) size and position by matching size across algorithms, ROI-detection    */
  /*           smoothing, interpolation, frame-by-frame smoothing, and resizing.                                         */
  /*  */
  /*     Helper function to function FacePulseRate.  */
  /*     Within function FacePulseRate, called by functions ROIMeans_FirstRead_TakeMeans and  */
  /*     ROIMeans_SecondRead. */
  /*  */
  /*  */
  /*     Code Generation */
  /*     --------------- */
  /*  */
  /*     Can be called as a Matlab function or used for C-language code generation. */
  /*  */
  /*     Compiled file: The compiled file included in folder FacePulseRate (ROIMSIR_mex.mexw64) only     */
  /*     compatible on Windows platforms.      */
  /*  */
  /*  */
  /*     Description */
  /*     ----------- */
  /*  */
  /*     The size and position of ROI(s) are modified to increase stability and accuracy across frames. */
  /*     By increasing stability, fluctuations in size and position that could introduce artifacts to  */
  /*     the pulse rate algorithms are reduced. Accuracy is improved by allowing the ROIs of nearby   */
  /*     frames to influence the size and position of a given frame. This assumption is that it is less  */
  /*     likely for a group of ROIs to be inaccurate than a single ROI to be inaccurate. Additionally, */
  /*     frames without an ROI from a detection are interpolated. Some frames may not have an ROI if  */
  /*     the detection algorithms were skipped for certain frames for efficiency (see function  */
  /*     ROIMeans_FirstRead_DetermineSkipFrame) or if none of the detection algorithms were successful */
  /*     for some frames. */
  /*  */
  /*     ROI(s) to be returned are processed differently depending on whether they (1) correspond to a */
  /*     detection or whether they (2) do not correspond a detection, in which case interpolation */
  /*     will be conducted.   */
  /*  */
  /*     (1) ROI(s) to be returned that correspond to detection(s):  */
  /*     */
  /*       If the ROI(s) to be returned correspond to face-detection algorithm or skin-detection  */
  /*       algorithm detection(s), four modications are made: */
  /*  */
  /*       (i) Size matching (function ROIMSIR_MatchSize): if the ROI(s) do not correspond to a primary  */
  /*       face-detection algorithm detection, the size of the ROI is matched to the size of primary    */
  /*       face-detection algorithm ROIs to increase stability of size of ROIs across frames.  */
  /*  */
  /*       (ii) Detection smoothing (function ROIMSIR_DetectionSmooth): the ROI(s) are smoothed with  */
  /*       nearby ROIs that correspond to face-detection algorithm detections to reduce outliers.  */
  /*       Nearby ROIs that correspond to skin-detection algorithm detections are not used because  */
  /*       face-detection algorithm detections tend to be more accurate. Detection smoothing is used to   */
  /*       increase stability and accuracy of ROI position and size across frames. */
  /*  */
  /*       (iii) Frame-by-frame smoothing (function ROIMSIR_FrameByFrameSmooth): the ROI(s) are  */
  /*       smoothed with all nearby ROIs regardless of whether the ROIs correspond to detections. These  */
  /*       nearby ROIs will have size matching and detection smoothing applied to them to increase   */
  /*       their stability and accuracy. Frame-by-frame smoothing conducts a finer level of adjustments   */
  /*       compared to size matching and detection smoothing. Frame-by-frame smoothing, like detection   */
  /*       smoothing, is intended to increase stability and accuracy of ROI position and size across  */
  /*       frames. */
  /*  */
  /*       (iv) ROI resizing (function ROIResize): ROI resizing resizes ROIs according to   */
  /*       ROIWidthResizeFactor and ROIHeightResizeFactor, which are arguments to function  */
  /*       FacePulseRate. The values of these arguments are specified to maximize facial skin and  */
  /*       minimize non-skin within the ROI. */
  /*      */
  /*     (2) ROI(s) to be returned that do not correspond to detection(s): */
  /*  */
  /*       If an ROI does not correspond to a detection, which indicates either the frame was skipped  */
  /*       or no detection was made, three opertions will be conducted: */
  /*  */
  /*       (i) Interpolation (function ROIMSIR_Interpolate): The ROI(s) are interpolated from nearby     */
  /*       ROIs that correspond to detections. These nearby ROIs will have size matching and detection     */
  /*       smoothing applied to them to increase their stability and accuracy before being used in    */
  /*       interpolation. (The size matching and detection smoothing applied to nearby ROIs is only     */
  /*       conducted for the purpose of interpolation, and these nearby ROIs are not returned as  */
  /*       output). */
  /*  */
  /*       (ii) Frame-by-frame smoothing (function ROIMSIR_FrameByFrameSmooth): see descripton provided  */
  /*       above. */
  /*  */
  /*       (iii) ROI resizing (function ROIResize): see descripton provided above.     */
  /*  */
  /*       Note:  */
  /*  */
  /*       If fewer than two ROIs within the ROI block (BlockFullLinIdx_In) correspond to a detection,  */
  /*       then interpolation is not possible as the interpolation method used is linear interpolation,  */
  /*       which requires at least two points to draw upon.  */
  /*  */
  /*       If exactly one ROI within the ROI block corresponds to a detection, then the ROI output  */
  /*       depends upon whether the function is called during the first-read (FirstReadTF == true) or */
  /*       second-read operations. If called during the first-read operations, then the output ROIs are */
  /*       assignd the values of the one ROI that corresponds to a detection. If called during the */
  /*       second-read operations, then the output ROIs are assigned the dimensions of the full frame.  */
  /*       The output of the second-read operations is different from the output of the first-read */
  /*       operations in this case because the ROI block is expected to be larger during the    */
  /*       second-read operations, and it is assumed that basing the values of all ROIs on one ROI may    */
  /*       likely lead to inaccuracies.  */
  /*  */
  /*       In the case that no ROIs within the ROI block correspond to a detection, then the output  */
  /*       ROIs are assigned the dimensions of the full frame. */
  /*  */
  /*       In the event that the full frame dimensions are assigned, then Frame-by-frame smoothing and */
  /*       ROI resizing are not conducted. */
  /*  */
  /*     Implementation differences between first-read and second-read operations: */
  /*  */
  /*     FirstReadTF == true indicates that the function is being called during the first-read  */
  /*     operations (specifically, by function ROIMeans_FirstRead_TakeMeans). FirstReadTF == false  */
  /*     indicates that the function is being called during the second-read operations (specifically,  */
  /*     by function ROIMeans_SecondRead). Different implementations are used depending on this */
  /*     argument. Different implementations are used for four reasons.  */
  /*  */
  /*     (1) During the first-read operations, the ROIs corresponding to a single frame (ROIOut_FR and */
  /*     ROIOutBeforeFrameByFrameSmoothing_FR) are returned. During the second-read operations, the  */
  /*     ROIs corresponding to a multiple frames (ROIOut_SR and ROIOutBeforeFrameByFrameSmoothing_SR) */
  /*     are returned. As multiple ROIs are processed during second-read operations, a vectorized  */
  /*     implementation is used during second-read operations. For the single ROIs returned during */
  /*     first-read operations, a vectorized implementation was observed to add additional overhead. */
  /*     The function is called potentially thousands of times during first-read operations, so the */
  /*     accummulation of this overhead became noticable. Consequently, the first-read implementation */
  /*     was designed without vectorization for operations where vectorization would not be relevant. */
  /*  */
  /*     (2) During the first-read, but not the second-read, operations, the function is called    */
  /*     sequentially (frame-by-frame) (see function ROIMeans_FirstRead_TakeMeans). When called   */
  /*     sequentially, a positive feedback loop was observed to develop that resulted in noticable  */
  /*     oscillations of ROI values. The feedback loop developed because the values of ROIs previously    */
  /*     returned reentered as input on each call (although the first-read operations return the ROIs */
  /*     for only a single frame on each call, a block of ROIs is used as input to conduct the  */
  /*     operations). This feedback loop is analogous to the feedback loop that develops between a  */
  /*     microphone and a speaker. Consequently, the first-read implementation takes steps to remove */
  /*     the cause of the feedback loop. Specifically, ROI values that were returned previously do not */
  /*     reenter the function. To use ROIs values that were not returned previously, a variable  */
  /*     (ROINoMods) is used that holds ROI values that were not returned by the function. */
  /*      */
  /*     (3) During second-read operations, the function is applied to the same ROIs on two occassions */
  /*     (second-read pre-processing and second-read post-processing) (see function */
  /*     ROIMeans_SecondRead). Because the same ROIs are processed twice by the function, the  */
  /*     second-read implementation takes steps to avoid applying the same operations to the same ROIs */
  /*     if the state of the ROIs did not change between the pre-processing and post-processing steps.   */
  /*     The argument SecondReadPreProcessingTF indicates whether the function is being called during  */
  /*     the pre-processing or post-processing step. During the first-read operations, the value of */
  /*     SecondReadPreProcessingTF is not relevant. */
  /*  */
  /*     (4) To increase efficiency of the compiled version of function ROIMSIR (ROIMSIR_mex), ROIMSIR  */
  /*     was developed so that the first-read operations take an execution path separate from the  */
  /*     second-read operations. Separate execution paths were developed so that Matlab code generation   */
  /*     can make separate functions for each path (termed "function specialization") if doing so   */
  /*     increases efficiency. Function specialization can increase efficiency when some versions of */
  /*     variables can use static, rather than dynamic, memory allocation or if some versions of  */
  /*     variables can used fixed, rather than variable, sizes.  */
  /*  */
  /*     To facilitate function specialization, the execution path of the first-read operations was   */
  /*     developed such that variable BlockFullLinIdx_FR is always a fixed-length. If always a fixed */
  /*     length, dynamic memory allocation can be avoided and fixed-size variables can be utilized in   */
  /*     the compiled function. Moreover, many variables along the execution will be assigned with the */
  /*     length of this variable, so they, too, can avoid dynamic memory allocation and utlize  */
  /*     fixed-size variables in the compiled function. */
  /*    */
  /*     To further discourage dymanic memory allocation and utilize fixed-size variables, a   */
  /*     fixed-length ROI block row of 229 is used for first-read operations. The value 229 corresponds */
  /*     to the length of the frame cache (see function ROIMeans_FirstRead_TakeMeans) multipled by two  */
  /*     with 1 added (115 * 2 + 1). */
  /*  */
  /*     Second-read operations require a variable-length version of BlockFullLinIdx_FR  */
  /*     (BlockFullLinIdx_SR), so second-read operations use a separate execution path to accommodate  */
  /*     this and avoid placing this requirement on  first-read operations. Note that although  */
  /*     first-read and second-read operations use separate execution paths using different variable  */
  /*     sizes, they actually undergo the same operations in most cases.   */
  /*  */
  /*     Internal error-checking: */
  /*  */
  /*     During development, small changes to the implementation can result in bugs that can be  */
  /*     difficult to detect intially and to trace. To detect such bugs immediately and indicate their */
  /*     origin, several checks are implemented in this function and the functions it calls. The */
  /*     warnings and errors thrown from these bugs use the message identifier "internal error", which */
  /*     indicates an implementation error rather than an error resulting from user input.  */
  /*  */
  /*     Because this function may be compiled, the function stack trace displayed on the command  */
  /*     window will not be able to identify which of the functions called within ROIMSIR threw the  */
  /*     error or warning. Given this, as well as the large number of potential error or warning  */
  /*     messages within the function, each error and warning will display a unique code for better  */
  /*     identification. */
  /*  */
  /*  */
  /*     Note */
  /*     ---- */
  /*  */
  /*     Intended only when input variable ROI uses integer types as rounding is not conducted. For  */
  /*     modification for use with floating-point types, rounding would be necessary as ROI values  */
  /*     should be integers. */
  /*  */
  /*  */
  /*     Inputs */
  /*     ------ */
  /*  */
  /*         BlockFullLinIdx_In = Linear index corresponding to frame index of block of frames used in  */
  /*                              operations. A block of frames is used as input even if the output */
  /*                              consists of ROIs corresponding to a single frame. 299 x 1 in first  */
  /*                              read and M x 1 in second read; type int32. */
  /*         ROI                = ROI matrix. M x 4; type int16.  */
  /*         Timestamp          = Timestamp for each frame. Column vector; type single.                                         */
  /*         HasROI_TF          = Struct with information regarding ROIs. See file  */
  /*                              ROIMeans_ROIVarsSetup. Scalar struct. */
  /*         VidObjWidth        = Frame width in pixels. Scalar; type int16. */
  /*         VidObjHeight       = Frame height in pixels. Scalar; type int16. */
  /*         FirstReadTF        = Logical value where true indicates that the function is being called  */
  /*                              during the first-read operations (by function */
  /*                              ROIMeans_FirstRead_TakeMeans) and false indicates the function is   */
  /*                              being called during second-read operations (by function */
  /*                              ROIMeans_SecondRead). If true, a one-row ROI is returned as output; */
  /*                              otherwise, an ROI with an arbitrary number of rows can be returned.  */
  /*                              Scalar; type logical. */
  /*         SecondReadPostProcessingTFCode = Logical value where true indicates that the function is   */
  /*                              being called during the second-read operations post-processing step */
  /*                              and false indicates otherwise. When FirstReadTF == false and  */
  /*                              SecondReadPostProcessingTFCode == true, the function is being called */
  /*                              during the second-read operations pre-processing step. Scalar; type  */
  /*                              logical. */
  /*         ROIGeneralConfig_MatchSmoothInterpolateResize_DiffMax = Maximum distance permitted between */
  /*                              an interpolated ROI and the previous ROI. Scalar; type int16.                            */
  /*         ROIGeneralConfig_ROIWidthResizeFactor = Amount by which to resize width. Argument to   */
  /*                              function FacePulseRate. Scalar; type double.                              */
  /*         ROIGeneralConfig_ROIHeightResizeFactor = Amount by which to resize width. Argument to   */
  /*                              function FacePulseRate Scalar; type double. */
  /*         FaceDetectConfig_ROIFaceSecondary1TF = Logical value indicating whether the secondary #1 */
  /*                              face-detection algorithm is enabled. Argument to function  */
  /*                              FacePulseRate. Scalar; type logical. */
  /*         FaceDetectConfig_ROIFaceSecondary2TF = Logical value indicating whether the secondary #2 */
  /*                              face-detection algorithm is enabled. Argument to function  */
  /*                              FacePulseRate. Scalar; type logical. */
  /*         FaceDetectConfig_ROIFaceSmoothingWindow = Amount by which to smooth ROI position for ROIs */
  /*                              corresponding to face-detection algorithm detections. Argument to   */
  /*                              function FacePulseRate. Scalar; type double.                                                          */
  /*         SkinDetectConfig_ROISkinSmoothingWindow = Amount by which to smooth ROI position for ROIs */
  /*                              corresponding to skin-detection algorithm detections. Argument to   */
  /*                              function FacePulseRate. Scalar; type double.            */
  /*         ROIGeneralConfig_ROIFinalSmoothingWindows = Amounts by which to smooth ROI position and  */
  /*                              size, respectively. Argument to function FacePulseRate. 1 x 2; type  */
  /*                              int32.   */
  /*         ExpectedBehaviorTestTF = Whether testing is enabled to determine whether ROI widths and  */
  /*                              heights are below a certain value after various steps of the  */
  /*                              operations. If below the value, this may indicate that the  */
  /*                              implementation is not behaving as expected. Occasionally, however, */
  /*                              widths or heights may be below the value in the absence of an */
  /*                              implementation issue. If a width or height is below the value, a */
  /*                              warning is displayed. This option is intended to be enabled only  */
  /*                              during testing. Otherwise, to increase efficiency and avoid the  */
  /*                              display of unnecessary warnings, it should be disabled. */
  /*  */
  /*         The following inputs are relevant only during the first-read operations: */
  /*  */
  /*         RowToReturnFullLinIdx_FR = Frame index of the block of ROIs to be used in operations.   */
  /*                                    Note that, within this function, another variable  */
  /*                                    (RowToReturnBlockLinIdx_FR) is assigned to act as an index of    */
  /*                                    this variable itself; for example, if RowToReturnFullLinIdx_FR   */
  /*                                    contains values 300 : 500, RowToReturnBlockLinIdx_FR would     */
  /*                                    contain values 1 : 300. Scalar; type int32. */
  /*         ROINoMods                = ROI matrix without ROI values previously returned by the   */
  /*                                    function. This variable is used to prevent a positive feedback  */
  /*                                    loop (see notes at top of file). Size is same as input "ROI"; */
  /*                                    type int16. */
  /*         ROINoResize              = ROI matrix with ROIOutNoResize_FR values previously returned by    */
  /*                                    the function. These ROIs received all operations in the current */
  /*                                    function except resizing. Size is same as input "ROI"; type  */
  /*                                    int16. */
  /*         ROIMSIR_FirstFrameLinIdx_FR = Frame index indicating the first frame that was called by   */
  /*                                    the function. This index will be used by helper function                             */
  /*                                    ROIMSIR_FrameByFrameSmooth. Scalar; type int32.      */
  /*         VideoReadConfig_FrameIdx_FR = Frame index for use in warning and error messages (see notes   */
  /*                                    at top of file regarding internal errors). Column vector; type  */
  /*                                    int32. */
  /*  */
  /*  */
  /*     Copyright */
  /*     --------- */
  /*  */
  /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), September, 2020. Licensed under the MIT License    */
  /*     and the Responsible AI License (RAIL). */
  /*  %%%%%%%%%%%%%%%% */
  /* %% Setup %%%%%%%%% */
  /* %%%%%%%%%%%%%%%%%%           */
  /* %%%%% Code-generation settings %%%%%% */
  /* Specify inlining for faster code execution */
  /* Call function as extrinsic so that stack trace can be displayed */
  /* %%%%% Declare and initialize variables %%%%%% */
  /* Note: regarding "coder.nullcopy", see Matlab documentation topic "Eliminate Redundant Copies   */
  /* of Variables in Generated Code". */
  /* %%%%% --- Variables in first-read operations %%%%%% */
  /* Declare variable-size variables: */
  /*                                                       Upp. Bounds  Var. Size (T/F) */
  /* Initialize variables: */
  /* Note: constant 229 assumes that the length of BlockFullLinIdx == 229. If the length of this  */
  /* variable were to change, the constant would need to be modified.  */
  *InterpolatedLinIdx_FR = 0;

  /* note: 0 will be indication that interpolation not conducted */
  RowToReturnBlockLinIdx_FR = -2;

  /* scalar needed here */
  c_TimestampBlockDetections_FR_s = 229;
  d_NoPrevCallsBlock_ROIDetection = 0;
  FrameByFrameSmoothingWin_WHHalf = 229;
  d_ROIBlockDetectionFaceSkinLinI = 229;
  c_ROIBlockNoDetectionFaceSkinLi = 229;

  /* %%%%% --- Variables in second-read operations %%%%%% */
  /* Declare variable-size variables: */
  /*                                                        Upp. Bounds  Var. Size (T/F) */
  /* Initialize variables: */
  ROIOut_SR->size[0] = 0;
  ROIOut_SR->size[1] = 4;
  d_ROIOutBeforeFrameByFrameSmoot->size[0] = 0;
  d_ROIOutBeforeFrameByFrameSmoot->size[1] = 4;
  InterpolatedLinIdx_SR->size[0] = 0;
  BlockFullLinIdx_SR->size[0] = 0;
  TimestampBlock_SR->size[0] = 0;
  TimestampBlockDetections_SR->size[0] = 0;
  ROINoPrevCallsBlock_SR->size[0] = 0;
  ROINoPrevCallsBlock_SR->size[1] = 4;
  c_NoPrevCallsBlock_ROIDetection->size[0] = 0;
  c_NoPrevCallsBlock_ROIDetection->size[1] = 4;
  ROIBlockDetectionFaceLinIdx_SR->size[0] = 0;
  ROIBlockDetectionSkinLinIdx_SR->size[0] = 0;
  c_ROIBlockDetectionFaceSkinLinI->size[0] = 0;
  d_ROIBlockNoDetectionFaceSkinLi = 0;

  /* %%%%% C-language optimation %%%%%% */
  /* If called during first-read operations */
  emxInit_int32_T(&FramesToAdjust, 2, true);
  emxInit_int16_T(&ROIBlockFaceSkin_Temp, 2, true);
  emxInit_boolean_T(&b_HasROI_TF, 1, true);
  if (FirstReadTF) {
    /* Assign BlockFullLinIdx_FR with fixed length of 229.   */
    /* Note: constant 229 assumes that the length of BlockFullLinIdx == 229. If the length of this  */
    /* variable were to change, the constant would need to be modified.      */
    /* If length of BlockFullLinIdx_In == 229 */
    if (BlockFullLinIdx_In->size[0] == 229) {
      /* Use indexing as a way to declare fixed length to code generation. */
      /* 229 x 1 column vector; type int32. */
      for (i = 0; i < 229; i++) {
        BlockFullLinIdx_FR[i] = BlockFullLinIdx_In->data[i];
      }

      /* Assert fixed size */
      /* If length of BlockFullLinIdx_In less than 229, make adjustments  */
      /* Length only less than 229 during the final 228 frames of the portion of the video to be  */
      /* processed.             */
    } else {
      /* Note: ROIMSIR_Optimize is a custom function located within folder 'FacePulseRate'. */
      /* ROIMSIR_Optimize   Artificially increase the span of BlockFullLinIdx_In to accommodate a fixed   */
      /*                    memory allocation size.  */
      /*                     */
      /*     Helper function to function FacePulseRate.  */
      /*     Within function FacePulseRate, called by function ROIMSIR. */
      /*  */
      /*  */
      /*     Code Generation */
      /*     --------------- */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /*  */
      /*  */
      /*     Description */
      /*     ----------- */
      /*  */
      /*     During the first-read operations, artificially increase the span of BlockFullLinIdx_In when it    */
      /*     is less than a specified length so that its length is always fixed. Using a fixed size for  */
      /*     this variable allows many operations to avoid the use of dynamically-allocated memory and use */
      /*     fixed-sized variables, increasing efficiency.         */
      /*  */
      /*     Overview of optimization: */
      /*  */
      /*     To increase efficiency of the compiled version of function ROIMSIR (ROIMSIR_mex), ROIMSIR was  */
      /*     developed so that the first-read operations take an execution path separate from the  */
      /*     second-read operations. Separate execution paths were developed so that Matlab code generation  */
      /*     can make separate functions for each path (termed "function specialization") if doing so  */
      /*     increases efficiency. Efficiency gains are typically made by reducing instances where dynamic */
      /*     memory allocattion needs to be used and through the use of fixed-sized variables. */
      /*        */
      /*     The execution path of the first-read operations was developed such that variable  */
      /*     BlockFullLinIdx_FR is always a fixed-length. If always a fixed length, dynamic memory  */
      /*     allocation does not need to be used and fixed-size variables can be utilized. Moreover, many  */
      /*     variables along the execution match the length of this variable, so they, too, do not need to   */
      /*     use dynamic memory allocation and can utilize fixed-size variables. Although there is a cost  */
      /*     to the modifications to variables conducted in this function to facilitate fixed-size  */
      /*     variables, this cost only occurs for the final 228 frames of the input video, which is likely */
      /*     a small portion of the input video.     */
      /*  */
      /*     Second-read operations require a variable- length version of BlockFullLinIdx_FR  */
      /*     (BlockFullLinIdx_SR), so second-read operations use a separate execution path to accommodate   */
      /*     this and avoid placing this requirement on first-read operations.  However, note that although  */
      /*     first-read and second-read operations use separate execution paths using different variable  */
      /*     sizes, they actually undergo the same operations in most cases.  */
      /*       */
      /*     Implementation safeguards and notes: */
      /*  */
      /*     BlockFullLinIdx_FR indexes into the other input variables, and they should be of a length  */
      /*     long enough to accommodate the increase in the index. However, in case they are not (likely */
      /*     because of an upstream implementation change), the function will verify their length and  */
      /*     increase it if needed.  */
      /*  */
      /*     This optimization has only been implemented for first-read operations, where the length of the */
      /*     span is expected to be increased only on the right of (greater than) RowToReturnFullLinIdx.  */
      /*     That is, the portion of the span that will need to be increased will only come at the end of  */
      /*     the video. This optimization is not implemented for extending the span on the left of (less  */
      /*     than) RowToReturnFullLinIdx (at the beginning of the video).  This is not expected to the case */
      /*     because function ROIMeans_FirstRead_TakeMeans is implemented not to call this function until */
      /*     the left-side span is at full length. */
      /*  */
      /*     The value 229 seen throughout the function is the number of ROIs used during the first-read  */
      /*     operations. This number is determined by the number of ROIs available ahead of the current  */
      /*     ROI, which is determined by the lag between the frame-reading operations and the ROI-means */
      /*     operations (for details, see the file for function ROIMeans_FirstRead_TakeMeans).  */
      /*     Specifically, to use an equal number of ROIs on either side of the current ROI, the number of */
      /*     ROIs used before the current ROI is kept equal to the number used after, or  */
      /*     (ROIGeneralConfig.ROIMeansOperationsLag - 1) * 2 + 1. If  */
      /*     ROIGeneralConfig.ROIMeansOperationsLag is modified (for an implementation change), the value */
      /*     229 should be increased if ROIGeneralConfig.ROIMeansOperationsLag is made larger; doing so  */
      /*     would allow all the available ROIs to be used. If ROIGeneralConfig.ROIMeansOperationsLag is */
      /*     made smaller, then the value 229 should be decreased; otherwise, there will not be ROIs */
      /*     available where indexed. If the value is changed, function ROIMSIR would need to be  */
      /*     recompiled. */
      /*          */
      /*  */
      /*     Copyright */
      /*     --------- */
      /*  */
      /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), June, 2020. Licensed under the MIT License and   */
      /*     the Responsible AI License (RAIL). */
      /* %%%%% Code-generation settings %%%%%% */
      /* Inline function */
      /* Call function as extrinsic so that stack trace can be displayed */
      /* %%%%% Validate inputs %%%%%% */
      /* The left-side span of BlockFullLinIdx_In should be at full length. */
      /* If not, an implementation error has likely occurred.  */
      /* Note: constant 229 assumes that the length of BlockFullLinIdx == 229. If the length of this  */
      /* variable were to change, the constant would need to be modified. */
      /* Optimize division by 2 by bit-wise division */
      Idx = BlockFullLinIdx_In->size[0];
      VideoReadConfig_FrameIdx_Length = BlockFullLinIdx_In->data[0];
      for (winNew = 2; winNew <= Idx; winNew++) {
        i = BlockFullLinIdx_In->data[winNew - 1];
        if (VideoReadConfig_FrameIdx_Length > i) {
          VideoReadConfig_FrameIdx_Length = i;
        }
      }

      if (VideoReadConfig_FrameIdx_Length < 115) {
        /* Throw exception */
        /* Called as extrinsic so that stack trace can be displayed. */
        error(emlrt_marshallOut(cv3), c_emlrt_marshallOut(cv5), &c_emlrtMCI);
      }

      /* %%%%% Increase span of BlockFullLinIdx_FR %%%%%% */
      /* Note: constant 229 assumes that the length of BlockFullLinIdx == 229. If the length of this  */
      /* variable were to change, the constant would need to be modified. */
      /* Build index up from first index of BlockFullLinIdx_In */
      Idx = BlockFullLinIdx_In->data[0] - 1;
      for (b_i = 0; b_i < 229; b_i++) {
        Idx++;
        BlockFullLinIdx_FR[b_i] = Idx;
      }

      /* %%%%% Verify sizes of variables that BlockFullLinIdx_FR indexes and extend if needed %%%%%% */
      /* Some indices of BlockFullLinIdx_FR will now exceed range of input variables to function ROIMSIR. */
      /* To remedy this, increase the length of these input variables. Function ROIMSIR ignores portions of */
      /* variables that were extended this way. */
      /* Note: the extended sizes are not returned as output of ROIMSIR; they are only used within function */
      /* ROIMSIR for the purpose of the optimization. */
      /* Initial measurements: */
      /* Note: constant 229 assumes that the length of BlockFullLinIdx == 229. If the length of this  */
      /* variable were to change, the constant would need to be modified. */
      VideoReadConfig_FrameIdx_Length = VideoReadConfig_FrameIdx_FR->size[1];

      /* ROI: */
      if (ROI->size[0] < BlockFullLinIdx_FR[228]) {
        /* Extend with zero values; these values will not enter into calculations. */
        Idx = BlockFullLinIdx_FR[228] - ROI->size[0];
        i = ROIBlockFaceSkin_Temp->size[0] * ROIBlockFaceSkin_Temp->size[1];
        ROIBlockFaceSkin_Temp->size[0] = ROI->size[0] + Idx;
        ROIBlockFaceSkin_Temp->size[1] = 4;
        emxEnsureCapacity_int16_T(ROIBlockFaceSkin_Temp, i);
        Sum = ROI->size[0];
        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp->data[i] = ROI->data[i];
        }

        for (i = 0; i < Idx; i++) {
          ROIBlockFaceSkin_Temp->data[i + ROI->size[0]] = 0;
        }

        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0]] =
            ROI->data[i + ROI->size[0]];
        }

        for (i = 0; i < Idx; i++) {
          ROIBlockFaceSkin_Temp->data[(i + ROI->size[0]) +
            ROIBlockFaceSkin_Temp->size[0]] = 0;
        }

        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 2] =
            ROI->data[i + ROI->size[0] * 2];
        }

        for (i = 0; i < Idx; i++) {
          ROIBlockFaceSkin_Temp->data[(i + ROI->size[0]) +
            ROIBlockFaceSkin_Temp->size[0] * 2] = 0;
        }

        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 3] =
            ROI->data[i + ROI->size[0] * 3];
        }

        for (i = 0; i < Idx; i++) {
          ROIBlockFaceSkin_Temp->data[(i + ROI->size[0]) +
            ROIBlockFaceSkin_Temp->size[0] * 3] = 0;
        }

        i = ROI->size[0] * ROI->size[1];
        ROI->size[0] = ROIBlockFaceSkin_Temp->size[0];
        ROI->size[1] = 4;
        emxEnsureCapacity_int16_T(ROI, i);
        Sum = ROIBlockFaceSkin_Temp->size[0] * ROIBlockFaceSkin_Temp->size[1];
        for (i = 0; i < Sum; i++) {
          ROI->data[i] = ROIBlockFaceSkin_Temp->data[i];
        }
      }

      /* ROINoMods: */
      if (ROINoMods->size[0] < BlockFullLinIdx_FR[228]) {
        /* Extend with zero values; these values will not enter into calculations. */
        Idx = BlockFullLinIdx_FR[228] - ROINoMods->size[0];
        i = ROIBlockFaceSkin_Temp->size[0] * ROIBlockFaceSkin_Temp->size[1];
        ROIBlockFaceSkin_Temp->size[0] = ROINoMods->size[0] + Idx;
        ROIBlockFaceSkin_Temp->size[1] = 4;
        emxEnsureCapacity_int16_T(ROIBlockFaceSkin_Temp, i);
        Sum = ROINoMods->size[0];
        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp->data[i] = ROINoMods->data[i];
        }

        for (i = 0; i < Idx; i++) {
          ROIBlockFaceSkin_Temp->data[i + ROINoMods->size[0]] = 0;
        }

        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0]] =
            ROINoMods->data[i + ROINoMods->size[0]];
        }

        for (i = 0; i < Idx; i++) {
          ROIBlockFaceSkin_Temp->data[(i + ROINoMods->size[0]) +
            ROIBlockFaceSkin_Temp->size[0]] = 0;
        }

        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 2] =
            ROINoMods->data[i + ROINoMods->size[0] * 2];
        }

        for (i = 0; i < Idx; i++) {
          ROIBlockFaceSkin_Temp->data[(i + ROINoMods->size[0]) +
            ROIBlockFaceSkin_Temp->size[0] * 2] = 0;
        }

        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 3] =
            ROINoMods->data[i + ROINoMods->size[0] * 3];
        }

        for (i = 0; i < Idx; i++) {
          ROIBlockFaceSkin_Temp->data[(i + ROINoMods->size[0]) +
            ROIBlockFaceSkin_Temp->size[0] * 3] = 0;
        }

        i = ROINoMods->size[0] * ROINoMods->size[1];
        ROINoMods->size[0] = ROIBlockFaceSkin_Temp->size[0];
        ROINoMods->size[1] = 4;
        emxEnsureCapacity_int16_T(ROINoMods, i);
        Sum = ROIBlockFaceSkin_Temp->size[0] * ROIBlockFaceSkin_Temp->size[1];
        for (i = 0; i < Sum; i++) {
          ROINoMods->data[i] = ROIBlockFaceSkin_Temp->data[i];
        }
      }

      /* ROINoResize: */
      if (ROINoResize->size[0] < BlockFullLinIdx_FR[228]) {
        /* Extend with zero values; these values will not enter into calculations. */
        Idx = BlockFullLinIdx_FR[228] - ROINoResize->size[0];
        i = ROIBlockFaceSkin_Temp->size[0] * ROIBlockFaceSkin_Temp->size[1];
        ROIBlockFaceSkin_Temp->size[0] = ROINoResize->size[0] + Idx;
        ROIBlockFaceSkin_Temp->size[1] = 4;
        emxEnsureCapacity_int16_T(ROIBlockFaceSkin_Temp, i);
        Sum = ROINoResize->size[0];
        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp->data[i] = ROINoResize->data[i];
        }

        for (i = 0; i < Idx; i++) {
          ROIBlockFaceSkin_Temp->data[i + ROINoResize->size[0]] = 0;
        }

        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0]] =
            ROINoResize->data[i + ROINoResize->size[0]];
        }

        for (i = 0; i < Idx; i++) {
          ROIBlockFaceSkin_Temp->data[(i + ROINoResize->size[0]) +
            ROIBlockFaceSkin_Temp->size[0]] = 0;
        }

        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 2] =
            ROINoResize->data[i + ROINoResize->size[0] * 2];
        }

        for (i = 0; i < Idx; i++) {
          ROIBlockFaceSkin_Temp->data[(i + ROINoResize->size[0]) +
            ROIBlockFaceSkin_Temp->size[0] * 2] = 0;
        }

        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 3] =
            ROINoResize->data[i + ROINoResize->size[0] * 3];
        }

        for (i = 0; i < Idx; i++) {
          ROIBlockFaceSkin_Temp->data[(i + ROINoResize->size[0]) +
            ROIBlockFaceSkin_Temp->size[0] * 3] = 0;
        }

        i = ROINoResize->size[0] * ROINoResize->size[1];
        ROINoResize->size[0] = ROIBlockFaceSkin_Temp->size[0];
        ROINoResize->size[1] = 4;
        emxEnsureCapacity_int16_T(ROINoResize, i);
        Sum = ROIBlockFaceSkin_Temp->size[0] * ROIBlockFaceSkin_Temp->size[1];
        for (i = 0; i < Sum; i++) {
          ROINoResize->data[i] = ROIBlockFaceSkin_Temp->data[i];
        }
      }

      /* VideoReadConfig_FrameIdx: */
      if (VideoReadConfig_FrameIdx_FR->size[1] < BlockFullLinIdx_FR[228]) {
        /* Extend with linearly increasing integers; these values will enter into calculations (used  */
        /* during extrapolation). */
        eml_integer_colon_dispatcher(VideoReadConfig_FrameIdx_FR->
          data[VideoReadConfig_FrameIdx_FR->size[1] - 1] + 1,
          (VideoReadConfig_FrameIdx_FR->data[VideoReadConfig_FrameIdx_FR->size[1]
           - 1] + BlockFullLinIdx_FR[228]) - VideoReadConfig_FrameIdx_FR->size[1],
          FramesToAdjust);
        i = VideoReadConfig_FrameIdx_FR->size[1];
        Sum = FramesToAdjust->size[1];
        i1 = VideoReadConfig_FrameIdx_FR->size[0] *
          VideoReadConfig_FrameIdx_FR->size[1];
        VideoReadConfig_FrameIdx_FR->size[1] += FramesToAdjust->size[1];
        emxEnsureCapacity_int32_T(VideoReadConfig_FrameIdx_FR, i1);
        for (i1 = 0; i1 < Sum; i1++) {
          VideoReadConfig_FrameIdx_FR->data[i + i1] = FramesToAdjust->data[i1];
        }
      }

      /* Timestamp: */
      if (Timestamp->size[0] < BlockFullLinIdx_FR[228]) {
        emxInit_real32_T(&y, 2, true);

        /* Type single for compatibility with variable Timestamp. */
        /* Extend with linearly increasing values of .05; these values will enter into calculations (used  */
        /* during extrapolation). */
        /* Note: .05 is used as a quick substitute of the frate rate. */
        HeightRatio_Single = (Timestamp->data[Timestamp->size[0] - 1] + 0.05F) +
          0.05F * (((real32_T)BlockFullLinIdx_FR[228] - (real32_T)
                    VideoReadConfig_FrameIdx_Length) - 1.0F);
        if (muSingleScalarIsNaN(Timestamp->data[Timestamp->size[0] - 1] + 0.05F)
            || muSingleScalarIsNaN(HeightRatio_Single)) {
          i = y->size[0] * y->size[1];
          y->size[0] = 1;
          y->size[1] = 1;
          emxEnsureCapacity_real32_T(y, i);
          y->data[0] = rtNaNF;
        } else if (HeightRatio_Single < Timestamp->data[Timestamp->size[0] - 1]
                   + 0.05F) {
          y->size[0] = 1;
          y->size[1] = 0;
        } else if ((muSingleScalarIsInf(Timestamp->data[Timestamp->size[0] - 1]
                     + 0.05F) || muSingleScalarIsInf(HeightRatio_Single)) &&
                   (Timestamp->data[Timestamp->size[0] - 1] + 0.05F ==
                    HeightRatio_Single)) {
          i = y->size[0] * y->size[1];
          y->size[0] = 1;
          y->size[1] = 1;
          emxEnsureCapacity_real32_T(y, i);
          y->data[0] = rtNaNF;
        } else {
          eml_float_colon(Timestamp->data[Timestamp->size[0] - 1] + 0.05F,
                          HeightRatio_Single, y);
        }

        emxInit_real32_T(&r2, 1, true);
        i = r2->size[0];
        r2->size[0] = y->size[1];
        emxEnsureCapacity_real32_T(r2, i);
        Sum = y->size[1];
        for (i = 0; i < Sum; i++) {
          r2->data[i] = y->data[i];
        }

        i = Timestamp->size[0];
        i1 = Timestamp->size[0];
        Timestamp->size[0] += r2->size[0];
        emxEnsureCapacity_real32_T(Timestamp, i1);
        Sum = y->size[1];
        emxFree_real32_T(&r2);
        for (i1 = 0; i1 < Sum; i1++) {
          Timestamp->data[i + i1] = y->data[i1];
        }

        emxFree_real32_T(&y);
      }

      /* HasROI_TF_NRow: */
      winNew = HasROI_TF->FacePrimary->size[0];

      /* any field could be used here */
      if (HasROI_TF->FacePrimary->size[0] < BlockFullLinIdx_FR[228]) {
        /* Extend with false values; these values will indicate that the zero values added above should */
        /* not be entered into calculations. */
        /* The names and the number of fields are compile-time constants */
        Sum = BlockFullLinIdx_FR[228] - HasROI_TF->FacePrimary->size[0];
        i = b_HasROI_TF->size[0];
        b_HasROI_TF->size[0] = HasROI_TF->FacePrimary->size[0] + Sum;
        emxEnsureCapacity_boolean_T(b_HasROI_TF, i);
        Idx = HasROI_TF->FacePrimary->size[0];
        for (i = 0; i < Idx; i++) {
          b_HasROI_TF->data[i] = HasROI_TF->FacePrimary->data[i];
        }

        for (i = 0; i < Sum; i++) {
          b_HasROI_TF->data[i + HasROI_TF->FacePrimary->size[0]] = false;
        }

        i = HasROI_TF->FacePrimary->size[0];
        HasROI_TF->FacePrimary->size[0] = b_HasROI_TF->size[0];
        emxEnsureCapacity_boolean_T(HasROI_TF->FacePrimary, i);
        Sum = b_HasROI_TF->size[0];
        for (i = 0; i < Sum; i++) {
          HasROI_TF->FacePrimary->data[i] = b_HasROI_TF->data[i];
        }

        i = HasROI_TF->FaceSecondary1->size[0];
        i1 = HasROI_TF->FaceSecondary1->size[0];
        HasROI_TF->FaceSecondary1->size[0] = (HasROI_TF->FaceSecondary1->size[0]
          + BlockFullLinIdx_FR[228]) - winNew;
        emxEnsureCapacity_boolean_T(HasROI_TF->FaceSecondary1, i1);
        Idx = BlockFullLinIdx_FR[228] - winNew;
        for (i1 = 0; i1 < Idx; i1++) {
          HasROI_TF->FaceSecondary1->data[i + i1] = false;
        }

        i = HasROI_TF->FaceSecondary2->size[0];
        i1 = HasROI_TF->FaceSecondary2->size[0];
        HasROI_TF->FaceSecondary2->size[0] = (HasROI_TF->FaceSecondary2->size[0]
          + BlockFullLinIdx_FR[228]) - winNew;
        emxEnsureCapacity_boolean_T(HasROI_TF->FaceSecondary2, i1);
        for (i1 = 0; i1 < Idx; i1++) {
          HasROI_TF->FaceSecondary2->data[i + i1] = false;
        }

        i = HasROI_TF->Skin->size[0];
        i1 = HasROI_TF->Skin->size[0];
        HasROI_TF->Skin->size[0] = (HasROI_TF->Skin->size[0] +
          BlockFullLinIdx_FR[228]) - winNew;
        emxEnsureCapacity_boolean_T(HasROI_TF->Skin, i1);
        for (i1 = 0; i1 < Idx; i1++) {
          HasROI_TF->Skin->data[i + i1] = false;
        }

        i = HasROI_TF->ROISpecifiedByArgument->size[0];
        i1 = HasROI_TF->ROISpecifiedByArgument->size[0];
        HasROI_TF->ROISpecifiedByArgument->size[0] =
          (HasROI_TF->ROISpecifiedByArgument->size[0] + BlockFullLinIdx_FR[228])
          - winNew;
        emxEnsureCapacity_boolean_T(HasROI_TF->ROISpecifiedByArgument, i1);
        for (i1 = 0; i1 < Idx; i1++) {
          HasROI_TF->ROISpecifiedByArgument->data[i + i1] = false;
        }
      }

      /* end function */
    }

    /* If called during second-read operations */
  } else {
    i = BlockFullLinIdx_SR->size[0];
    BlockFullLinIdx_SR->size[0] = BlockFullLinIdx_In->size[0];
    emxEnsureCapacity_int32_T(BlockFullLinIdx_SR, i);
    Sum = BlockFullLinIdx_In->size[0];
    for (i = 0; i < Sum; i++) {
      BlockFullLinIdx_SR->data[i] = BlockFullLinIdx_In->data[i];
    }

    /* Assign zero-valued variables for code-generation purposes    */
    /* Note: constant 229 assumes that the length of BlockFullLinIdx == 229. If the length of this  */
    /* variable were to change, the constant would need to be modified.  */
  }

  /* %%%%% Implementation-specific setup %%%%%% */
  /* This function uses different implementations depending on whether the function is called during  */
  /* the first-read operations (by function ROIMeans_FirstRead_TakeMeans) or during the second-read  */
  /* operations (by function ROIMeans_SecondRead). */
  /* %%%%% --- First-read setup %%%%%% */
  /* Use implementation for first-read operations. See notes at top of file. */
  emxInit_int16_T(&ROIWidthHeightPreSmooth, 2, true);
  emxInit_int32_T(&SkinIdxFit, 1, true);
  emxInit_int16_T(&r, 2, true);
  emxInit_int16_T(&SmoothedXYColumn, 2, true);
  emxInit_char_T(&varargin_2, 2, true);
  emxInit_boolean_T(&x, 2, true);
  emxInit_boolean_T(&b_x, 2, true);
  emxInit_char_T(&r1, 2, true);
  guard1 = false;
  guard2 = false;
  if (FirstReadTF) {
    /* %%%%% >>>>>> Validate first-read inputs %%%%%% */
    /* Validate whether input ROI is type int16. */
    /* Must be an integer type because no rounding is conducted. */
    /* Should be type int16 because the function is implemented to assign values of this type. */
    /* A non-matching type would be due to an implementation error. */
    /* Validate whether input ROINoMods is type int16. */
    /* Must be an integer type because no rounding is conducted. */
    /* Should be type int16 because the function is implemented to assign values of this type. */
    /* A non-matching type would be due to an implementation error. */
    /* %%%%% >>>>>> Assign additional first-read variables %%%%%% */
    /* Assign variables only used during first-read (not second-read) operations: */
    /* Index to length of ROI block.  */
    /* Also rename to "ROINoPrevCallsBlock_FR" to make the name more applicable because modications    */
    /* will be applied.     */
    /* 229 x 4; type int16. */
    /* Index to length of ROI block.  */
    /* 229 x 4; type int16.     */
    for (i = 0; i < 4; i++) {
      for (i1 = 0; i1 < 229; i1++) {
        Idx = i1 + 229 * i;
        b_i = BlockFullLinIdx_FR[i1];
        ROINoPrevCallsBlock_FR[Idx] = ROINoMods->data[(b_i + ROINoMods->size[0] *
          i) - 1];
        ROINoResizeBlock_FR[Idx] = ROINoResize->data[(b_i + ROINoResize->size[0]
          * i) - 1];
      }
    }

    /* Linear index of target frame converted to align with length of ROI block rather than full  */
    /* frame index. */
    /* Scalar; type int32. */
    /* Note: constant 115 assumes that the length of BlockFullLinIdx == 229. If the length of this  */
    /* variable were to change, the constant would need to be modified.   */
    /* Note: General indexing version (this is not used to discourage dynamic memory allocation):  */
    /* RowToReturnBlockLinIdx_FR = RowToReturnFullLinIdx_FR - BlockFullLinIdx_FR(1) + 1; */
    RowToReturnBlockLinIdx_FR = 113;

    /* Confirm that RowToReturnBlockLinIdx_FR == 115 */
    /* Only in the case of an implementation error would this not be the case. */
    if ((RowToReturnFullLinIdx_FR - BlockFullLinIdx_FR[0]) + 1 != 115) {
      /* Throw error */
      /* Called as extrinsic so that stack trace can be displayed. */
      b_sprintf(VideoReadConfig_FrameIdx_FR->data[RowToReturnFullLinIdx_FR - 1],
                r1);
      i = varargin_2->size[0] * varargin_2->size[1];
      varargin_2->size[0] = 1;
      varargin_2->size[1] = r1->size[1] + 162;
      emxEnsureCapacity_char_T(varargin_2, i);
      for (i = 0; i < 77; i++) {
        varargin_2->data[i] = cv[i];
      }

      for (i = 0; i < 16; i++) {
        varargin_2->data[i + 77] = cv1[i];
      }

      for (i = 0; i < 34; i++) {
        varargin_2->data[i + 93] = cv2[i];
      }

      Sum = r1->size[1];
      for (i = 0; i < Sum; i++) {
        varargin_2->data[i + 127] = r1->data[i];
      }

      for (i = 0; i < 35; i++) {
        varargin_2->data[(i + r1->size[1]) + 127] = cv4[i];
      }

      error(emlrt_marshallOut(cv3), b_emlrt_marshallOut(varargin_2), &emlrtMCI);
    }

    /* Assign variables common to first-read and second-read operations: */
    /* Note: Of these variables, the same form of variables are used in the second-read operations    */
    /* (they would have the "_SR" suffix), but, unlike the variables in the second-read, the    */
    /* variables used in the first-read are of fixed length. */
    /* ROIMSIR_AssignVars is a custom function located within folder 'FacePulseRate' */
    /* ROIMSIR_AssignVars   Assign variables, which may differ in length depending on whether they are  */
    /*                      assigned during first-read or second-read operations. */
    /*  */
    /*     Helper function to function FacePulseRate.  */
    /*     Within function FacePulseRate, called by function ROIMSIR. */
    /*  */
    /*  */
    /*     Code Generation */
    /*     --------------- */
    /*  */
    /*     Can be called as a Matlab function or used for C-language code generation. */
    /*  */
    /*  */
    /*     Description */
    /*     ----------- */
    /*  */
    /*     Assign variables, which may differ in length depending on whether they are assigned during  */
    /*     first-read or second-read operations. */
    /*                       */
    /*     Note: */
    /*  */
    /*     Linear indices returned (e.g., ROIBlockDetectionFaceLinIdx) should contain unique values */
    /*     sorted from least to greatest. This is required by functions SetDiff (called by functions  */
    /*     ROIMSIR_FrameByFrameSmooth_InterpFR and ROIMSIR_FrameByFrameSmooth_SmoothFR) and PositionsIn */
    /*     (called by function ROIMSIR_DetectionSmooth). */
    /*  */
    /*  */
    /*     Copyright */
    /*     --------- */
    /*  */
    /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
    /*     the Responsible AI License (RAIL). */
    /* Inline function */
    /* If code generation running */
    /* If first-read operations */
    /* Local function */
    /* end main function */
    /* ============================================================================================= */
    /* Local functions */
    /* ============================================================================================= */
    /* ============================================================================================= */
    /* DetectionIndices_FR   Assign linear indices and counts corresponding to detections for first-read  */
    /*                       operations. */
    /*  */
    /*     Description: */
    /*  */
    /*     Assign linear indices corresponding to the detections for first-read operations. Specifically, */
    /*     return a linear index corresponding to detections by the face-detection algorithm, a linear */
    /*     index corresponding to detections by the skin-detection algorithm, and a linear index  */
    /*     corresponding to detections by either the face- or skin-detection algorithms. Also return  */
    /*     counts of detections corresponding to each of the linear indices. */
    /*  */
    /*     Notes: */
    /*  */
    /*     This function differs from function DetectionIndices_SR because the lengths of the variables   */
    /*     are fixed at 229 to prevent dynamic memory allocation. Note that constant 229 assumes that the   */
    /*     length of BlockFullLinIdx == 229. If the length of this variable were to change, the constant   */
    /*     would need to be modified. */
    /*  */
    /*     Linear indices returned (e.g., ROIBlockDetectionFaceLinIdx) should contain unique values */
    /*     sorted from least to greatest. See note at top. */
    /* Inline function */
    /* Preallocate linear index indicating ROIs that correspond to face detections or ROIs specified by  */
    /* argument ROISpecifiedByArgument to FacePulseRate. */
    /* Preallocate linear index indicating ROIs that correspond to skin detections */
    /* Preallocate linear index indicating ROIs that correspond to face detections, ROIs specified by   */
    /* argument ROISpecifiedByArgument, or skin detections. */
    /* The converse of ROIBlockDetectionFaceSkinLinIdx */
    /* Face-detection counter */
    NDetectionsFace_FR = 0;

    /* Skin-detection counter */
    NDetectionsSkin_FR = 0;

    /* Face or skin-detection counter */
    NDetectionsFaceSkin_FR = 0;

    /* Converse */
    NNoDetectionsFaceSkin_FR = 0;

    /* Loop across the variables */
    for (b_i = 0; b_i < 229; b_i++) {
      /* Assign index that aligns with full index */
      /* The full index used to index into HasROI_TF. */
      /* If any face detection */
      i = BlockFullLinIdx_FR[b_i];
      if (HasROI_TF->FacePrimary->data[i - 1] || HasROI_TF->FaceSecondary1->
          data[i - 1] || HasROI_TF->FaceSecondary2->data[i - 1] ||
          HasROI_TF->ROISpecifiedByArgument->data[i - 1]) {
        NDetectionsFace_FR++;

        /* Assign index */
        e_ROIBlockNoDetectionFaceSkinLi[NDetectionsFace_FR - 1] = (uint8_T)(b_i
          + 1);
        FaceOrSkinTF = true;
      } else {
        FaceOrSkinTF = false;
      }

      /* If any skin detection */
      if (HasROI_TF->Skin->data[i - 1]) {
        NDetectionsSkin_FR++;

        /* Assign index */
        ROIBlockDetectionSkinLinIdx[NDetectionsSkin_FR - 1] = (uint8_T)(b_i + 1);
        FaceOrSkinTF = true;
      }

      /* If any face detection or a skin detection */
      if (FaceOrSkinTF) {
        NDetectionsFaceSkin_FR++;

        /* Assign index */
        e_ROIBlockDetectionFaceSkinLinI[NDetectionsFaceSkin_FR - 1] = (uint8_T)
          (b_i + 1);
      } else {
        NNoDetectionsFaceSkin_FR++;

        /* Assign index */
        f_ROIBlockNoDetectionFaceSkinLi[NNoDetectionsFaceSkin_FR - 1] = b_i + 1;
      }
    }

    /* Assert to prevent dynamic memory allocation by colon operation */
    /* Linear index indicating ROIs that correspond to face detections or ROIs specified by argument  */
    /* ROISpecifiedByArgument to FacePulseRate. */
    /* :229 x 1 column vector; type int32. */
    if (NDetectionsFace_FR != 0) {
      FrameByFrameSmoothingWin_WHHalf = NDetectionsFace_FR;
      if (0 <= NDetectionsFace_FR - 1) {
        memcpy(&c_ROIBlockDetectionFaceLinIdx_F[0],
               &e_ROIBlockNoDetectionFaceSkinLi[0], NDetectionsFace_FR * sizeof
               (uint8_T));
      }
    } else {
      FrameByFrameSmoothingWin_WHHalf = 0;
    }

    /* Linear index indicating ROIs that correspond to skin detections */
    /* :229 x 1 column vector; type int32. */
    if (NDetectionsSkin_FR != 0) {
      for (i = 0; i < NDetectionsSkin_FR; i++) {
        c_ROIBlockDetectionSkinLinIdx_F[i] = ROIBlockDetectionSkinLinIdx[i];
      }
    }

    /* Linear index indicating ROIs that correspond to face detections, ROIs specified by argument  */
    /* ROISpecifiedByArgument, or skin detections. */
    /* :229 x 1 column vector; type int32. */
    if (NDetectionsFaceSkin_FR != 0) {
      d_ROIBlockDetectionFaceSkinLinI = NDetectionsFaceSkin_FR;
      if (0 <= NDetectionsFaceSkin_FR - 1) {
        memcpy(&f_ROIBlockDetectionFaceSkinLinI[0],
               &e_ROIBlockDetectionFaceSkinLinI[0], NDetectionsFaceSkin_FR *
               sizeof(uint8_T));
      }
    } else {
      d_ROIBlockDetectionFaceSkinLinI = 0;
    }

    /* Converse */
    /* :229 x 1 column vector; type int32. */
    if (NNoDetectionsFaceSkin_FR != 0) {
      c_ROIBlockNoDetectionFaceSkinLi = NNoDetectionsFaceSkin_FR;
      for (i = 0; i < NNoDetectionsFaceSkin_FR; i++) {
        e_ROIBlockNoDetectionFaceSkinLi[i] = (uint8_T)
          f_ROIBlockNoDetectionFaceSkinLi[i];
      }
    } else {
      c_ROIBlockNoDetectionFaceSkinLi = 0;
    }

    /* If second-read operations           */
    /* If code generation not running    */
    /* ROI matrix with modifications corresponding to block index */
    /* For the case of more than one output row assigned as output, ROI may not have had modifications, */
    /* but whether it had modifications or not does not affect this case. */
    for (i = 0; i < 4; i++) {
      for (i1 = 0; i1 < 229; i1++) {
        ROIBlock_FR[i1 + 229 * i] = ROI->data[(BlockFullLinIdx_FR[i1] +
          ROI->size[0] * i) - 1];
      }
    }

    /* Timestamps in block */
    for (i = 0; i < 229; i++) {
      TimestampBlock_FR[i] = Timestamp->data[BlockFullLinIdx_FR[i] - 1];
    }

    /* Timestamps in block corresponding to frames with a detection  */
    c_TimestampBlockDetections_FR_s = d_ROIBlockDetectionFaceSkinLinI;
    for (i = 0; i < d_ROIBlockDetectionFaceSkinLinI; i++) {
      c_TimestampBlockDetections_FR_d[i] =
        TimestampBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] - 1];
    }

    /* %%%%% >>>>>> Validation of additional first-read variables %%%%%% */
    /* Check whether HasROI_TF indicates detection for current frame but the ROI of the current frame   */
    /* contains zeros. */
    /* If a detection is present but the ROI values are zeros, this likely indicates an   */
    /* implementation error in function ROIMeans_FirstRead_TakeMeans.  */
    /* Note: IsMember is a custom function located within folder 'FacePulseRate'. */
    /*  if current frame corresponds to a detection detection */
    /*  ROI of current frame contains zeros */
    /* IsMember  Determine whether scalar a is a member of vector B. */
    /*  */
    /*     Helper function to function FacePulseRate.  */
    /*     Within function FacePulseRate, called by functions ROIMSIR and ROIMSIR_InterpolateFR. */
    /*  */
    /*     Code generation:  */
    /*  */
    /*     Can be called as a Matlab function or used for C-language code generation. */
    /* Inline function */
    FaceOrSkinTF = false;
    b_i = 0;
    exitg1 = false;
    while ((!exitg1) && (b_i <= NDetectionsFaceSkin_FR - 1)) {
      if (115 == f_ROIBlockDetectionFaceSkinLinI[b_i]) {
        FaceOrSkinTF = true;
        exitg1 = true;
      } else {
        b_i++;
      }
    }

    /* end function */
    if (FaceOrSkinTF && ((ROINoMods->data[BlockFullLinIdx_FR[114] - 1] == 0) ||
                         (ROINoMods->data[(BlockFullLinIdx_FR[114] +
           ROINoMods->size[0]) - 1] == 0) || (ROINoMods->data
          [(BlockFullLinIdx_FR[114] + ROINoMods->size[0] * 2) - 1] == 0) ||
                         (ROINoMods->data[(BlockFullLinIdx_FR[114] +
           ROINoMods->size[0] * 3) - 1] == 0))) {
      /* Throw error */
      /* Called as extrinsic so that stack trace can be displayed. */
      b_sprintf(VideoReadConfig_FrameIdx_FR->data[RowToReturnFullLinIdx_FR - 1],
                r1);
      i = varargin_2->size[0] * varargin_2->size[1];
      varargin_2->size[0] = 1;
      varargin_2->size[1] = r1->size[1] + 233;
      emxEnsureCapacity_char_T(varargin_2, i);
      for (i = 0; i < 79; i++) {
        varargin_2->data[i] = cv6[i];
        varargin_2->data[i + 79] = cv7[i];
      }

      for (i = 0; i < 40; i++) {
        varargin_2->data[i + 158] = cv8[i];
      }

      Sum = r1->size[1];
      for (i = 0; i < Sum; i++) {
        varargin_2->data[i + 198] = r1->data[i];
      }

      for (i = 0; i < 35; i++) {
        varargin_2->data[(i + r1->size[1]) + 198] = cv4[i];
      }

      error(emlrt_marshallOut(cv3), b_emlrt_marshallOut(varargin_2), &b_emlrtMCI);
    }

    /* %%%%% --- Second-read setup %%%%%%     */
    /* Use implementation for second-read operations. See notes at top of file.    */
    guard1 = true;
  } else {
    /* %%%%% >>>>>> Validate second-read inputs %%%%%% */
    /* Check whether type int16. */
    /* Must be an integer type because no rounding is conducted. */
    /* Should be type int16 because the function is implemented to assign values of this type. */
    /* A non-matching type would be due to an implementation error. */
    /* %%%%% >>>>>> Handle case where no detections are present in ROIs to be processed %%%%%% */
    /* Operations cannot continue if no detections are present in the span of ROIs to be processed  */
    /* (the span of ROIs is indicated by the index BlockFullLinIdx_In). */
    /* Check whether at least one detection is present in span */
    /* Note: if there are not any face detections, there also will not be any skin detections as the  */
    /* skin-detection algorithm cannot be enabled without a certain number of face detections. */
    /*  primary face-detection algorithm */
    /*  secondary #1 face-detection algorithm */
    /*  secondary #2 face-detection algorithm */
    i = b_HasROI_TF->size[0];
    b_HasROI_TF->size[0] = BlockFullLinIdx_In->size[0];
    emxEnsureCapacity_boolean_T(b_HasROI_TF, i);
    Sum = BlockFullLinIdx_In->size[0];
    for (i = 0; i < Sum; i++) {
      b_HasROI_TF->data[i] = HasROI_TF->FacePrimary->data
        [BlockFullLinIdx_In->data[i] - 1];
    }

    if (any(b_HasROI_TF)) {
      guard2 = true;
    } else {
      i = b_HasROI_TF->size[0];
      b_HasROI_TF->size[0] = BlockFullLinIdx_In->size[0];
      emxEnsureCapacity_boolean_T(b_HasROI_TF, i);
      Sum = BlockFullLinIdx_In->size[0];
      for (i = 0; i < Sum; i++) {
        b_HasROI_TF->data[i] = HasROI_TF->FaceSecondary1->
          data[BlockFullLinIdx_In->data[i] - 1];
      }

      if (any(b_HasROI_TF)) {
        guard2 = true;
      } else {
        i = b_HasROI_TF->size[0];
        b_HasROI_TF->size[0] = BlockFullLinIdx_In->size[0];
        emxEnsureCapacity_boolean_T(b_HasROI_TF, i);
        Sum = BlockFullLinIdx_In->size[0];
        for (i = 0; i < Sum; i++) {
          b_HasROI_TF->data[i] = HasROI_TF->FaceSecondary2->
            data[BlockFullLinIdx_In->data[i] - 1];
        }

        if (any(b_HasROI_TF)) {
          guard2 = true;
        } else {
          /* Assign output for second-read operations when no detection is present in span: */
          /* Note: in first-read operations, cases where no detections are available in the ROI block  */
          /* are handled in function ROIMSIR_InterpolateFR. */
          /* Note: function ROIMSIR_OutputIfNoDetections_SecondRead is a custom function located within */
          /* folder 'FacePulseRate'. */
          /* ROIMSIR_OutputIfNoDetections_SecondRead   Assign output for second-read operations when no  */
          /*                                           detection is present in ROIs to be processed. */
          /*  */
          /*     Helper function to function FacePulseRate.  */
          /*     Within function FacePulseRate, called by function ROIMSIR. */
          /*  */
          /*  */
          /*     Code Generation */
          /*     --------------- */
          /*  */
          /*     Can be called as a Matlab function or used for C-language code generation. */
          /*  */
          /*  */
          /*     Description */
          /*     ----------- */
          /*    */
          /*     Assign output for second-read operations when no detection is present in ROIs to be processed  */
          /*     BlockFullLinIdx_In. For ROI output, assign the ROIs with the size of the frame dimensions. For  */
          /*     example, if the frame dimensions are 1920 x 1080, assign ROIs of [1, 1, 1920, 1080]. Return */
          /*     InterpolatedLinIdx_SR filled with the indices of all frames within the block, indicating that */
          /*     all frames were interpolated. Although assigning the frame dimensions may not be considered */
          /*     an interpolation operation, it is considered interpolation for convenience. */
          /*                 */
          /*     Note: in first-read operations, cases where no detections are available in the ROI block are */
          /*     handled in function ROIMSIR_InterpolateFR. In the second-read operations, an operation */
          /*     similar to the one here is conducted when there are fewer than two detections (see function */
          /*     ROIMSIR_InterpolateSR).  */
          /*      */
          /*  */
          /*     Copyright */
          /*     --------- */
          /*  */
          /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), September, 2020. Licensed under the MIT License    */
          /*     and the Responsible AI License (RAIL).     */
          /* Inline function */
          /* Assign frame dimensions in place of an ROI */
          yi_ith[0] = 1;
          yi_ith[1] = 1;
          yi_ith[2] = VidObjWidth;
          yi_ith[3] = VidObjHeight;
          repmat(yi_ith, BlockFullLinIdx_In->size[0], ROIOut_SR);

          /* These output values will be identical to the ROI output values */
          /* Count these ROIs as being interpolated */
          /* end function */
          i = d_ROIOutBeforeFrameByFrameSmoot->size[0] *
            d_ROIOutBeforeFrameByFrameSmoot->size[1];
          d_ROIOutBeforeFrameByFrameSmoot->size[0] = ROIOut_SR->size[0];
          d_ROIOutBeforeFrameByFrameSmoot->size[1] = 4;
          emxEnsureCapacity_int16_T(d_ROIOutBeforeFrameByFrameSmoot, i);
          Sum = ROIOut_SR->size[0] * ROIOut_SR->size[1];
          for (i = 0; i < Sum; i++) {
            d_ROIOutBeforeFrameByFrameSmoot->data[i] = ROIOut_SR->data[i];
          }

          i = InterpolatedLinIdx_SR->size[0];
          InterpolatedLinIdx_SR->size[0] = BlockFullLinIdx_In->size[0];
          emxEnsureCapacity_int32_T(InterpolatedLinIdx_SR, i);
          Sum = BlockFullLinIdx_In->size[0];
          for (i = 0; i < Sum; i++) {
            InterpolatedLinIdx_SR->data[i] = BlockFullLinIdx_In->data[i];
          }

          /* Exit function */
        }
      }
    }
  }

  if (guard2) {
    /* %%%%% >>>>>> Assign additional second-read variables %%%%%% */
    /* Compared to first-read operations, the second-read operations do not need to use unmodified  */
    /* ROIs. The use of unmodified ROIs is only needed during the first-read operations because the */
    /* input of first-read operations is dependent on the output of previous calls; using unmodified  */
    /* ROIs prevents a positive feedback loop from developing (see note at top). However, this */
    /* dependency is not present for second-read operations, so unmodified ROIs are not needed. */
    /* Therefore, use modified ROIs (ROI) where the first-read operations uses unmodified ROIs */
    /* (ROINoMods). To keep variable names consistent across first-read and second-read operations,  */
    /* keep the name "ROINoMods" even though these ROIs have been modified. */
    /* M x 4 matrix; type int16. */
    i = ROINoMods->size[0] * ROINoMods->size[1];
    ROINoMods->size[0] = ROI->size[0];
    ROINoMods->size[1] = 4;
    emxEnsureCapacity_int16_T(ROINoMods, i);
    Sum = ROI->size[0] * ROI->size[1];
    for (i = 0; i < Sum; i++) {
      ROINoMods->data[i] = ROI->data[i];
    }

    /* Assign ROIs from ROINoMods that will be used in most operations. */
    /* As with the rationale above, name the variable "ROINoPrevCallsBlock_SR" to be consistent with */
    /* first-read operations although the ROIs will have been the result of previous calls to the  */
    /* function (i.e., modified). */
    /* M x 4 matrix; type int16. */
    i = ROINoPrevCallsBlock_SR->size[0] * ROINoPrevCallsBlock_SR->size[1];
    ROINoPrevCallsBlock_SR->size[0] = BlockFullLinIdx_SR->size[0];
    ROINoPrevCallsBlock_SR->size[1] = 4;
    emxEnsureCapacity_int16_T(ROINoPrevCallsBlock_SR, i);
    Sum = BlockFullLinIdx_SR->size[0];
    for (i = 0; i < Sum; i++) {
      ROINoPrevCallsBlock_SR->data[i] = ROI->data[BlockFullLinIdx_SR->data[i] -
        1];
    }

    for (i = 0; i < Sum; i++) {
      ROINoPrevCallsBlock_SR->data[i + ROINoPrevCallsBlock_SR->size[0]] =
        ROI->data[(BlockFullLinIdx_SR->data[i] + ROI->size[0]) - 1];
    }

    for (i = 0; i < Sum; i++) {
      ROINoPrevCallsBlock_SR->data[i + ROINoPrevCallsBlock_SR->size[0] * 2] =
        ROI->data[(BlockFullLinIdx_SR->data[i] + ROI->size[0] * 2) - 1];
    }

    for (i = 0; i < Sum; i++) {
      ROINoPrevCallsBlock_SR->data[i + ROINoPrevCallsBlock_SR->size[0] * 3] =
        ROI->data[(BlockFullLinIdx_SR->data[i] + ROI->size[0] * 3) - 1];
    }

    /* Assign variables common to first-read and second-read operations: */
    /* Note: Of these variables, the same form of variables are used in the first-read operations    */
    /* (they would have the "_FR" suffix), but, unlike the variables in the first-read, the variables   */
    /* used in the second-read operations are of variable length. */
    /* ROIMSIR_AssignVars is a custom function located within folder 'FacePulseRate' */
    /* ROIMSIR_AssignVars   Assign variables, which may differ in length depending on whether they are  */
    /*                      assigned during first-read or second-read operations. */
    /*  */
    /*     Helper function to function FacePulseRate.  */
    /*     Within function FacePulseRate, called by function ROIMSIR. */
    /*  */
    /*  */
    /*     Code Generation */
    /*     --------------- */
    /*  */
    /*     Can be called as a Matlab function or used for C-language code generation. */
    /*  */
    /*  */
    /*     Description */
    /*     ----------- */
    /*  */
    /*     Assign variables, which may differ in length depending on whether they are assigned during  */
    /*     first-read or second-read operations. */
    /*                       */
    /*     Note: */
    /*  */
    /*     Linear indices returned (e.g., ROIBlockDetectionFaceLinIdx) should contain unique values */
    /*     sorted from least to greatest. This is required by functions SetDiff (called by functions  */
    /*     ROIMSIR_FrameByFrameSmooth_InterpFR and ROIMSIR_FrameByFrameSmooth_SmoothFR) and PositionsIn */
    /*     (called by function ROIMSIR_DetectionSmooth). */
    /*  */
    /*  */
    /*     Copyright */
    /*     --------- */
    /*  */
    /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
    /*     the Responsible AI License (RAIL). */
    /* Inline function */
    /* If code generation running */
    /* If first-read operations */
    /* Local function */
    /* end local function */
    /* ============================================================================================= */
    /* DetectionIndices_SR   Assign linear indices and counts corresponding to detections for second-read  */
    /*                       operations. */
    /*  */
    /*     Description: */
    /*  */
    /*     Assign linear indices corresponding to the detections for second-read operations.  */
    /*     Specifically, return a linear index corresponding to detections by the face-detection  */
    /*     algorithm, a linear index corresponding to detections by the skin-detection algorithm, and a   */
    /*     linear index corresponding to detections by either the face- or skin-detection algorithms.   */
    /*     Also return counts of detections corresponding to each of the linear indices. */
    /*  */
    /*     Notes: */
    /*  */
    /*     This function differs from function DetectionIndices_FR because the lengths of the variables   */
    /*     are not fixed in the current function. */
    /*  */
    /*     Linear indices returned (e.g., ROIBlockDetectionFaceLinIdx) should contain unique values */
    /*     sorted from least to greatest. See note at top. */
    /* Inline function */
    /* Length of ROI block           */
    Idx = BlockFullLinIdx_SR->size[0];

    /* Preallocate linear index indicating ROIs that correspond to face detections or ROIs specified by  */
    /* argument ROISpecifiedByArgument to FacePulseRate. */
    i = ROIBlockDetectionFaceLinIdx_SR->size[0];
    ROIBlockDetectionFaceLinIdx_SR->size[0] = BlockFullLinIdx_SR->size[0];
    emxEnsureCapacity_int32_T(ROIBlockDetectionFaceLinIdx_SR, i);

    /* Preallocate linear index indicating ROIs that correspond to skin detections */
    i = ROIBlockDetectionSkinLinIdx_SR->size[0];
    ROIBlockDetectionSkinLinIdx_SR->size[0] = BlockFullLinIdx_SR->size[0];
    emxEnsureCapacity_int32_T(ROIBlockDetectionSkinLinIdx_SR, i);

    /* Preallocate linear index indicating ROIs that correspond to face detections, ROIs specified by   */
    /* argument ROISpecifiedByArgument, or skin detections. */
    i = c_ROIBlockDetectionFaceSkinLinI->size[0];
    c_ROIBlockDetectionFaceSkinLinI->size[0] = BlockFullLinIdx_SR->size[0];
    emxEnsureCapacity_int32_T(c_ROIBlockDetectionFaceSkinLinI, i);

    /* The converse of ROIBlockDetectionFaceSkinLinIdx */
    /* Face-detection counter */
    NDetectionsFace_SR = 0;

    /* Skin-detection counter */
    NDetectionsSkin_SR = 0;

    /* Face or skin-detection counter */
    NDetectionsFaceSkin_SR = 0;

    /* Converse */
    NNoDetectionsFaceSkin_SR = 0;

    /* Loop across the variables */
    for (b_i = 0; b_i < Idx; b_i++) {
      /* Assign index that aligns with full index */
      /* The full index used to index into HasROI_TF. */
      /* If any face detection */
      if (HasROI_TF->FacePrimary->data[BlockFullLinIdx_SR->data[b_i] - 1] ||
          HasROI_TF->FaceSecondary1->data[BlockFullLinIdx_SR->data[b_i] - 1] ||
          HasROI_TF->FaceSecondary2->data[BlockFullLinIdx_SR->data[b_i] - 1] ||
          HasROI_TF->ROISpecifiedByArgument->data[BlockFullLinIdx_SR->data[b_i]
          - 1]) {
        NDetectionsFace_SR++;

        /* Assign index */
        ROIBlockDetectionFaceLinIdx_SR->data[NDetectionsFace_SR - 1] = b_i + 1;
        FaceOrSkinTF = true;
      } else {
        FaceOrSkinTF = false;
      }

      /* If any skin detection */
      if (HasROI_TF->Skin->data[BlockFullLinIdx_SR->data[b_i] - 1]) {
        NDetectionsSkin_SR++;

        /* Assign index */
        ROIBlockDetectionSkinLinIdx_SR->data[NDetectionsSkin_SR - 1] = b_i + 1;
        FaceOrSkinTF = true;
      }

      /* If any face detection or a skin detection */
      if (FaceOrSkinTF) {
        NDetectionsFaceSkin_SR++;

        /* Assign index */
        c_ROIBlockDetectionFaceSkinLinI->data[NDetectionsFaceSkin_SR - 1] = b_i
          + 1;
      } else {
        NNoDetectionsFaceSkin_SR++;

        /* Assign index */
        f_ROIBlockNoDetectionFaceSkinLi[NNoDetectionsFaceSkin_SR - 1] = b_i + 1;
      }
    }

    /* Linear index indicating ROIs that correspond to face detections or ROIs specified by argument  */
    /* ROISpecifiedByArgument to FacePulseRate. */
    /* M x 1 column vector; type int32. */
    if (NDetectionsFace_SR != 0) {
      i = ROIBlockDetectionFaceLinIdx_SR->size[0];
      ROIBlockDetectionFaceLinIdx_SR->size[0] = NDetectionsFace_SR;
      emxEnsureCapacity_int32_T(ROIBlockDetectionFaceLinIdx_SR, i);
    } else {
      ROIBlockDetectionFaceLinIdx_SR->size[0] = 0;
    }

    /* Linear index indicating ROIs that correspond to skin detections */
    /* M x 1 column vector; type int32. */
    if (NDetectionsSkin_SR != 0) {
      i = ROIBlockDetectionSkinLinIdx_SR->size[0];
      ROIBlockDetectionSkinLinIdx_SR->size[0] = NDetectionsSkin_SR;
      emxEnsureCapacity_int32_T(ROIBlockDetectionSkinLinIdx_SR, i);
    } else {
      ROIBlockDetectionSkinLinIdx_SR->size[0] = 0;
    }

    /* Linear index indicating ROIs that correspond to face detections, ROIs specified by argument  */
    /* ROISpecifiedByArgument, or skin detections. */
    /* M x 1 column vector; type int32. */
    if (NDetectionsFaceSkin_SR != 0) {
      i = c_ROIBlockDetectionFaceSkinLinI->size[0];
      c_ROIBlockDetectionFaceSkinLinI->size[0] = NDetectionsFaceSkin_SR;
      emxEnsureCapacity_int32_T(c_ROIBlockDetectionFaceSkinLinI, i);
    } else {
      c_ROIBlockDetectionFaceSkinLinI->size[0] = 0;
    }

    /* Converse */
    /* M x 1 column vector; type int32. */
    if (NNoDetectionsFaceSkin_SR != 0) {
      d_ROIBlockNoDetectionFaceSkinLi = NNoDetectionsFaceSkin_SR;
      if (0 <= NNoDetectionsFaceSkin_SR - 1) {
        memcpy(&g_ROIBlockNoDetectionFaceSkinLi[0],
               &f_ROIBlockNoDetectionFaceSkinLi[0], NNoDetectionsFaceSkin_SR *
               sizeof(int32_T));
      }
    }

    /* If code generation not running    */
    /* ROI matrix with modifications corresponding to block index */
    /* For the case of more than one output row assigned as output, ROI may not have had modifications, */
    /* but whether it had modifications or not does not affect this case. */
    /* Timestamps in block */
    i = TimestampBlock_SR->size[0];
    TimestampBlock_SR->size[0] = BlockFullLinIdx_SR->size[0];
    emxEnsureCapacity_real32_T(TimestampBlock_SR, i);
    Sum = BlockFullLinIdx_SR->size[0];
    for (i = 0; i < Sum; i++) {
      TimestampBlock_SR->data[i] = Timestamp->data[BlockFullLinIdx_SR->data[i] -
        1];
    }

    /* Timestamps in block corresponding to frames with a detection  */
    i = TimestampBlockDetections_SR->size[0];
    TimestampBlockDetections_SR->size[0] = c_ROIBlockDetectionFaceSkinLinI->
      size[0];
    emxEnsureCapacity_real32_T(TimestampBlockDetections_SR, i);
    Sum = c_ROIBlockDetectionFaceSkinLinI->size[0];
    for (i = 0; i < Sum; i++) {
      TimestampBlockDetections_SR->data[i] = TimestampBlock_SR->
        data[c_ROIBlockDetectionFaceSkinLinI->data[i] - 1];
    }

    guard1 = true;
  }

  if (guard1) {
    /*  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
    /* %% Match sizes ROIs to be more consistent across algorithms %%% */
    /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
    /* Match sizes of ROIs that correspond to detections to be more consistent across detection */
    /* algorithms. */
    /* Note: ROIMSIR_MatchSize is a custom function located within folder 'FacePulseRate'. */
    /* First-read operations */
    if (FirstReadTF) {
      /* 229 x 4 row vector; type int16. */
      /* ROIMSIR_MatchSize    Match sizes of ROIs that correspond to detections to be more consistent   */
      /*                      across detection algorithms. */
      /*  */
      /*     Helper function to function FacePulseRate.  */
      /*     Within function FacePulseRate, called by function ROIMSIR. */
      /*  */
      /*  */
      /*     Code Generation */
      /*     --------------- */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /*  */
      /*  */
      /*     Description */
      /*     ----------- */
      /*  */
      /*     The ROIs returned across different detection algorithms systematically differ in size. For */
      /*     example, the default primary face-detection algorithm returns an ROI about half the size of  */
      /*     the default secondary #1 face-detection algorithm. The sizes of ROIs that correspond to   */
      /*     detections are adjusted to be more similar to increase stability of sizes across frames. The */
      /*     objective of increased stability is to reduce fluctuations in the ROI means from ROIs across  */
      /*     frames, which could introduce artifacts into the pulse rate processing. */
      /*  */
      /*     In this implementation, ROIs from detections are matched to the size of ROIs from the primary  */
      /*     face-detection algorithm, the size of which is used because it tends to capture much of the  */
      /*     face without permitting non-skin pixels. The size matching is implemented by multiplying the */
      /*     size of the ROI by the ratio indicating the systematic size difference between the ROIs  */
      /*     returned from the primary face-detection algorithm and the ROIs returned from the algorithm */
      /*     that corresponds to the ROI. For example, the size ratio of the primary face-detection */
      /*     algorithm to the secondary #1 face-detection algorithm might be .8 for width and .6 for   */
      /*     height. In such a case, the width and height of an ROI returned by the secondary #1    */
      /*     face-detection algorithm would be multiplied by .8 and .6, respectively. A ratio, rather than  */
      /*     a fixed size, is used to permit the size of the ROI to vary based upon other factors, such as  */
      /*     the distance between the face and the camera. As the ROI size of the primary face-detection  */
      /*     algorithm is used as the target size, ROIs from the primary face-detection algorithm are not */
      /*     adjusted here. */
      /*       */
      /*     Hypothetically, the systematic size differences between the primary face-detection algorithm  */
      /*     and other detection algorithms might be known in advance. However, this implementation assumes */
      /*     they are initially unknown and calculates the systematic size differences (the ratios) based  */
      /*     on the ROI sizes it observes. The accuracy of calculating the systematic size differences  */
      /*     may improve as more ROIs are observed; to take advantage of this, the systematic size  */
      /*     differences are recalculated on each call to the function. The accuracy may improve as more   */
      /*     ROIs are observed because a larger quantity of ROIs may reduce the impact of momentary    */
      /*     influences by factors other than the systematic size difference. For example, the calculated  */
      /*     size difference may also be due to the distance between the face and the camera if the  */
      /*     primary face-detection algorithm happened to make more detections when the face was near the  */
      /*     camera whereas other algorithms happened to make detections when the face was distant from the  */
      /*     camera. As a result, the calculation will not accurately reflect only the systematic size */
      /*     difference. As more ROIs are observed, it is anticipated that size differences due to other    */
      /*     factors, such as distance, will cancel out to a certain extent. */
      /*  */
      /*  */
      /*     Copyright */
      /*     --------- */
      /*  */
      /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
      /*     the Responsible AI License (RAIL). */
      /* %%%%% Code generation settings %%%%%% */
      /* Inline function */
      /* Call function as extrinsic */
      /* See note where warning() is used. */
      /* Call function as extrinsic so that stack trace can be displayed */
      /* %%%%% Setup %%%%%% */
      /* Length of ROI block */
      /* %%%%% Take means of ROIs corresponding to detection-algorithm detections %%%%%% */
      /* Return means from detection-algorithm detections */
      /* Also return accumulators for use on subsequent function calls. */
      /* Local function. */
      /* end main function */
      /* ============================================================================================= */
      /* Local functions */
      /* ============================================================================================= */
      /* ============================================================================================= */
      /* DetectionMeans   Take means of ROIs corresponding to detection-algorithm detections. */
      /* Inline function */
      /* %%%%% Take means over a range of frames %%%%%% */
      /* If first call to function or if called within post-processing second-read operations */
      /* Note: the first call to function always occurs during the first-read operations. */
      /* Note: in the pre-processing second-read operations, no new detections will be encountered, so this */
      /* loop does not need to be run. In the post-processing second-read operations, the new detections */
      /* are skin detections from frame 1 until the length of BlockFullLinIdx. */
      if (FirstCallTF || SecondReadPostProcessingTF) {
        VideoReadConfig_FrameIdx_Length = BlockFullLinIdx_FR[228];

        /* Loop across ROI rows */
        for (b_i = 0; b_i < VideoReadConfig_FrameIdx_Length; b_i++) {
          /* %%%%% --- First-call operations %%%%%% */
          /* If called during the first call to the function */
          if (FirstCallTF) {
            /* If detection from primary algorithm */
            if (HasROI_TF->FacePrimary->data[b_i]) {
              /* Cast to floating-point type and accumulate width sum  */
              ROIMatchSizeData->SumW_Pri += (real32_T)ROINoMods->data[b_i +
                ROINoMods->size[0] * 2];

              /* Cast to floating-point type and accumulate height sum  */
              ROIMatchSizeData->SumH_Pri += (real32_T)ROINoMods->data[b_i +
                ROINoMods->size[0] * 3];

              /* Detection count */
              ROIMatchSizeData->AlgN_Pri++;

              /* Mean width from primary algorithm */
              ROIMatchSizeData->ROIMeanWidthPri = ROIMatchSizeData->SumW_Pri /
                ROIMatchSizeData->AlgN_Pri;

              /* Mean height from primary algorithm */
              ROIMatchSizeData->ROIMeanHeightPri = ROIMatchSizeData->SumH_Pri /
                ROIMatchSizeData->AlgN_Pri;
            }

            /* If detection from secondary #1 algorithm */
            if (HasROI_TF->FaceSecondary1->data[b_i]) {
              /* Cast to floating-point type and accumulate width sum */
              ROIMatchSizeData->SumW_Sec1 += (real32_T)ROINoMods->data[b_i +
                ROINoMods->size[0] * 2];

              /* Cast to floating-point type and accumulate height sum */
              ROIMatchSizeData->SumH_Sec1 += (real32_T)ROINoMods->data[b_i +
                ROINoMods->size[0] * 3];

              /* Detection count */
              ROIMatchSizeData->AlgN_Sec1++;

              /* Mean ROI width from secondary #1 algorithm */
              ROIMatchSizeData->ROIMeanWidthSec1 = ROIMatchSizeData->SumW_Sec1 /
                ROIMatchSizeData->AlgN_Sec1;

              /* Mean ROI height from secondary #1 algorithm */
              ROIMatchSizeData->ROIMeanHeightSec1 = ROIMatchSizeData->SumH_Sec1 /
                ROIMatchSizeData->AlgN_Sec1;
            }

            /* If detection from secondary #1 algorithm */
            if (HasROI_TF->FaceSecondary2->data[b_i]) {
              /* Cast to floating-point type and accumulate width sum  */
              ROIMatchSizeData->SumW_Sec2 += (real32_T)ROINoMods->data[b_i +
                ROINoMods->size[0] * 2];

              /* Cast to floating-point type and accumulate height sum */
              ROIMatchSizeData->SumH_Sec2 += (real32_T)ROINoMods->data[b_i +
                ROINoMods->size[0] * 3];

              /* Detection count */
              ROIMatchSizeData->AlgN_Sec2++;

              /* Mean ROI width from secondary #2 algorithm */
              ROIMatchSizeData->ROIMeanWidthSec2 = ROIMatchSizeData->SumW_Sec2 /
                ROIMatchSizeData->AlgN_Sec2;

              /* Mean ROI height from secondary #2 algorithm */
              ROIMatchSizeData->ROIMeanHeightSec2 = ROIMatchSizeData->SumH_Sec2 /
                ROIMatchSizeData->AlgN_Sec2;
            }
          }

          /* %%%%% --- First-call or second-read post-processing operations %%%%%%          */
          if ((FirstCallTF || SecondReadPostProcessingTF) && HasROI_TF->
              Skin->data[b_i]) {
            /* If detection from skin algorithm */
            /* Cast to floating-point type and accumulate width sum  */
            ROIMatchSizeData->SumW_Skin += (real32_T)ROINoMods->data[b_i +
              ROINoMods->size[0] * 2];

            /* Cast to floating-point type and accumulate height sum */
            ROIMatchSizeData->SumH_Skin += (real32_T)ROINoMods->data[b_i +
              ROINoMods->size[0] * 3];

            /* Detection count */
            ROIMatchSizeData->AlgN_Skin++;

            /* Mean ROI width from skin algorithm */
            ROIMatchSizeData->ROIMeanWidthSkin = ROIMatchSizeData->SumW_Skin /
              ROIMatchSizeData->AlgN_Skin;

            /* Mean ROI height from skin algorithm */
            ROIMatchSizeData->ROIMeanHeightSkin = ROIMatchSizeData->SumH_Skin /
              ROIMatchSizeData->AlgN_Skin;
          }
        }

        /* %%%%% Take means by addition of one frame %%%%%%     */
        /* If during the first-read operations (other than the first call to the function) */
      } else {
        /* Index of last frame that has been read */
        if (HasROI_TF->FacePrimary->data[BlockFullLinIdx_FR[228] - 1]) {
          /* Cast to floating-point type and accumulate width sum  */
          ROIMatchSizeData->SumW_Pri += (real32_T)ROINoMods->data
            [(BlockFullLinIdx_FR[228] + ROINoMods->size[0] * 2) - 1];

          /* Cast to floating-point type and accumulate height sum  */
          ROIMatchSizeData->SumH_Pri += (real32_T)ROINoMods->data
            [(BlockFullLinIdx_FR[228] + ROINoMods->size[0] * 3) - 1];

          /* Increase count */
          ROIMatchSizeData->AlgN_Pri++;

          /* Mean width from primary algorithm */
          ROIMatchSizeData->ROIMeanWidthPri = ROIMatchSizeData->SumW_Pri /
            ROIMatchSizeData->AlgN_Pri;

          /* Mean height from primary algorithm */
          ROIMatchSizeData->ROIMeanHeightPri = ROIMatchSizeData->SumH_Pri /
            ROIMatchSizeData->AlgN_Pri;
        }

        if (HasROI_TF->FaceSecondary1->data[BlockFullLinIdx_FR[228] - 1]) {
          /* Cast to floating-point type and accumulate width sum  */
          ROIMatchSizeData->SumW_Sec1 += (real32_T)ROINoMods->data
            [(BlockFullLinIdx_FR[228] + ROINoMods->size[0] * 2) - 1];

          /* Cast to floating-point type and accumulate height sum  */
          ROIMatchSizeData->SumH_Sec1 += (real32_T)ROINoMods->data
            [(BlockFullLinIdx_FR[228] + ROINoMods->size[0] * 3) - 1];

          /* Increase count */
          ROIMatchSizeData->AlgN_Sec1++;

          /* Mean ROI width from secondary #1 algorithm */
          ROIMatchSizeData->ROIMeanWidthSec1 = ROIMatchSizeData->SumW_Sec1 /
            ROIMatchSizeData->AlgN_Sec1;

          /* Mean ROI height from secondary #1 algorithm */
          ROIMatchSizeData->ROIMeanHeightSec1 = ROIMatchSizeData->SumH_Sec1 /
            ROIMatchSizeData->AlgN_Sec1;
        }

        if (HasROI_TF->FaceSecondary2->data[BlockFullLinIdx_FR[228] - 1]) {
          /* Cast to floating-point type and accumulate width sum  */
          ROIMatchSizeData->SumW_Sec2 += (real32_T)ROINoMods->data
            [(BlockFullLinIdx_FR[228] + ROINoMods->size[0] * 2) - 1];

          /* Cast to floating-point type and accumulate height sum  */
          ROIMatchSizeData->SumH_Sec2 += (real32_T)ROINoMods->data
            [(BlockFullLinIdx_FR[228] + ROINoMods->size[0] * 3) - 1];

          /* Increase count */
          ROIMatchSizeData->AlgN_Sec2++;

          /* Mean ROI width from secondary #2 algorithm */
          ROIMatchSizeData->ROIMeanWidthSec2 = ROIMatchSizeData->SumW_Sec2 /
            ROIMatchSizeData->AlgN_Sec2;

          /* Mean ROI height from secondary #2 algorithm */
          ROIMatchSizeData->ROIMeanHeightSec2 = ROIMatchSizeData->SumH_Sec2 /
            ROIMatchSizeData->AlgN_Sec2;
        }

        if (HasROI_TF->Skin->data[BlockFullLinIdx_FR[228] - 1]) {
          /* Cast to floating-point type and accumulate width sum  */
          ROIMatchSizeData->SumW_Skin += (real32_T)ROINoMods->data
            [(BlockFullLinIdx_FR[228] + ROINoMods->size[0] * 2) - 1];

          /* Cast to floating-point type and accumulate height sum  */
          ROIMatchSizeData->SumH_Skin += (real32_T)ROINoMods->data
            [(BlockFullLinIdx_FR[228] + ROINoMods->size[0] * 3) - 1];

          /* Increase count */
          ROIMatchSizeData->AlgN_Skin++;

          /* Mean ROI width from skin algorithm */
          ROIMatchSizeData->ROIMeanWidthSkin = ROIMatchSizeData->SumW_Skin /
            ROIMatchSizeData->AlgN_Skin;

          /* Mean ROI height from skin algorithm */
          ROIMatchSizeData->ROIMeanHeightSkin = ROIMatchSizeData->SumH_Skin /
            ROIMatchSizeData->AlgN_Skin;
        }
      }

      /* %%%%% Assign for use in function ROIMSIR_MatchSize %%%%%% */
      /* end local function */
      /* ============================================================================================= */
      /* Code-generation and build script */
      /* ============================================================================================= */
      /* Note: this function is not currently used as a compiled function as it is nested within a */
      /* compiled function, ROIMSIR_mex. */
      /* Code-generation and build script used to generate C-language code and create the compiled version  */
      /* (ROIMSIR_MatchSize_mex) of the function. */
      /* { */
      /*                  */
      /*  */
      /* %%%%% Specify variable-size input arguments %%%%%% */
      /*  */
      /* See Matlab documentation for coder.typeof. */
      /*  */
      /* Specify struct variable-size element properties */
      /* Element1 = ... */
      /*     coder.typeof(false(500, 1), ... example code */
      /*                  [inf, 1],      ... upper bounds */
      /*                  [1, 0]         ... variable size (T/F) */
      /*     ); */
      /*  */
      /* HasROI_TFCode = ... */
      /*     struct( ... */
      /*         'ByAnyMethod',                      Element1, ...    */
      /*         'FacePrimary',                      Element1, ... */
      /*         'FacePrimaryAttempted',             Element1, ... */
      /*         'FaceSecondary1',                   Element1, ... */
      /*         'FaceSecondary1Attempted',          Element1, ... */
      /*         'FaceSecondary2',                   Element1, ... */
      /*         'FaceSecondary2Attempted',          Element1, ... */
      /*         'Skipped',                          Element1, ... */
      /*         'Skin',                             Element1, ... */
      /*         'SkinAttempted',                    Element1, ... */
      /*         'Interpolated',                     Element1, ... */
      /*         'AdjustedBecauseLowSkinProportion', Element1, ... */
      /*         'ROISpecifiedByArgument',           Element1, ... */
      /*         'ROIIgnoreByArgument',              Element1 ... */
      /*     ); */
      /*  */
      /*                                                      Example Code                 Upp. Bounds  Var. Size (T/F)  Type */
      /* ROINoModsCode                         = coder.typeof( zeros(500, 4, 'int16'),      [inf, 4],    [1, 0] );        %int16 */
      /* ROINoPrevCallsBlockCode               = coder.typeof( zeros(500, 4, 'int16'),      [inf, 4],    [1, 0] );        %int16 */
      /* BlockFullLinIdxCode                   = coder.typeof( zeros(1, 500, 'uint32'),     [1, inf],    [0, 1] );        %int32 */
      /* ROIBlockDetectionSkinLogIdxCode       = coder.typeof( false(500, 1),               [inf, 1],    [1, 0] );        %logical */
      /* ROIBlockDetectionFaceSkinLogIdxCode   = coder.typeof( false(500, 1),               [inf, 1],    [1, 0] );        %logical  */
      /* VideoReadConfig_FrameIdxCode          = coder.typeof( zeros(1, 500, 'uint32'),     [1, inf],    [0, 1] );        %int32  */
      /*                   */
      /*  */
      /* %%%%% Specify fixed-size input arguments %%%%%% */
      /*  */
      /* VidObjWidthCode                          = int16(0);          */
      /* VidObjHeightCode                         = int16(0); */
      /* FirstReadTFCode                          = false; */
      /* SecondReadPostProcessingTFCode           = false; */
      /* RowToReturnFullLinIdxCode                = int32(0); */
      /* FaceDetectConfig_ROIFaceSecondary1TFCode = false; */
      /* FaceDetectConfig_ROIFaceSecondary2TFCode = false; */
      /*  */
      /*  */
      /* %%%%% Set configurations to increase performance %%%%%% */
      /*  */
      /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
      /* "Optimization Strategies" */
      /* cfg = coder.config('mex'); */
      /* cfg.GlobalDataSyncMethod = 'NoSync'; */
      /* cfg.ConstantInputs = 'IgnoreValues'; */
      /* cfg.ExtrinsicCalls = false; */
      /* cfg.SaturateOnIntegerOverflow = false; */
      /* cfg.IntegrityChecks = false; */
      /* cfg.ResponsivenessChecks = false; */
      /*  */
      /*  */
      /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
      /*  */
      /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
      /*  */
      /* The flags are specified as part of the code-generation configuration object. A custom function, */
      /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
      /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
      /* Matlab guidance found in */
      /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
      /*  */
      /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
      /* a character vector prior to execution of the codegen command. */
      /*  */
      /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
      /*  */
      /* Argument buildInfo: this variable is assign by the caller (the codegen command executed  */
      /* below) and is not present in the base workspace. */
      /*  */
      /* Second argument: specify a cell array of compiler-specific flags, where each flag is a  */
      /* character vector. As function setbuildargs will be evaluated from text, use double ' quotes for  */
      /* each character vector to maintain the charater vector, */
      /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
      /*  */
      /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
      /*  */
      /* Assign to code-generation configuration object */
      /* cfg.PostCodeGenCommand = setbuildargsAsText; */
      /*  */
      /*  */
      /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
      /*  */
      /* codegen ROIMSIR_MatchSize.m -config cfg -args {ROINoModsCode, ROINoPrevCallsBlockCode, HasROI_TFCode, ROIBlockDetectionSkinLogIdxCode, ROIBlockDetectionFaceSkinLogIdxCode, BlockFullLinIdxCode, VidObjWidthCode, VidObjHeightCode, FirstReadTFCode, SecondReadPostProcessingTFCode, FaceDetectConfig_ROIFaceSecondary1TFCode, FaceDetectConfig_ROIFaceSecondary2TFCode, VideoReadConfig_FrameIdxCode, RowToReturnFullLinIdxCode} */
      /*               */
      /* } */
      /* %%%%% Size match face-detection ROIs in block to be more similar across face-detection algorithms %%%%%% */
      /* Note: used during the first read or during the second read in the pre-processing (but not   */
      /* post-processing) step. During the second read pre-processing step, size match ROIs near the  */
      /* beginning of the video that were not size matched during the first read. The second read does not  */
      /* use the face-detection algorithm(s), so size matching is not needed during the second read  */
      /* post-processing step.  */
      /*  first read */
      /*    second read pre-processing step  */
      /* %%%%% --- Match the size of secondary. #1 alg. ROIs in block to size of primary alg. ROIs %%%%%%    */
      /*  if sec. #1 alg. enabled */
      /*  if any sec. #1 alg. detections in block */
      /*  min sample for better ratio determination */
      if (c_FaceDetectConfig_ROIFaceSecon) {
        HasROI_TF_size[0] = 229;
        for (i = 0; i < 229; i++) {
          HasROI_TF_data[i] = HasROI_TF->FaceSecondary1->
            data[BlockFullLinIdx_FR[i] - 1];
        }

        if (vectorAny(HasROI_TF_data, HasROI_TF_size) &&
            (ROIMatchSizeData->AlgN_Pri > 5.0F) && (ROIMatchSizeData->AlgN_Sec1 >
             5.0F)) {
          /*    min sample for better ratio determination        */
          /* Determine size ratio of primary alg. to secondary #1 alg */
          WidthRatio_Single = ROIMatchSizeData->ROIMeanWidthPri /
            ROIMatchSizeData->ROIMeanWidthSec1;
          HeightRatio_Single = ROIMatchSizeData->ROIMeanHeightPri /
            ROIMatchSizeData->ROIMeanHeightSec1;

          /* Logical index of secondary #1 algorithm detections within ROI block */
          /* Loop across elements of ROIs where a detection was made by the secondary #1 algorithm */
          for (b_i = 0; b_i < 229; b_i++) {
            /* Where an ROI corresponds to the detection algorithm */
            if (HasROI_TF->FaceSecondary1->data[BlockFullLinIdx_FR[b_i] - 1]) {
              /* Match ROI widths and heights of ROIs from secondary #1 algorithm: */
              /* Extract width and height of ith ROI */
              Width_ith = ROINoPrevCallsBlock_FR[b_i + 458];
              Height_ith = ROINoPrevCallsBlock_FR[b_i + 687];

              /* Adjust size by primary-to-secondary #1 ROI width ratio */
              /* Cast to floating point type during calculation */
              WidthNew_ith = (int16_T)muSingleScalarRound((real32_T)Width_ith *
                WidthRatio_Single);

              /* Adjust size by primary-to-secondary #1 ROI height ratio */
              /* Cast to floating point type during calculation */
              HeightNew_ith = (int16_T)muSingleScalarRound((real32_T)Height_ith *
                HeightRatio_Single);

              /* Reassign */
              ROINoPrevCallsBlock_FR[b_i + 458] = WidthNew_ith;
              ROINoPrevCallsBlock_FR[b_i + 687] = HeightNew_ith;

              /* Adjust X- and Y-coordinates to correspond to adjustments in widths and heights: */
              /* Half of difference between unmatched widths and height and adjusted widths and  */
              /* heights. */
              /* Optimize division by two by bit-wise operation. */
              /* Add the half-differences to the X- and Y-coordinates */
              /* Note: if there were negative differences, the half-differences will be subtracted  */
              /* from the X- and Y-coordinates. */
              ROINoPrevCallsBlock_FR[b_i] = (int16_T)(ROINoPrevCallsBlock_FR[b_i]
                + ((int16_T)(Width_ith - WidthNew_ith) >> 1));
              ROINoPrevCallsBlock_FR[b_i + 229] = (int16_T)
                (ROINoPrevCallsBlock_FR[b_i + 229] + ((int16_T)(Height_ith -
                   HeightNew_ith) >> 1));
            }
          }
        }
      }

      /* %%%%% --- Match the size of secondary. #2 alg. ROIs in block to size of primary alg. ROIs %%%%%%     */
      /*  if sec. #2 alg. enabled */
      /*  if any sec. #2 alg. detections in block */
      /*  min sample for better ratio determination */
      if (d_FaceDetectConfig_ROIFaceSecon) {
        HasROI_TF_size[0] = 229;
        for (i = 0; i < 229; i++) {
          HasROI_TF_data[i] = HasROI_TF->FaceSecondary2->
            data[BlockFullLinIdx_FR[i] - 1];
        }

        if (vectorAny(HasROI_TF_data, HasROI_TF_size) &&
            (ROIMatchSizeData->AlgN_Pri > 5.0F) && (ROIMatchSizeData->AlgN_Sec2 >
             5.0F)) {
          /*    min sample for better ratio determination        */
          /* Determine size ratio of primary alg. to secondary #2 alg */
          WidthRatio_Single = ROIMatchSizeData->ROIMeanWidthPri /
            ROIMatchSizeData->ROIMeanWidthSec2;
          HeightRatio_Single = ROIMatchSizeData->ROIMeanHeightPri /
            ROIMatchSizeData->ROIMeanHeightSec2;

          /* Logical index of secondary #2 algorithm detections within ROI block */
          /* Loop across elements of ROIs where a detection was made by the secondary #1 algorithm */
          for (b_i = 0; b_i < 229; b_i++) {
            /* Where an ROI corresponds to the detection algorithm */
            if (HasROI_TF->FaceSecondary2->data[BlockFullLinIdx_FR[b_i] - 1]) {
              /* Match ROI widths and heights of ROIs from secondary #2 algorithm: */
              /* Extract width and height of ith ROI */
              Width_ith = ROINoPrevCallsBlock_FR[b_i + 458];
              Height_ith = ROINoPrevCallsBlock_FR[b_i + 687];

              /* Adjust size by primary-to-secondary #2 ROI width ratio */
              /* Cast to floating point type during calculation */
              WidthNew_ith = (int16_T)muSingleScalarRound((real32_T)Width_ith *
                WidthRatio_Single);

              /* Adjust size by primary-to-secondary #2 ROI height ratio */
              /* Cast to floating point type during calculation */
              HeightNew_ith = (int16_T)muSingleScalarRound((real32_T)Height_ith *
                HeightRatio_Single);

              /* Reassign */
              ROINoPrevCallsBlock_FR[b_i + 458] = WidthNew_ith;
              ROINoPrevCallsBlock_FR[b_i + 687] = HeightNew_ith;

              /* Adjust X- and Y-coordinates to correspond to adjustments in widths and heights: */
              /* Half of difference between unmatched widths and height and adjusted widths and  */
              /* heights. */
              /* Optimize division by two by bit-wise operation. */
              /* Add the half-differences to the X- and Y-coordinates */
              /* Note: if there were negative differences, the half-differences will be subtracted  */
              /* from the X- and Y-coordinates. */
              ROINoPrevCallsBlock_FR[b_i] = (int16_T)(ROINoPrevCallsBlock_FR[b_i]
                + ((int16_T)(Width_ith - WidthNew_ith) >> 1));
              ROINoPrevCallsBlock_FR[b_i + 229] = (int16_T)
                (ROINoPrevCallsBlock_FR[b_i + 229] + ((int16_T)(Height_ith -
                   HeightNew_ith) >> 1));
            }
          }
        }
      }

      /* end if output is one row */
      /* %%%%% Match the size of skin-detection ROIs to the size of face-detection ROIs %%%%%% */
      /* Note: used during all calls. */
      /* During the second read pre-processing step, size match ROIs near the beginning of the video */
      /* that were not size matched during the first read. During the second read post-processing step, */
      /* size match ROIs near the beginning of the video based on recent skin-detection algorithm */
      /* ROI detections.  */
      /* If at least one skin-detection algorithm detection within block; no matching needed if no  */
      /* detections within block. */
      /* Also, at least two face-detection algorithm detections from which to make size match. */
      if ((NDetectionsSkin_FR != 0) && ((ROIMatchSizeData->AlgN_Pri > 1.0F) ||
           (ROIMatchSizeData->AlgN_Sec1 > 1.0F) || (ROIMatchSizeData->AlgN_Sec2 >
            1.0F))) {
        /* Use the ROIs from a face-detection algorithm as the basis of ROIs sizes for the ROIs from the */
        /* skin-detection algorithms. Use ROIs only from the primary face-detection algorithm if  */
        /* available. Otherwise, use ROIs only from the secondary #1 face-detection algorithm if  */
        /* available; otherwise, use ROIs from the secondary #2 face-detection algorithm. If ROI not */
        /* available from any face-detection algorithm, skip skin-detection ROI size adjustment. */
        /* Match widths and heights: */
        /* Use primary algorithm mean ROI size as basis for skin-detection ROI size */
        if (ROIMatchSizeData->AlgN_Pri > 1.0F) {
          /* Use primary algorithm as mean face-detection ROI size */
          HeightRatio_Single = ROIMatchSizeData->ROIMeanWidthPri;
          x_after = ROIMatchSizeData->ROIMeanHeightPri;

          /* Use secondary #1 algorithm mean ROI size as basis for skin-detection ROI size */
        } else if (ROIMatchSizeData->AlgN_Sec1 > 1.0F) {
          /* Use secondary #1 algorithm as mean face-detection ROI size */
          HeightRatio_Single = ROIMatchSizeData->ROIMeanWidthSec1;
          x_after = ROIMatchSizeData->ROIMeanHeightSec1;

          /* Use secondary #2 algorithm mean ROI size as basis for skin-detection ROI size */
        } else {
          /* Use secondary #2 algorithm as mean face-detection ROI size */
          HeightRatio_Single = ROIMatchSizeData->ROIMeanWidthSec2;
          x_after = ROIMatchSizeData->ROIMeanHeightSec2;
        }

        /* Determine face-to-skin size ratio  */
        WidthRatio_Single = HeightRatio_Single /
          ROIMatchSizeData->ROIMeanWidthSkin;
        HeightRatio_Single = x_after / ROIMatchSizeData->ROIMeanHeightSkin;

        /* Match ROI size of ROIs from skin-detection algorithm:     */
        /* Loop across elements of ROIs where a detection was made by the skin-detection algorithm */
        for (b_i = 0; b_i < NDetectionsSkin_FR; b_i++) {
          /* Where an ROI corresponds to the detection algorithm */
          /* Match ROI widths and heights of ROIs from skin-detection algorithm: */
          /* Extract width and height of ith ROI */
          i = c_ROIBlockDetectionSkinLinIdx_F[b_i];
          Width_ith = ROINoPrevCallsBlock_FR[i + 457];
          Height_ith = ROINoPrevCallsBlock_FR[i + 686];

          /* Adjust size by face-to-skin ROI width ratio */
          /* Cast to floating point type during calculation */
          WidthNew_ith = (int16_T)muSingleScalarRound((real32_T)Width_ith *
            WidthRatio_Single);

          /* Adjust size by face-to-skin ROI height ratio */
          /* Cast to floating point type during calculation */
          HeightNew_ith = (int16_T)muSingleScalarRound((real32_T)Height_ith *
            HeightRatio_Single);

          /* Reassign */
          ROINoPrevCallsBlock_FR[i + 457] = WidthNew_ith;
          ROINoPrevCallsBlock_FR[i + 686] = HeightNew_ith;

          /* Adjust X- and Y-coordinates to correspond to adjustments in widths and heights: */
          /* Half of difference between unmatched widths and height and adjusted widths and  */
          /* heights. */
          /* Optimize division by two by bit-wise operation. */
          /* Add the half-differences to the X- and Y-coordinates */
          /* Note: if there were negative differences, the half-differences will be subtracted  */
          /* from the X- and Y-coordinates. */
          ROINoPrevCallsBlock_FR[i - 1] = (int16_T)(ROINoPrevCallsBlock_FR[i - 1]
            + ((int16_T)(Width_ith - WidthNew_ith) >> 1));
          ROINoPrevCallsBlock_FR[i + 228] = (int16_T)(ROINoPrevCallsBlock_FR[i +
            228] + ((int16_T)(Height_ith - HeightNew_ith) >> 1));
        }
      }

      /* %%%%% Adjust ROI(s) that exceed frame dimensions %%%%%%    */
      /* Although ROI(s) are also checked later in function ROIMSIR, check here as well so that any */
      /* overshoots from size matching don't affect the detection-smoothing operations in function  */
      /* ROIMSIR_DetectionSmooth, which occurs before the check by ROIMSIR. Also, before the check by    */
      /* ROIMSIR, ROIs returned here will influence variable ROIOutBeforeFrameByFrameSmoothing_FR or */
      /* ROIOutBeforeFrameByFrameSmoothing_SR (assigned in function ROIMSIR), and this variable needs to be   */
      /* within frame dimensions for later use in function WriteFaceVideo.  */
      /* Adjust any coordinates that exceed frame dimensions */
      /* M x 4 matrix (229 x 4 during first-read operations); type int16. */
      /* Note: ROIAdjustIfExceedsFrameDims is a custom function located within folder 'FacePulseRate'. */
      i = ROIBlockFaceSkin_Temp->size[0] * ROIBlockFaceSkin_Temp->size[1];
      ROIBlockFaceSkin_Temp->size[0] = d_ROIBlockDetectionFaceSkinLinI;
      ROIBlockFaceSkin_Temp->size[1] = 4;
      emxEnsureCapacity_int16_T(ROIBlockFaceSkin_Temp, i);
      for (i = 0; i < d_ROIBlockDetectionFaceSkinLinI; i++) {
        ROIBlockFaceSkin_Temp->data[i] =
          ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] - 1];
      }

      for (i = 0; i < d_ROIBlockDetectionFaceSkinLinI; i++) {
        ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0]] =
          ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] + 228];
      }

      for (i = 0; i < d_ROIBlockDetectionFaceSkinLinI; i++) {
        ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 2] =
          ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] + 457];
      }

      for (i = 0; i < d_ROIBlockDetectionFaceSkinLinI; i++) {
        ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 3] =
          ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] + 686];
      }

      /* ROIAdjustIfExceedsFrameDims   Verify whether proposed widths and heights of ROIs exceed frame  */
      /*                               dimensions and, if so, modify them to conform to frame dimensions. */
      /*                                */
      /*     Helper function to function FacePulseRate. */
      /*     Within function FacePulseRate, called by functions ROIResize, ROIMeans_FirstRead_Extrapolate, */
      /*     SkinDetect_EnlargeROI, ROIMSIR, ROIMSIR_MatchSize, ROIMSIR_DetectionSmooth,   */
      /*     ROIMSIR_Interpolate, and ROIMSIR_FrameByFrameSmooth.    */
      /*  */
      /*  */
      /*     Code Generation */
      /*     --------------- */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /*  */
      /*  */
      /*     Description */
      /*     ----------- */
      /*  */
      /*     This function verifies that ROIs that have had modifications to their sizes are still within */
      /*     the dimensions of the frame. If not, this function adjusts the dimensions (and, consequently,   */
      /*     the spatial coordinates) to conform to the frame dimensions. */
      /*  */
      /*     Note:  */
      /*  */
      /*     Intended only for use with integer types as rounding is not conducted. For modification for  */
      /*     use with floating-point types, rounding would be necessary as ROI values should be integers. */
      /*  */
      /*  */
      /*     Copyright */
      /*     --------- */
      /*  */
      /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
      /*     the Responsible AI License (RAIL). */
      /* %%%%% Validate inputs %%%%%% */
      /* Exit if empty */
      if (d_ROIBlockDetectionFaceSkinLinI != 0) {
        /* Validate whether input ROIsProposed is type int16. */
        /* Must be an integer type because no rounding is conducted. */
        /* Should be type int16 because the function is implemented to assign values of this type. */
        /* A non-matching type would be due to an implementation error. */
        /* %%%%% Running in code generation %%%%%% */
        /* When running in code generation, use for-loops. When running in Matlab code, use vectorization. */
        /* code generation running */
        /* Inline function */
        for (b_i = 0; b_i < d_ROIBlockDetectionFaceSkinLinI; b_i++) {
          /* %%%%% --- Verify, and adjust if necessary, X-coordinates and widths %%%%%% */
          /* Adjust left-side X-coordinate if exceeds frame dimensions: */
          WidthNew_ith = ROIBlockFaceSkin_Temp->data[b_i];
          if (WidthNew_ith < 1) {
            WidthNew_ith = 1;

            /* recent code mod */
            ROIBlockFaceSkin_Temp->data[b_i] = 1;
          } else {
            if (WidthNew_ith > VidObjWidth) {
              WidthNew_ith = VidObjWidth;

              /* recent code mod */
              ROIBlockFaceSkin_Temp->data[b_i] = VidObjWidth;
            }
          }

          /* Adjust right-side X-coordinate if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(WidthNew_ith +
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 2])
                                - 1);
          if (Width_ith > VidObjWidth) {
            Width_ith = VidObjWidth;
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 2]
              = (int16_T)((int16_T)(VidObjWidth - WidthNew_ith) + 1);
          } else {
            if (Width_ith < 1) {
              Width_ith = 1;
              WidthNew_ith = 1;
              ROIBlockFaceSkin_Temp->data[b_i] = 1;
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                2] = 1;
            }
          }

          /* Adjust width if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(Width_ith - WidthNew_ith) + 1);
          if (Width_ith > VidObjWidth) {
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 2]
              = VidObjWidth;
          } else {
            if (Width_ith < 1) {
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                2] = 1;
            }
          }

          /* %%%%% --- Verify, and adjust if necessary, Y-coordinates and heights %%%%%% */
          /* Adjust top-side Y-coordinate if exceeds frame dimensions: */
          Height_ith = ROIBlockFaceSkin_Temp->data[b_i +
            ROIBlockFaceSkin_Temp->size[0]];
          if (Height_ith < 1) {
            Height_ith = 1;

            /* recent code mod */
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0]] =
              1;
          } else {
            if (Height_ith > VidObjHeight) {
              Height_ith = VidObjHeight;

              /* recent code mod */
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0]] =
                VidObjHeight;
            }
          }

          /* Adjust bottom-side Y-coordinate if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(Height_ith +
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 3])
                                - 1);
          if (Width_ith > VidObjHeight) {
            Width_ith = VidObjHeight;
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 3]
              = (int16_T)((int16_T)(VidObjHeight - Height_ith) + 1);
          } else {
            if (Width_ith < 1) {
              Width_ith = 1;
              Height_ith = 1;
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0]] =
                1;
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                3] = 1;
            }
          }

          /* Adjust height value if exceeds frame dimensions: */
          HeightNew_ith = (int16_T)((int16_T)(Width_ith - Height_ith) + 1);
          if (HeightNew_ith > VidObjHeight) {
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 3]
              = VidObjHeight;
          } else {
            if (HeightNew_ith < 1) {
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                3] = 1;
            }
          }
        }

        /* %%%%% Code generation not running %%%%%% */
      } else {
        /* Exit function */
      }

      /* end function */
      /* ============================================================================================= */
      /* Code-generation and build script */
      /* ============================================================================================= */
      /* Code-generation and build script used to generate C-language code and create the compiled version  */
      /* (ROIAdjustIfExceedsFrameDims_mex) of the function. */
      /* { */
      /*  */
      /* %%%%% Specify variable-size input arguments %%%%%% */
      /*  */
      /* See Matlab documentation for coder.typeof. */
      /*  */
      /*                                   Example Code               Upp. Bounds   Var. Size (T/F)  Type */
      /* ROIsProposedCode   = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],     [1, 0] );        %int16 */
      /*            */
      /*        */
      /* %%%%% Specify fixed-size input arguments %%%%%% */
      /*  */
      /* VidObjWidthCode  = int16(0);          */
      /* VidObjHeightCode = int16(0); */
      /*                    */
      /*  */
      /* %%%%% Set configurations to increase performance %%%%%% */
      /*  */
      /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
      /* "Optimization Strategies" */
      /*  */
      /* cfg = coder.config('mex'); */
      /* cfg.GlobalDataSyncMethod = 'NoSync'; */
      /* cfg.ConstantInputs = 'IgnoreValues'; */
      /* cfg.ExtrinsicCalls = true; %permit to show assert error */
      /* cfg.SaturateOnIntegerOverflow = false; */
      /* cfg.IntegrityChecks = false; */
      /* cfg.ResponsivenessChecks = false; */
      /*  */
      /*  */
      /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
      /*  */
      /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
      /*  */
      /* The flags are specified as part of the code-generation configuration object. A custom function, */
      /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
      /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
      /* Matlab guidance found in */
      /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
      /*  */
      /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
      /* a character vector prior to execution of the codegen command. */
      /*  */
      /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
      /*  */
      /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
      /* is not present in the base workspace. */
      /*  */
      /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
      /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
      /* character vector to maintain the charater vector, */
      /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
      /*  */
      /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
      /*  */
      /* Assign to code-generation configuration object */
      /* cfg.PostCodeGenCommand = setbuildargsAsText; */
      /*  */
      /*  */
      /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
      /*  */
      /* codegen ROIAdjustIfExceedsFrameDims.m -report -config cfg -args {ROIsProposedCode, VidObjWidthCode, VidObjHeightCode} */
      /*                  */
      /* } */
      Sum = ROIBlockFaceSkin_Temp->size[0];
      for (i = 0; i < Sum; i++) {
        ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] - 1] =
          ROIBlockFaceSkin_Temp->data[i];
      }

      for (i = 0; i < Sum; i++) {
        ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] + 228] =
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0]];
      }

      for (i = 0; i < Sum; i++) {
        ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] + 457] =
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 2];
      }

      for (i = 0; i < Sum; i++) {
        ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] + 686] =
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 3];
      }

      /* %%%%% Output validation %%%%%% */
      /* First-read operations */
      /* Check whether any ROI value is zero */
      /* The operations of this function were intended to prevent values of zero, so such a value is */
      /* likely due to an implementation error in this function. */
      /* Loop across columns */
      for (b_i = 0; b_i < 4; b_i++) {
        /* Loop across ROIs rows that correspond to ROIs modified in the current function */
        for (j = 0; j < NDetectionsFaceSkin_FR; j++) {
          if (ROINoPrevCallsBlock_FR[(f_ROIBlockDetectionFaceSkinLinI[j] + 229 *
               b_i) - 1] == 0) {
            /* Throw error */
            /* Called as extrinsic so that stack trace can be displayed. */
            b_sprintf(VideoReadConfig_FrameIdx_FR->data[RowToReturnFullLinIdx_FR
                      - 1], r1);
            i = varargin_2->size[0] * varargin_2->size[1];
            varargin_2->size[0] = 1;
            varargin_2->size[1] = r1->size[1] + 237;
            emxEnsureCapacity_char_T(varargin_2, i);
            for (i = 0; i < 70; i++) {
              varargin_2->data[i] = cv10[i];
            }

            for (i = 0; i < 68; i++) {
              varargin_2->data[i + 70] = cv11[i];
            }

            for (i = 0; i < 34; i++) {
              varargin_2->data[i + 138] = cv12[i];
            }

            Sum = r1->size[1];
            for (i = 0; i < Sum; i++) {
              varargin_2->data[i + 172] = r1->data[i];
            }

            for (i = 0; i < 65; i++) {
              varargin_2->data[(i + r1->size[1]) + 172] = cv13[i];
            }

            error(emlrt_marshallOut(cv3), b_emlrt_marshallOut(varargin_2),
                  &f_emlrtMCI);
          }
        }
      }

      /* Check whether the ROI size is unreasonably small */
      /* Such a small size is likely due to an implementation error in this function. */
      /* This check is intended to be run when testing new implementations, as small ROI sizes are an */
      /* indication of a implementation error. As occassional values below 20 may be considered */
      /* acceptable, this check is not intended for use outside of testing. "Occassional" in this case    */
      /* might be defined as a few occurances out of 10,000. Flag ExpectedBehaviorTestTF enables the */
      /* check.     */
      if (ExpectedBehaviorTestTF) {
        i = x->size[0] * x->size[1];
        x->size[0] = d_ROIBlockDetectionFaceSkinLinI;
        x->size[1] = 2;
        emxEnsureCapacity_boolean_T(x, i);
        for (i = 0; i < d_ROIBlockDetectionFaceSkinLinI; i++) {
          x->data[i] = (ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i]
                        + 457] < 20);
        }

        for (i = 0; i < d_ROIBlockDetectionFaceSkinLinI; i++) {
          x->data[i + x->size[0]] =
            (ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] + 686] <
             20);
        }

        winNew = x->size[0] << 1;
        c_x = *x;
        c_VideoReadConfig_FrameIdx_FR[0] = winNew;
        c_x.size = &c_VideoReadConfig_FrameIdx_FR[0];
        c_x.numDimensions = 1;
        if (any(&c_x)) {
          /* Note: function warning() not available for code generation; so it must have previously */
          /* been declared as extrinsic. */
          /* Function fprintf can not be used as a substitute for warning() in this case because  */
          /* fprintf can not accept variable-length arguments.    */
          b_sprintf(VideoReadConfig_FrameIdx_FR->data[RowToReturnFullLinIdx_FR -
                    1], r1);
          i = varargin_2->size[0] * varargin_2->size[1];
          varargin_2->size[0] = 1;
          varargin_2->size[1] = r1->size[1] + 296;
          emxEnsureCapacity_char_T(varargin_2, i);
          for (i = 0; i < 80; i++) {
            varargin_2->data[i] = cv15[i];
          }

          for (i = 0; i < 77; i++) {
            varargin_2->data[i + 80] = cv16[i];
          }

          for (i = 0; i < 74; i++) {
            varargin_2->data[i + 157] = cv17[i];
          }

          Sum = r1->size[1];
          for (i = 0; i < Sum; i++) {
            varargin_2->data[i + 231] = r1->data[i];
          }

          for (i = 0; i < 46; i++) {
            varargin_2->data[(i + r1->size[1]) + 231] = cv18[i];
          }

          for (i = 0; i < 19; i++) {
            varargin_2->data[(i + r1->size[1]) + 277] = cv19[i];
          }

          warning(emlrt_marshallOut(cv3), b_emlrt_marshallOut(varargin_2),
                  &g_emlrtMCI);
        }
      }

      /* Second-read operations     */
      /* Second-read operations         */
    } else {
      /* Note: during the second-read operations, the following arguments are entered but not used: */
      /* VideoReadConfig_FrameIdx_FR and RowToReturnFullLinIdx_FR. */
      /* Note: 0 was previously assigned to variable RowToReturnFullLinIdx_FR.  */
      /* M x 4 matrix; type int16. */
      /* ROIMSIR_MatchSize    Match sizes of ROIs that correspond to detections to be more consistent   */
      /*                      across detection algorithms. */
      /*  */
      /*     Helper function to function FacePulseRate.  */
      /*     Within function FacePulseRate, called by function ROIMSIR. */
      /*  */
      /*  */
      /*     Code Generation */
      /*     --------------- */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /*  */
      /*  */
      /*     Description */
      /*     ----------- */
      /*  */
      /*     The ROIs returned across different detection algorithms systematically differ in size. For */
      /*     example, the default primary face-detection algorithm returns an ROI about half the size of  */
      /*     the default secondary #1 face-detection algorithm. The sizes of ROIs that correspond to   */
      /*     detections are adjusted to be more similar to increase stability of sizes across frames. The */
      /*     objective of increased stability is to reduce fluctuations in the ROI means from ROIs across  */
      /*     frames, which could introduce artifacts into the pulse rate processing. */
      /*  */
      /*     In this implementation, ROIs from detections are matched to the size of ROIs from the primary  */
      /*     face-detection algorithm, the size of which is used because it tends to capture much of the  */
      /*     face without permitting non-skin pixels. The size matching is implemented by multiplying the */
      /*     size of the ROI by the ratio indicating the systematic size difference between the ROIs  */
      /*     returned from the primary face-detection algorithm and the ROIs returned from the algorithm */
      /*     that corresponds to the ROI. For example, the size ratio of the primary face-detection */
      /*     algorithm to the secondary #1 face-detection algorithm might be .8 for width and .6 for   */
      /*     height. In such a case, the width and height of an ROI returned by the secondary #1    */
      /*     face-detection algorithm would be multiplied by .8 and .6, respectively. A ratio, rather than  */
      /*     a fixed size, is used to permit the size of the ROI to vary based upon other factors, such as  */
      /*     the distance between the face and the camera. As the ROI size of the primary face-detection  */
      /*     algorithm is used as the target size, ROIs from the primary face-detection algorithm are not */
      /*     adjusted here. */
      /*       */
      /*     Hypothetically, the systematic size differences between the primary face-detection algorithm  */
      /*     and other detection algorithms might be known in advance. However, this implementation assumes */
      /*     they are initially unknown and calculates the systematic size differences (the ratios) based  */
      /*     on the ROI sizes it observes. The accuracy of calculating the systematic size differences  */
      /*     may improve as more ROIs are observed; to take advantage of this, the systematic size  */
      /*     differences are recalculated on each call to the function. The accuracy may improve as more   */
      /*     ROIs are observed because a larger quantity of ROIs may reduce the impact of momentary    */
      /*     influences by factors other than the systematic size difference. For example, the calculated  */
      /*     size difference may also be due to the distance between the face and the camera if the  */
      /*     primary face-detection algorithm happened to make more detections when the face was near the  */
      /*     camera whereas other algorithms happened to make detections when the face was distant from the  */
      /*     camera. As a result, the calculation will not accurately reflect only the systematic size */
      /*     difference. As more ROIs are observed, it is anticipated that size differences due to other    */
      /*     factors, such as distance, will cancel out to a certain extent. */
      /*  */
      /*  */
      /*     Copyright */
      /*     --------- */
      /*  */
      /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
      /*     the Responsible AI License (RAIL). */
      /* %%%%% Code generation settings %%%%%% */
      /* Inline function */
      /* Call function as extrinsic */
      /* See note where warning() is used. */
      /* Call function as extrinsic so that stack trace can be displayed */
      /* %%%%% Setup %%%%%% */
      /* Length of ROI block */
      /* %%%%% Take means of ROIs corresponding to detection-algorithm detections %%%%%% */
      /* Return means from detection-algorithm detections */
      /* Also return accumulators for use on subsequent function calls. */
      /* Local function. */
      /* end main function */
      /* ============================================================================================= */
      /* Local functions */
      /* ============================================================================================= */
      /* ============================================================================================= */
      /* DetectionMeans   Take means of ROIs corresponding to detection-algorithm detections. */
      /* Inline function */
      /* %%%%% Take means over a range of frames %%%%%% */
      /* If first call to function or if called within post-processing second-read operations */
      /* Note: the first call to function always occurs during the first-read operations. */
      /* Note: in the pre-processing second-read operations, no new detections will be encountered, so this */
      /* loop does not need to be run. In the post-processing second-read operations, the new detections */
      /* are skin detections from frame 1 until the length of BlockFullLinIdx. */
      if (FirstCallTF || SecondReadPostProcessingTF) {
        VideoReadConfig_FrameIdx_Length = BlockFullLinIdx_SR->
          data[BlockFullLinIdx_SR->size[0] - 1];

        /* Loop across ROI rows */
        for (b_i = 0; b_i < VideoReadConfig_FrameIdx_Length; b_i++) {
          /* %%%%% --- First-call operations %%%%%% */
          /* If called during the first call to the function */
          if (FirstCallTF) {
            /* If detection from primary algorithm */
            if (HasROI_TF->FacePrimary->data[b_i]) {
              /* Cast to floating-point type and accumulate width sum  */
              ROIMatchSizeData->SumW_Pri += (real32_T)ROINoMods->data[b_i +
                ROINoMods->size[0] * 2];

              /* Cast to floating-point type and accumulate height sum  */
              ROIMatchSizeData->SumH_Pri += (real32_T)ROINoMods->data[b_i +
                ROINoMods->size[0] * 3];

              /* Detection count */
              ROIMatchSizeData->AlgN_Pri++;

              /* Mean width from primary algorithm */
              ROIMatchSizeData->ROIMeanWidthPri = ROIMatchSizeData->SumW_Pri /
                ROIMatchSizeData->AlgN_Pri;

              /* Mean height from primary algorithm */
              ROIMatchSizeData->ROIMeanHeightPri = ROIMatchSizeData->SumH_Pri /
                ROIMatchSizeData->AlgN_Pri;
            }

            /* If detection from secondary #1 algorithm */
            if (HasROI_TF->FaceSecondary1->data[b_i]) {
              /* Cast to floating-point type and accumulate width sum */
              ROIMatchSizeData->SumW_Sec1 += (real32_T)ROINoMods->data[b_i +
                ROINoMods->size[0] * 2];

              /* Cast to floating-point type and accumulate height sum */
              ROIMatchSizeData->SumH_Sec1 += (real32_T)ROINoMods->data[b_i +
                ROINoMods->size[0] * 3];

              /* Detection count */
              ROIMatchSizeData->AlgN_Sec1++;

              /* Mean ROI width from secondary #1 algorithm */
              ROIMatchSizeData->ROIMeanWidthSec1 = ROIMatchSizeData->SumW_Sec1 /
                ROIMatchSizeData->AlgN_Sec1;

              /* Mean ROI height from secondary #1 algorithm */
              ROIMatchSizeData->ROIMeanHeightSec1 = ROIMatchSizeData->SumH_Sec1 /
                ROIMatchSizeData->AlgN_Sec1;
            }

            /* If detection from secondary #1 algorithm */
            if (HasROI_TF->FaceSecondary2->data[b_i]) {
              /* Cast to floating-point type and accumulate width sum  */
              ROIMatchSizeData->SumW_Sec2 += (real32_T)ROINoMods->data[b_i +
                ROINoMods->size[0] * 2];

              /* Cast to floating-point type and accumulate height sum */
              ROIMatchSizeData->SumH_Sec2 += (real32_T)ROINoMods->data[b_i +
                ROINoMods->size[0] * 3];

              /* Detection count */
              ROIMatchSizeData->AlgN_Sec2++;

              /* Mean ROI width from secondary #2 algorithm */
              ROIMatchSizeData->ROIMeanWidthSec2 = ROIMatchSizeData->SumW_Sec2 /
                ROIMatchSizeData->AlgN_Sec2;

              /* Mean ROI height from secondary #2 algorithm */
              ROIMatchSizeData->ROIMeanHeightSec2 = ROIMatchSizeData->SumH_Sec2 /
                ROIMatchSizeData->AlgN_Sec2;
            }
          }

          /* %%%%% --- First-call or second-read post-processing operations %%%%%%          */
          if ((FirstCallTF || SecondReadPostProcessingTF) && HasROI_TF->
              Skin->data[b_i]) {
            /* If detection from skin algorithm */
            /* Cast to floating-point type and accumulate width sum  */
            ROIMatchSizeData->SumW_Skin += (real32_T)ROINoMods->data[b_i +
              ROINoMods->size[0] * 2];

            /* Cast to floating-point type and accumulate height sum */
            ROIMatchSizeData->SumH_Skin += (real32_T)ROINoMods->data[b_i +
              ROINoMods->size[0] * 3];

            /* Detection count */
            ROIMatchSizeData->AlgN_Skin++;

            /* Mean ROI width from skin algorithm */
            ROIMatchSizeData->ROIMeanWidthSkin = ROIMatchSizeData->SumW_Skin /
              ROIMatchSizeData->AlgN_Skin;

            /* Mean ROI height from skin algorithm */
            ROIMatchSizeData->ROIMeanHeightSkin = ROIMatchSizeData->SumH_Skin /
              ROIMatchSizeData->AlgN_Skin;
          }
        }

        /* %%%%% Take means by addition of one frame %%%%%%     */
        /* If during the first-read operations (other than the first call to the function) */
      }

      /* %%%%% Assign for use in function ROIMSIR_MatchSize %%%%%% */
      /* end local function */
      /* ============================================================================================= */
      /* Code-generation and build script */
      /* ============================================================================================= */
      /* Note: this function is not currently used as a compiled function as it is nested within a */
      /* compiled function, ROIMSIR_mex. */
      /* Code-generation and build script used to generate C-language code and create the compiled version  */
      /* (ROIMSIR_MatchSize_mex) of the function. */
      /* { */
      /*                  */
      /*  */
      /* %%%%% Specify variable-size input arguments %%%%%% */
      /*  */
      /* See Matlab documentation for coder.typeof. */
      /*  */
      /* Specify struct variable-size element properties */
      /* Element1 = ... */
      /*     coder.typeof(false(500, 1), ... example code */
      /*                  [inf, 1],      ... upper bounds */
      /*                  [1, 0]         ... variable size (T/F) */
      /*     ); */
      /*  */
      /* HasROI_TFCode = ... */
      /*     struct( ... */
      /*         'ByAnyMethod',                      Element1, ...    */
      /*         'FacePrimary',                      Element1, ... */
      /*         'FacePrimaryAttempted',             Element1, ... */
      /*         'FaceSecondary1',                   Element1, ... */
      /*         'FaceSecondary1Attempted',          Element1, ... */
      /*         'FaceSecondary2',                   Element1, ... */
      /*         'FaceSecondary2Attempted',          Element1, ... */
      /*         'Skipped',                          Element1, ... */
      /*         'Skin',                             Element1, ... */
      /*         'SkinAttempted',                    Element1, ... */
      /*         'Interpolated',                     Element1, ... */
      /*         'AdjustedBecauseLowSkinProportion', Element1, ... */
      /*         'ROISpecifiedByArgument',           Element1, ... */
      /*         'ROIIgnoreByArgument',              Element1 ... */
      /*     ); */
      /*  */
      /*                                                      Example Code                 Upp. Bounds  Var. Size (T/F)  Type */
      /* ROINoModsCode                         = coder.typeof( zeros(500, 4, 'int16'),      [inf, 4],    [1, 0] );        %int16 */
      /* ROINoPrevCallsBlockCode               = coder.typeof( zeros(500, 4, 'int16'),      [inf, 4],    [1, 0] );        %int16 */
      /* BlockFullLinIdxCode                   = coder.typeof( zeros(1, 500, 'uint32'),     [1, inf],    [0, 1] );        %int32 */
      /* ROIBlockDetectionSkinLogIdxCode       = coder.typeof( false(500, 1),               [inf, 1],    [1, 0] );        %logical */
      /* ROIBlockDetectionFaceSkinLogIdxCode   = coder.typeof( false(500, 1),               [inf, 1],    [1, 0] );        %logical  */
      /* VideoReadConfig_FrameIdxCode          = coder.typeof( zeros(1, 500, 'uint32'),     [1, inf],    [0, 1] );        %int32  */
      /*                   */
      /*  */
      /* %%%%% Specify fixed-size input arguments %%%%%% */
      /*  */
      /* VidObjWidthCode                          = int16(0);          */
      /* VidObjHeightCode                         = int16(0); */
      /* FirstReadTFCode                          = false; */
      /* SecondReadPostProcessingTFCode           = false; */
      /* RowToReturnFullLinIdxCode                = int32(0); */
      /* FaceDetectConfig_ROIFaceSecondary1TFCode = false; */
      /* FaceDetectConfig_ROIFaceSecondary2TFCode = false; */
      /*  */
      /*  */
      /* %%%%% Set configurations to increase performance %%%%%% */
      /*  */
      /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
      /* "Optimization Strategies" */
      /* cfg = coder.config('mex'); */
      /* cfg.GlobalDataSyncMethod = 'NoSync'; */
      /* cfg.ConstantInputs = 'IgnoreValues'; */
      /* cfg.ExtrinsicCalls = false; */
      /* cfg.SaturateOnIntegerOverflow = false; */
      /* cfg.IntegrityChecks = false; */
      /* cfg.ResponsivenessChecks = false; */
      /*  */
      /*  */
      /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
      /*  */
      /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
      /*  */
      /* The flags are specified as part of the code-generation configuration object. A custom function, */
      /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
      /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
      /* Matlab guidance found in */
      /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
      /*  */
      /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
      /* a character vector prior to execution of the codegen command. */
      /*  */
      /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
      /*  */
      /* Argument buildInfo: this variable is assign by the caller (the codegen command executed  */
      /* below) and is not present in the base workspace. */
      /*  */
      /* Second argument: specify a cell array of compiler-specific flags, where each flag is a  */
      /* character vector. As function setbuildargs will be evaluated from text, use double ' quotes for  */
      /* each character vector to maintain the charater vector, */
      /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
      /*  */
      /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
      /*  */
      /* Assign to code-generation configuration object */
      /* cfg.PostCodeGenCommand = setbuildargsAsText; */
      /*  */
      /*  */
      /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
      /*  */
      /* codegen ROIMSIR_MatchSize.m -config cfg -args {ROINoModsCode, ROINoPrevCallsBlockCode, HasROI_TFCode, ROIBlockDetectionSkinLogIdxCode, ROIBlockDetectionFaceSkinLogIdxCode, BlockFullLinIdxCode, VidObjWidthCode, VidObjHeightCode, FirstReadTFCode, SecondReadPostProcessingTFCode, FaceDetectConfig_ROIFaceSecondary1TFCode, FaceDetectConfig_ROIFaceSecondary2TFCode, VideoReadConfig_FrameIdxCode, RowToReturnFullLinIdxCode} */
      /*               */
      /* } */
      /* %%%%% Size match face-detection ROIs in block to be more similar across face-detection algorithms %%%%%% */
      /* Note: used during the first read or during the second read in the pre-processing (but not   */
      /* post-processing) step. During the second read pre-processing step, size match ROIs near the  */
      /* beginning of the video that were not size matched during the first read. The second read does not  */
      /* use the face-detection algorithm(s), so size matching is not needed during the second read  */
      /* post-processing step.  */
      /*  first read */
      if (!SecondReadPostProcessingTF) {
        /*    second read pre-processing step  */
        /* %%%%% --- Match the size of secondary. #1 alg. ROIs in block to size of primary alg. ROIs %%%%%%    */
        /*  if sec. #1 alg. enabled */
        /*  if any sec. #1 alg. detections in block */
        /*  min sample for better ratio determination */
        if (c_FaceDetectConfig_ROIFaceSecon) {
          i = b_HasROI_TF->size[0];
          b_HasROI_TF->size[0] = BlockFullLinIdx_SR->size[0];
          emxEnsureCapacity_boolean_T(b_HasROI_TF, i);
          Sum = BlockFullLinIdx_SR->size[0];
          for (i = 0; i < Sum; i++) {
            b_HasROI_TF->data[i] = HasROI_TF->FaceSecondary1->
              data[BlockFullLinIdx_SR->data[i] - 1];
          }

          if (any(b_HasROI_TF) && (ROIMatchSizeData->AlgN_Pri > 5.0F) &&
              (ROIMatchSizeData->AlgN_Sec1 > 5.0F)) {
            /*    min sample for better ratio determination        */
            /* Determine size ratio of primary alg. to secondary #1 alg */
            WidthRatio_Single = ROIMatchSizeData->ROIMeanWidthPri /
              ROIMatchSizeData->ROIMeanWidthSec1;
            HeightRatio_Single = ROIMatchSizeData->ROIMeanHeightPri /
              ROIMatchSizeData->ROIMeanHeightSec1;

            /* Logical index of secondary #1 algorithm detections within ROI block */
            /* Loop across elements of ROIs where a detection was made by the secondary #1 algorithm */
            i = BlockFullLinIdx_SR->size[0];
            for (b_i = 0; b_i < i; b_i++) {
              /* Where an ROI corresponds to the detection algorithm */
              if (HasROI_TF->FaceSecondary1->data[BlockFullLinIdx_SR->data[b_i]
                  - 1]) {
                /* Match ROI widths and heights of ROIs from secondary #1 algorithm: */
                /* Extract width and height of ith ROI */
                Width_ith = ROINoPrevCallsBlock_SR->data[b_i +
                  ROINoPrevCallsBlock_SR->size[0] * 2];
                Height_ith = ROINoPrevCallsBlock_SR->data[b_i +
                  ROINoPrevCallsBlock_SR->size[0] * 3];

                /* Adjust size by primary-to-secondary #1 ROI width ratio */
                /* Cast to floating point type during calculation */
                WidthNew_ith = (int16_T)muSingleScalarRound((real32_T)Width_ith *
                  WidthRatio_Single);

                /* Adjust size by primary-to-secondary #1 ROI height ratio */
                /* Cast to floating point type during calculation */
                HeightNew_ith = (int16_T)muSingleScalarRound((real32_T)
                  Height_ith * HeightRatio_Single);

                /* Reassign */
                ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size
                  [0] * 2] = WidthNew_ith;
                ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size
                  [0] * 3] = HeightNew_ith;

                /* Adjust X- and Y-coordinates to correspond to adjustments in widths and heights: */
                /* Half of difference between unmatched widths and height and adjusted widths and  */
                /* heights. */
                /* Optimize division by two by bit-wise operation. */
                /* Add the half-differences to the X- and Y-coordinates */
                /* Note: if there were negative differences, the half-differences will be subtracted  */
                /* from the X- and Y-coordinates. */
                ROINoPrevCallsBlock_SR->data[b_i] = (int16_T)
                  (ROINoPrevCallsBlock_SR->data[b_i] + ((int16_T)(Width_ith -
                     WidthNew_ith) >> 1));
                ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size
                  [0]] = (int16_T)(ROINoPrevCallsBlock_SR->data[b_i +
                                   ROINoPrevCallsBlock_SR->size[0]] + ((int16_T)
                  (Height_ith - HeightNew_ith) >> 1));
              }
            }
          }
        }

        /* %%%%% --- Match the size of secondary. #2 alg. ROIs in block to size of primary alg. ROIs %%%%%%     */
        /*  if sec. #2 alg. enabled */
        /*  if any sec. #2 alg. detections in block */
        /*  min sample for better ratio determination */
        if (d_FaceDetectConfig_ROIFaceSecon) {
          i = b_HasROI_TF->size[0];
          b_HasROI_TF->size[0] = BlockFullLinIdx_SR->size[0];
          emxEnsureCapacity_boolean_T(b_HasROI_TF, i);
          Sum = BlockFullLinIdx_SR->size[0];
          for (i = 0; i < Sum; i++) {
            b_HasROI_TF->data[i] = HasROI_TF->FaceSecondary2->
              data[BlockFullLinIdx_SR->data[i] - 1];
          }

          if (any(b_HasROI_TF) && (ROIMatchSizeData->AlgN_Pri > 5.0F) &&
              (ROIMatchSizeData->AlgN_Sec2 > 5.0F)) {
            /*    min sample for better ratio determination        */
            /* Determine size ratio of primary alg. to secondary #2 alg */
            WidthRatio_Single = ROIMatchSizeData->ROIMeanWidthPri /
              ROIMatchSizeData->ROIMeanWidthSec2;
            HeightRatio_Single = ROIMatchSizeData->ROIMeanHeightPri /
              ROIMatchSizeData->ROIMeanHeightSec2;

            /* Logical index of secondary #2 algorithm detections within ROI block */
            /* Loop across elements of ROIs where a detection was made by the secondary #1 algorithm */
            i = BlockFullLinIdx_SR->size[0];
            for (b_i = 0; b_i < i; b_i++) {
              /* Where an ROI corresponds to the detection algorithm */
              if (HasROI_TF->FaceSecondary2->data[BlockFullLinIdx_SR->data[b_i]
                  - 1]) {
                /* Match ROI widths and heights of ROIs from secondary #2 algorithm: */
                /* Extract width and height of ith ROI */
                Width_ith = ROINoPrevCallsBlock_SR->data[b_i +
                  ROINoPrevCallsBlock_SR->size[0] * 2];
                Height_ith = ROINoPrevCallsBlock_SR->data[b_i +
                  ROINoPrevCallsBlock_SR->size[0] * 3];

                /* Adjust size by primary-to-secondary #2 ROI width ratio */
                /* Cast to floating point type during calculation */
                WidthNew_ith = (int16_T)muSingleScalarRound((real32_T)Width_ith *
                  WidthRatio_Single);

                /* Adjust size by primary-to-secondary #2 ROI height ratio */
                /* Cast to floating point type during calculation */
                HeightNew_ith = (int16_T)muSingleScalarRound((real32_T)
                  Height_ith * HeightRatio_Single);

                /* Reassign */
                ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size
                  [0] * 2] = WidthNew_ith;
                ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size
                  [0] * 3] = HeightNew_ith;

                /* Adjust X- and Y-coordinates to correspond to adjustments in widths and heights: */
                /* Half of difference between unmatched widths and height and adjusted widths and  */
                /* heights. */
                /* Optimize division by two by bit-wise operation. */
                /* Add the half-differences to the X- and Y-coordinates */
                /* Note: if there were negative differences, the half-differences will be subtracted  */
                /* from the X- and Y-coordinates. */
                ROINoPrevCallsBlock_SR->data[b_i] = (int16_T)
                  (ROINoPrevCallsBlock_SR->data[b_i] + ((int16_T)(Width_ith -
                     WidthNew_ith) >> 1));
                ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size
                  [0]] = (int16_T)(ROINoPrevCallsBlock_SR->data[b_i +
                                   ROINoPrevCallsBlock_SR->size[0]] + ((int16_T)
                  (Height_ith - HeightNew_ith) >> 1));
              }
            }
          }
        }
      }

      /* end if output is one row */
      /* %%%%% Match the size of skin-detection ROIs to the size of face-detection ROIs %%%%%% */
      /* Note: used during all calls. */
      /* During the second read pre-processing step, size match ROIs near the beginning of the video */
      /* that were not size matched during the first read. During the second read post-processing step, */
      /* size match ROIs near the beginning of the video based on recent skin-detection algorithm */
      /* ROI detections.  */
      /* If at least one skin-detection algorithm detection within block; no matching needed if no  */
      /* detections within block. */
      /* Also, at least two face-detection algorithm detections from which to make size match. */
      if ((NDetectionsSkin_SR != 0) && ((ROIMatchSizeData->AlgN_Pri > 1.0F) ||
           (ROIMatchSizeData->AlgN_Sec1 > 1.0F) || (ROIMatchSizeData->AlgN_Sec2 >
            1.0F))) {
        /* Use the ROIs from a face-detection algorithm as the basis of ROIs sizes for the ROIs from the */
        /* skin-detection algorithms. Use ROIs only from the primary face-detection algorithm if  */
        /* available. Otherwise, use ROIs only from the secondary #1 face-detection algorithm if  */
        /* available; otherwise, use ROIs from the secondary #2 face-detection algorithm. If ROI not */
        /* available from any face-detection algorithm, skip skin-detection ROI size adjustment. */
        /* Match widths and heights: */
        /* Use primary algorithm mean ROI size as basis for skin-detection ROI size */
        if (ROIMatchSizeData->AlgN_Pri > 1.0F) {
          /* Use primary algorithm as mean face-detection ROI size */
          HeightRatio_Single = ROIMatchSizeData->ROIMeanWidthPri;
          x_after = ROIMatchSizeData->ROIMeanHeightPri;

          /* Use secondary #1 algorithm mean ROI size as basis for skin-detection ROI size */
        } else if (ROIMatchSizeData->AlgN_Sec1 > 1.0F) {
          /* Use secondary #1 algorithm as mean face-detection ROI size */
          HeightRatio_Single = ROIMatchSizeData->ROIMeanWidthSec1;
          x_after = ROIMatchSizeData->ROIMeanHeightSec1;

          /* Use secondary #2 algorithm mean ROI size as basis for skin-detection ROI size */
        } else {
          /* Use secondary #2 algorithm as mean face-detection ROI size */
          HeightRatio_Single = ROIMatchSizeData->ROIMeanWidthSec2;
          x_after = ROIMatchSizeData->ROIMeanHeightSec2;
        }

        /* Determine face-to-skin size ratio  */
        WidthRatio_Single = HeightRatio_Single /
          ROIMatchSizeData->ROIMeanWidthSkin;
        HeightRatio_Single = x_after / ROIMatchSizeData->ROIMeanHeightSkin;

        /* Match ROI size of ROIs from skin-detection algorithm:     */
        /* Loop across elements of ROIs where a detection was made by the skin-detection algorithm */
        for (b_i = 0; b_i < NDetectionsSkin_SR; b_i++) {
          /* Where an ROI corresponds to the detection algorithm */
          /* Match ROI widths and heights of ROIs from skin-detection algorithm: */
          /* Extract width and height of ith ROI */
          Width_ith = ROINoPrevCallsBlock_SR->data
            [(ROIBlockDetectionSkinLinIdx_SR->data[b_i] +
              ROINoPrevCallsBlock_SR->size[0] * 2) - 1];
          Height_ith = ROINoPrevCallsBlock_SR->data
            [(ROIBlockDetectionSkinLinIdx_SR->data[b_i] +
              ROINoPrevCallsBlock_SR->size[0] * 3) - 1];

          /* Adjust size by face-to-skin ROI width ratio */
          /* Cast to floating point type during calculation */
          WidthNew_ith = (int16_T)muSingleScalarRound((real32_T)Width_ith *
            WidthRatio_Single);

          /* Adjust size by face-to-skin ROI height ratio */
          /* Cast to floating point type during calculation */
          HeightNew_ith = (int16_T)muSingleScalarRound((real32_T)Height_ith *
            HeightRatio_Single);

          /* Reassign */
          ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionSkinLinIdx_SR->data[b_i]
            + ROINoPrevCallsBlock_SR->size[0] * 2) - 1] = WidthNew_ith;
          ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionSkinLinIdx_SR->data[b_i]
            + ROINoPrevCallsBlock_SR->size[0] * 3) - 1] = HeightNew_ith;

          /* Adjust X- and Y-coordinates to correspond to adjustments in widths and heights: */
          /* Half of difference between unmatched widths and height and adjusted widths and  */
          /* heights. */
          /* Optimize division by two by bit-wise operation. */
          /* Add the half-differences to the X- and Y-coordinates */
          /* Note: if there were negative differences, the half-differences will be subtracted  */
          /* from the X- and Y-coordinates. */
          ROINoPrevCallsBlock_SR->data[ROIBlockDetectionSkinLinIdx_SR->data[b_i]
            - 1] = (int16_T)(ROINoPrevCallsBlock_SR->
                             data[ROIBlockDetectionSkinLinIdx_SR->data[b_i] - 1]
                             + ((int16_T)(Width_ith - WidthNew_ith) >> 1));
          ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionSkinLinIdx_SR->data[b_i]
            + ROINoPrevCallsBlock_SR->size[0]) - 1] = (int16_T)
            (ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionSkinLinIdx_SR->
              data[b_i] + ROINoPrevCallsBlock_SR->size[0]) - 1] + ((int16_T)
              (Height_ith - HeightNew_ith) >> 1));
        }
      }

      /* %%%%% Adjust ROI(s) that exceed frame dimensions %%%%%%    */
      /* Although ROI(s) are also checked later in function ROIMSIR, check here as well so that any */
      /* overshoots from size matching don't affect the detection-smoothing operations in function  */
      /* ROIMSIR_DetectionSmooth, which occurs before the check by ROIMSIR. Also, before the check by    */
      /* ROIMSIR, ROIs returned here will influence variable ROIOutBeforeFrameByFrameSmoothing_FR or */
      /* ROIOutBeforeFrameByFrameSmoothing_SR (assigned in function ROIMSIR), and this variable needs to be   */
      /* within frame dimensions for later use in function WriteFaceVideo.  */
      /* Adjust any coordinates that exceed frame dimensions */
      /* M x 4 matrix (229 x 4 during first-read operations); type int16. */
      /* Note: ROIAdjustIfExceedsFrameDims is a custom function located within folder 'FacePulseRate'. */
      i = ROIBlockFaceSkin_Temp->size[0] * ROIBlockFaceSkin_Temp->size[1];
      ROIBlockFaceSkin_Temp->size[0] = c_ROIBlockDetectionFaceSkinLinI->size[0];
      ROIBlockFaceSkin_Temp->size[1] = 4;
      emxEnsureCapacity_int16_T(ROIBlockFaceSkin_Temp, i);
      Sum = c_ROIBlockDetectionFaceSkinLinI->size[0];
      for (i = 0; i < Sum; i++) {
        ROIBlockFaceSkin_Temp->data[i] = ROINoPrevCallsBlock_SR->
          data[c_ROIBlockDetectionFaceSkinLinI->data[i] - 1];
      }

      for (i = 0; i < Sum; i++) {
        ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0]] =
          ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->data[i]
          + ROINoPrevCallsBlock_SR->size[0]) - 1];
      }

      for (i = 0; i < Sum; i++) {
        ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 2] =
          ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->data[i]
          + ROINoPrevCallsBlock_SR->size[0] * 2) - 1];
      }

      for (i = 0; i < Sum; i++) {
        ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 3] =
          ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->data[i]
          + ROINoPrevCallsBlock_SR->size[0] * 3) - 1];
      }

      /* ROIAdjustIfExceedsFrameDims   Verify whether proposed widths and heights of ROIs exceed frame  */
      /*                               dimensions and, if so, modify them to conform to frame dimensions. */
      /*                                */
      /*     Helper function to function FacePulseRate. */
      /*     Within function FacePulseRate, called by functions ROIResize, ROIMeans_FirstRead_Extrapolate, */
      /*     SkinDetect_EnlargeROI, ROIMSIR, ROIMSIR_MatchSize, ROIMSIR_DetectionSmooth,   */
      /*     ROIMSIR_Interpolate, and ROIMSIR_FrameByFrameSmooth.    */
      /*  */
      /*  */
      /*     Code Generation */
      /*     --------------- */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /*  */
      /*  */
      /*     Description */
      /*     ----------- */
      /*  */
      /*     This function verifies that ROIs that have had modifications to their sizes are still within */
      /*     the dimensions of the frame. If not, this function adjusts the dimensions (and, consequently,   */
      /*     the spatial coordinates) to conform to the frame dimensions. */
      /*  */
      /*     Note:  */
      /*  */
      /*     Intended only for use with integer types as rounding is not conducted. For modification for  */
      /*     use with floating-point types, rounding would be necessary as ROI values should be integers. */
      /*  */
      /*  */
      /*     Copyright */
      /*     --------- */
      /*  */
      /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
      /*     the Responsible AI License (RAIL). */
      /* %%%%% Validate inputs %%%%%% */
      /* Exit if empty */
      if (c_ROIBlockDetectionFaceSkinLinI->size[0] != 0) {
        /* Validate whether input ROIsProposed is type int16. */
        /* Must be an integer type because no rounding is conducted. */
        /* Should be type int16 because the function is implemented to assign values of this type. */
        /* A non-matching type would be due to an implementation error. */
        /* %%%%% Running in code generation %%%%%% */
        /* When running in code generation, use for-loops. When running in Matlab code, use vectorization. */
        /* code generation running */
        /* Inline function */
        i = c_ROIBlockDetectionFaceSkinLinI->size[0];
        for (b_i = 0; b_i < i; b_i++) {
          /* %%%%% --- Verify, and adjust if necessary, X-coordinates and widths %%%%%% */
          /* Adjust left-side X-coordinate if exceeds frame dimensions: */
          WidthNew_ith = ROIBlockFaceSkin_Temp->data[b_i];
          if (WidthNew_ith < 1) {
            WidthNew_ith = 1;

            /* recent code mod */
            ROIBlockFaceSkin_Temp->data[b_i] = 1;
          } else {
            if (WidthNew_ith > VidObjWidth) {
              WidthNew_ith = VidObjWidth;

              /* recent code mod */
              ROIBlockFaceSkin_Temp->data[b_i] = VidObjWidth;
            }
          }

          /* Adjust right-side X-coordinate if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(WidthNew_ith +
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 2])
                                - 1);
          if (Width_ith > VidObjWidth) {
            Width_ith = VidObjWidth;
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 2]
              = (int16_T)((int16_T)(VidObjWidth - WidthNew_ith) + 1);
          } else {
            if (Width_ith < 1) {
              Width_ith = 1;
              WidthNew_ith = 1;
              ROIBlockFaceSkin_Temp->data[b_i] = 1;
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                2] = 1;
            }
          }

          /* Adjust width if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(Width_ith - WidthNew_ith) + 1);
          if (Width_ith > VidObjWidth) {
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 2]
              = VidObjWidth;
          } else {
            if (Width_ith < 1) {
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                2] = 1;
            }
          }

          /* %%%%% --- Verify, and adjust if necessary, Y-coordinates and heights %%%%%% */
          /* Adjust top-side Y-coordinate if exceeds frame dimensions: */
          Height_ith = ROIBlockFaceSkin_Temp->data[b_i +
            ROIBlockFaceSkin_Temp->size[0]];
          if (Height_ith < 1) {
            Height_ith = 1;

            /* recent code mod */
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0]] =
              1;
          } else {
            if (Height_ith > VidObjHeight) {
              Height_ith = VidObjHeight;

              /* recent code mod */
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0]] =
                VidObjHeight;
            }
          }

          /* Adjust bottom-side Y-coordinate if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(Height_ith +
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 3])
                                - 1);
          if (Width_ith > VidObjHeight) {
            Width_ith = VidObjHeight;
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 3]
              = (int16_T)((int16_T)(VidObjHeight - Height_ith) + 1);
          } else {
            if (Width_ith < 1) {
              Width_ith = 1;
              Height_ith = 1;
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0]] =
                1;
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                3] = 1;
            }
          }

          /* Adjust height value if exceeds frame dimensions: */
          HeightNew_ith = (int16_T)((int16_T)(Width_ith - Height_ith) + 1);
          if (HeightNew_ith > VidObjHeight) {
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 3]
              = VidObjHeight;
          } else {
            if (HeightNew_ith < 1) {
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                3] = 1;
            }
          }
        }

        /* %%%%% Code generation not running %%%%%% */
      } else {
        /* Exit function */
      }

      /* end function */
      /* ============================================================================================= */
      /* Code-generation and build script */
      /* ============================================================================================= */
      /* Code-generation and build script used to generate C-language code and create the compiled version  */
      /* (ROIAdjustIfExceedsFrameDims_mex) of the function. */
      /* { */
      /*  */
      /* %%%%% Specify variable-size input arguments %%%%%% */
      /*  */
      /* See Matlab documentation for coder.typeof. */
      /*  */
      /*                                   Example Code               Upp. Bounds   Var. Size (T/F)  Type */
      /* ROIsProposedCode   = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],     [1, 0] );        %int16 */
      /*            */
      /*        */
      /* %%%%% Specify fixed-size input arguments %%%%%% */
      /*  */
      /* VidObjWidthCode  = int16(0);          */
      /* VidObjHeightCode = int16(0); */
      /*                    */
      /*  */
      /* %%%%% Set configurations to increase performance %%%%%% */
      /*  */
      /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
      /* "Optimization Strategies" */
      /*  */
      /* cfg = coder.config('mex'); */
      /* cfg.GlobalDataSyncMethod = 'NoSync'; */
      /* cfg.ConstantInputs = 'IgnoreValues'; */
      /* cfg.ExtrinsicCalls = true; %permit to show assert error */
      /* cfg.SaturateOnIntegerOverflow = false; */
      /* cfg.IntegrityChecks = false; */
      /* cfg.ResponsivenessChecks = false; */
      /*  */
      /*  */
      /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
      /*  */
      /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
      /*  */
      /* The flags are specified as part of the code-generation configuration object. A custom function, */
      /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
      /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
      /* Matlab guidance found in */
      /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
      /*  */
      /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
      /* a character vector prior to execution of the codegen command. */
      /*  */
      /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
      /*  */
      /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
      /* is not present in the base workspace. */
      /*  */
      /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
      /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
      /* character vector to maintain the charater vector, */
      /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
      /*  */
      /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
      /*  */
      /* Assign to code-generation configuration object */
      /* cfg.PostCodeGenCommand = setbuildargsAsText; */
      /*  */
      /*  */
      /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
      /*  */
      /* codegen ROIAdjustIfExceedsFrameDims.m -report -config cfg -args {ROIsProposedCode, VidObjWidthCode, VidObjHeightCode} */
      /*                  */
      /* } */
      Sum = ROIBlockFaceSkin_Temp->size[0];
      for (i = 0; i < Sum; i++) {
        ROINoPrevCallsBlock_SR->data[c_ROIBlockDetectionFaceSkinLinI->data[i] -
          1] = ROIBlockFaceSkin_Temp->data[i];
      }

      for (i = 0; i < Sum; i++) {
        ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->data[i] +
          ROINoPrevCallsBlock_SR->size[0]) - 1] = ROIBlockFaceSkin_Temp->data[i
          + ROIBlockFaceSkin_Temp->size[0]];
      }

      for (i = 0; i < Sum; i++) {
        ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->data[i] +
          ROINoPrevCallsBlock_SR->size[0] * 2) - 1] =
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 2];
      }

      for (i = 0; i < Sum; i++) {
        ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->data[i] +
          ROINoPrevCallsBlock_SR->size[0] * 3) - 1] =
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 3];
      }

      /* %%%%% Output validation %%%%%% */
      /* First-read operations */
      /* Check whether any ROI value is zero */
      /* The operations of this function were intended to prevent values of zero, so such a value is */
      /* likely due to an implementation error in this function.  */
      /* Loop across columns */
      /* Loop across ROIs rows that correspond to ROIs modified in the current function */
      for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
        if (ROINoPrevCallsBlock_SR->data[c_ROIBlockDetectionFaceSkinLinI->data[j]
            - 1] == 0) {
          /* Throw exception */
          /* Called as extrinsic so that stack trace can be displayed. */
          /* Note: '%.0f' = floating point with no decimals. */
          error(emlrt_marshallOut(cv3), e_emlrt_marshallOut(cv9), &h_emlrtMCI);
        }
      }

      /* Loop across ROIs rows that correspond to ROIs modified in the current function */
      for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
        if (ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->
             data[j] + ROINoPrevCallsBlock_SR->size[0]) - 1] == 0) {
          /* Throw exception */
          /* Called as extrinsic so that stack trace can be displayed. */
          /* Note: '%.0f' = floating point with no decimals. */
          error(emlrt_marshallOut(cv3), e_emlrt_marshallOut(cv9), &h_emlrtMCI);
        }
      }

      /* Loop across ROIs rows that correspond to ROIs modified in the current function */
      for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
        if (ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->
             data[j] + ROINoPrevCallsBlock_SR->size[0] * 2) - 1] == 0) {
          /* Throw exception */
          /* Called as extrinsic so that stack trace can be displayed. */
          /* Note: '%.0f' = floating point with no decimals. */
          error(emlrt_marshallOut(cv3), e_emlrt_marshallOut(cv9), &h_emlrtMCI);
        }
      }

      /* Loop across ROIs rows that correspond to ROIs modified in the current function */
      for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
        if (ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->
             data[j] + ROINoPrevCallsBlock_SR->size[0] * 3) - 1] == 0) {
          /* Throw exception */
          /* Called as extrinsic so that stack trace can be displayed. */
          /* Note: '%.0f' = floating point with no decimals. */
          error(emlrt_marshallOut(cv3), e_emlrt_marshallOut(cv9), &h_emlrtMCI);
        }
      }

      /* Check whether the ROI size is unreasonably small */
      /* Such a small size is likely due to an implementation error in this function. */
      /* This check is intended to be run when testing new implementations, as small ROI sizes are an */
      /* indication of a implementation error. As occassional values below 20 may be considered */
      /* acceptable, this check is not intended for use outside of testing. "Occassional" in this case    */
      /* might be defined as a few occurances out of 10,000. Flag ExpectedBehaviorTestTF enables the */
      /* check.     */
      if (ExpectedBehaviorTestTF) {
        i = x->size[0] * x->size[1];
        x->size[0] = c_ROIBlockDetectionFaceSkinLinI->size[0];
        x->size[1] = 2;
        emxEnsureCapacity_boolean_T(x, i);
        Sum = c_ROIBlockDetectionFaceSkinLinI->size[0];
        for (i = 0; i < Sum; i++) {
          x->data[i] = (ROINoPrevCallsBlock_SR->data
                        [(c_ROIBlockDetectionFaceSkinLinI->data[i] +
                          ROINoPrevCallsBlock_SR->size[0] * 2) - 1] < 20);
        }

        for (i = 0; i < Sum; i++) {
          x->data[i + x->size[0]] = (ROINoPrevCallsBlock_SR->data
            [(c_ROIBlockDetectionFaceSkinLinI->data[i] +
              ROINoPrevCallsBlock_SR->size[0] * 3) - 1] < 20);
        }

        winNew = x->size[0] << 1;
        c_x = *x;
        b_VideoReadConfig_FrameIdx_FR[0] = winNew;
        c_x.size = &b_VideoReadConfig_FrameIdx_FR[0];
        c_x.numDimensions = 1;
        if (any(&c_x)) {
          /* Display warning */
          /* Note: function warning() not available for code generation, so it must have previously */
          /* been declared as extrinsic. */
          warning(emlrt_marshallOut(cv3), f_emlrt_marshallOut(cv14), &i_emlrtMCI);
        }
      }
    }

    /*  %%%%%%%%%%%%%%%%%%%%%%%%%%%% */
    /* %% ROI-detection smoothing %%% */
    /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
    /* Smooth ROIs that correspond to face-detection and skin-detection algorithm detections to help   */
    /* remove the effect of false positives and to add stability. False positives may be reduced because    */
    /* they sometimes occur as outliers, and smoothing should reduce the effect of outliers. Increasing    */
    /* stability across ROIs may help keep the ROI more oriented on the same area of the face, which may   */
    /* help increase accuracy of pulse rate calculations. Smooth with a moving mean.  */
    /* In addition to smoothing the ROI matrix, also assign a new matrix where only ROIs that correspond */
    /* to detections are included (NoPrevCallsBlock_ROIDetections_FR). */
    /* Note: ROIMSIR_DetectionSmooth is a custom function located within folder 'FacePulseRate'. */
    /* First-read operations */
    if (FirstReadTF) {
      /*  229 x 4 matrix; type int16 */
      /*  N detections (:229) x 4 matrix; type int16 */
      /* ROIMSIR_DetectionSmooth   Smooth ROIs that correspond to face-detection and skin-detection     */
      /*                           algorithm detections to help remove the effect of false positives and to  */
      /*                           add stability.  */
      /*  */
      /*     Helper function to function FacePulseRate.  */
      /*     Within function FacePulseRate, called by function ROIMSIR. */
      /*  */
      /*  */
      /*     Code Generation */
      /*     --------------- */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /*  */
      /*  */
      /*     Description */
      /*     ----------- */
      /*  */
      /*     Smooth ROIs that correspond to face-detection and skin-detection algorithm detections to help   */
      /*     remove the effect of false positives and to add stability. False positives may be reduced    */
      /*     because they sometimes occur as outliers, and smoothing should reduce the effect of outliers.    */
      /*     Increasing stability across ROIs may help keep the ROI more oriented on the same area of the   */
      /*     face, which may help increase accuracy of pulse rate calculations. Smooth with a moving mean. */
      /*  */
      /*     The face-detection algorithm ROIs have been observed to be, on average, more accurate than the */
      /*     skin-detection algorithm ROIs, so the smoothing operations have been ordered to increase the  */
      /*     influence of face-detection ROIs. Specifically, the face-detection ROIs will be smoothed first */
      /*     without including skin-detection ROIs; this removes the influence of skin-detection ROIs on  */
      /*     the face-detection ROIs. Second, the skin-detection ROIs are smoothed with the face-detection  */
      /*     ROIs included so that the face-detection ROIs can influence the skin-detection ROIs. Any  */
      /*     face-detection ROIs smoothed in the second operation are not retained to remove the influence  */
      /*     of skin-detection ROIs on face-detection ROIs. */
      /*  */
      /*     All smoothing follows the following pattern: */
      /*  */
      /*     (1) A moving mean is used to smooth the height and width of each ROI. */
      /*     (2) The X- and Y-coordinates of each ROI are adjusted to correspond to the previous changes to   */
      /*         the height and width. */
      /*     (3) A moving mean is used to smooth the X- and Y-coordinates of each ROI. */
      /*  */
      /*  */
      /*     Copyright */
      /*     --------- */
      /*  */
      /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
      /*     the Responsible AI License (RAIL). */
      /* %%%%% Code generation settings %%%%%% */
      /* Inline function */
      /* Call function as extrinsic */
      /* See note where warning() is used. */
      /* Call function as extrinsic so that stack trace can be displayed */
      /* %%%%% Preallocate variables %%%%%% */
      d_NoPrevCallsBlock_ROIDetection = NDetectionsFaceSkin_FR;

      /* %%%%% Face-detection algorithm detection smoothing %%%%%% */
      /* Note: used during the first read or during the second read in the pre-processing (but not   */
      /* post-processing) step. */
      /* During the second read pre-processing step, size match ROIs near the beginning of the video that */
      /* were not size matched during the first read. The second read does not use the face-detection */
      /* algorithm, so size matching is not needed during the second read post-processing step. */
      /* Note: during the first read, calls by function ROIMeans_FirstRead; during the second read, calls  */
      /* by function ROIMeans_SecondRead.    */
      /*  first read */
      /*    second read pre-processing step  */
      /* If more than one face-detection algorithm detection within block */
      /* No need to smooth if one or zero detections. */
      if (NDetectionsFace_FR > 1) {
        /* %%%%% --- Moving-mean smoothing on X- and Y-coordinates %%%%%%         */
        /* Smooth face-detection algorithm ROI X- and Y-coordinates with those of other  */
        /* face-detection algorithm ROIs. */
        /* The moving-mean smoothing window is specified by argument ROIFaceSmoothingWindow to */
        /* function FacePulseRate.  */
        /* M x 4 matrix; type int16. */
        /* Note: MovMean is a custom function located within folder 'FacePulseRate'. */
        /*  Smoothing window */
        /*  The number or rows of the input matrix */
        /*  The number or columns of the input */
        /*  matrix. */
        for (i = 0; i < FrameByFrameSmoothingWin_WHHalf; i++) {
          ROIBlockDetectionSkinLinIdx[i] = (uint8_T)
            (c_ROIBlockDetectionFaceLinIdx_F[i] - 1U);
        }

        /* MovMean   Moving mean column-wise smoother. */
        /*  */
        /*     Helper function to function FacePulseRate.  */
        /*     Within function FacePulseRate, called by functions ROIMSIR_DetectionSmooth and */
        /*     ROIMSIR_FrameByFrameSmooth. */
        /*  */
        /*     Code generation:  */
        /*  */
        /*     Can be called as a Matlab function or used for C-language code generation. */
        /*  */
        /*     Description: */
        /*  */
        /*     Use a moving mean to conduct column-wise smoothing to a matrix. Weight rows corresponding to */
        /*     linear index WeightLinIdx by weight Weight. */
        /*  */
        /*     Inputs: */
        /*  */
        /*         ROI          = Matrix of values to be smoothed. M x :4 matrix; type int16.  */
        /*         Win          = Moving-mean window. Scalar; type double. */
        /*         NRowsROI     = The number of rows of the input matrix. Scalar; int32. */
        /*         NColsROI     = The number of columns of the input matrix. Scalar; int32. */
        /*  */
        /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
        /*     the Responsible AI License (RAIL). */
        /* Inline function */
        /* %%%%% Setup %%%%%% */
        /* Take half of window for use during operations */
        Idx = (int32_T)muDoubleScalarFloor(c_FaceDetectConfig_ROIFaceSmoot / 2.0)
          + 1;

        /* Make the full window equal twice the value of the half-window:  */
        winNew = ((Idx - 1) << 1) + 1;

        /* Assert maximum number of columns to prevent dynamic memory allocation by the colon operator */
        /* Preallocate output */
        i = SmoothedXYColumn->size[0] * SmoothedXYColumn->size[1];
        SmoothedXYColumn->size[0] = NDetectionsFace_FR;
        SmoothedXYColumn->size[1] = 2;
        emxEnsureCapacity_int16_T(SmoothedXYColumn, i);

        /* %%%%% Reduce size of window if window cannot move %%%%%% */
        if (NDetectionsFace_FR <= winNew) {
          /* Take one-fourth of window rather than one-half for use during operations */
          Idx = (int32_T)muDoubleScalarFloor(c_FaceDetectConfig_ROIFaceSmoot /
            4.0) + 1;

          /* Make the full window equal twice the value of the half-window:  */
          winNew = ((Idx - 1) << 1) + 1;
        }

        /* %%%%% If window still cannot move %%%%%% */
        if (NDetectionsFace_FR <= winNew) {
          /* Loop across columns */
          /* Initialize accumulator */
          Sum = 0;

          /* Sum rows across window           */
          for (j = 0; j < NDetectionsFace_FR; j++) {
            /* Element cast to type int32. */
            Sum += ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[j] - 1];
          }

          /* Take the mean */
          if (Sum >= 0) {
            d_x = (uint32_T)Sum;
          } else if (Sum == MIN_int32_T) {
            d_x = 2147483648U;
          } else {
            d_x = (uint32_T)-Sum;
          }

          q = d_x / NDetectionsFace_FR;
          d_x -= q * NDetectionsFace_FR;
          if ((d_x > 0U) && (d_x >= ((uint32_T)NDetectionsFace_FR >> 1U) +
                             (NDetectionsFace_FR & 1U))) {
            q++;
          }

          Idx = (int32_T)q;
          if (Sum < 0) {
            Idx = -(int32_T)q;
          }

          /* Assign the mean to all rows of column i */
          /* Initialize accumulator */
          Sum = 0;

          /* Sum rows across window           */
          for (j = 0; j < NDetectionsFace_FR; j++) {
            SmoothedXYColumn->data[j] = (int16_T)Idx;

            /* Element cast to type int32. */
            Sum += ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[j] +
              228];
          }

          /* Take the mean */
          if (Sum >= 0) {
            d_x = (uint32_T)Sum;
          } else if (Sum == MIN_int32_T) {
            d_x = 2147483648U;
          } else {
            d_x = (uint32_T)-Sum;
          }

          q = d_x / NDetectionsFace_FR;
          d_x -= q * NDetectionsFace_FR;
          if ((d_x > 0U) && (d_x >= ((uint32_T)NDetectionsFace_FR >> 1U) +
                             (NDetectionsFace_FR & 1U))) {
            q++;
          }

          Idx = (int32_T)q;
          if (Sum < 0) {
            Idx = -(int32_T)q;
          }

          /* Assign the mean to all rows of column i */
          for (j = 0; j < NDetectionsFace_FR; j++) {
            SmoothedXYColumn->data[j + SmoothedXYColumn->size[0]] = (int16_T)Idx;
          }

          /* %%%%% If window can move %%%%%%     */
        } else {
          /* Loop across columns */
          i = Idx + 1;
          i1 = NDetectionsFace_FR - Idx;
          b_i = i1 + 2;

          /* Initialize */
          Sum = 0;

          /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
          /* Set intial window end index */
          /* Sum across truncated window           */
          for (j = 0; j < Idx; j++) {
            /* Cast to type int32 and add */
            Sum += ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[j] - 1];
          }

          /* Take mean */
          if (Idx == 0) {
            if (Sum == 0) {
              z = 0;
            } else if (Sum < 0) {
              z = MIN_int32_T;
            } else {
              z = MAX_int32_T;
            }
          } else if (Idx == 1) {
            z = Sum;
          } else if (Idx == -1) {
            z = -Sum;
          } else {
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            if (Idx >= 0) {
              b_y = (uint32_T)Idx;
            } else if (Idx == MIN_int32_T) {
              b_y = 2147483648U;
            } else {
              b_y = (uint32_T)-Idx;
            }

            if (b_y == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / b_y;
            }

            d_x -= q * b_y;
            if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
              q++;
            }

            z = (int32_T)q;
            if ((Sum < 0) != (Idx < 0)) {
              z = -(int32_T)q;
            }
          }

          SmoothedXYColumn->data[0] = (int16_T)z;

          /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
          /* Set initial truncated window length */
          n = Idx;

          /* Loop across rows */
          for (j = 2; j <= Idx; j++) {
            /* Set window end index for jth row */
            /* Add value at end of current window */
            /* Element cast to type int32. */
            Sum += ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[(j +
              Idx) - 2] - 1];

            /* Take mean:                 */
            n++;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
          /* Loop across rows */
          for (j = i; j <= i1 + 1; j++) {
            /* Set window start index for jth row */
            Start = (j - Idx) + 1;

            /* Set window end index for jth row */
            /* Subtract value at start of previous window.  */
            /* Then, add value at end of current window. */
            /* Element cast to type int32. */
            Sum = (Sum -
                   ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[Start
                   - 2] - 1]) +
              ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[(j + Idx) -
              2] - 1];

            /* Take mean */
            if (winNew == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (winNew == 1) {
              z = Sum;
            } else if (winNew == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (winNew >= 0) {
                b_y = (uint32_T)winNew;
              } else if (winNew == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-winNew;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (winNew < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
          /* Set intial window length */
          n = winNew;
          Start -= 2;
          for (j = b_i; j <= NDetectionsFace_FR; j++) {
            Start++;

            /* Subtract value at start of previous window */
            /* Element cast to type int32. */
            Sum -= ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[Start
              - 1] - 1];

            /* Take mean:        */
            n--;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* Initialize */
          Sum = 0;

          /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
          /* Set intial window end index */
          /* Sum across truncated window           */
          for (j = 0; j < Idx; j++) {
            /* Cast to type int32 and add */
            Sum += ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[j] +
              228];
          }

          /* Take mean */
          if (Idx == 0) {
            if (Sum == 0) {
              z = 0;
            } else if (Sum < 0) {
              z = MIN_int32_T;
            } else {
              z = MAX_int32_T;
            }
          } else if (Idx == 1) {
            z = Sum;
          } else if (Idx == -1) {
            z = -Sum;
          } else {
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            if (Idx >= 0) {
              b_y = (uint32_T)Idx;
            } else if (Idx == MIN_int32_T) {
              b_y = 2147483648U;
            } else {
              b_y = (uint32_T)-Idx;
            }

            if (b_y == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / b_y;
            }

            d_x -= q * b_y;
            if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
              q++;
            }

            z = (int32_T)q;
            if ((Sum < 0) != (Idx < 0)) {
              z = -(int32_T)q;
            }
          }

          SmoothedXYColumn->data[SmoothedXYColumn->size[0]] = (int16_T)z;

          /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
          /* Set initial truncated window length */
          n = Idx;

          /* Loop across rows */
          for (j = 2; j <= Idx; j++) {
            /* Set window end index for jth row */
            /* Add value at end of current window */
            /* Element cast to type int32. */
            Sum += ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[(j +
              Idx) - 2] + 228];

            /* Take mean:                 */
            n++;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
          /* Loop across rows */
          for (j = i; j <= i1 + 1; j++) {
            /* Set window start index for jth row */
            Start = (j - Idx) + 1;

            /* Set window end index for jth row */
            /* Subtract value at start of previous window.  */
            /* Then, add value at end of current window. */
            /* Element cast to type int32. */
            Sum = (Sum -
                   ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[Start
                   - 2] + 228]) +
              ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[(j + Idx) -
              2] + 228];

            /* Take mean */
            if (winNew == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (winNew == 1) {
              z = Sum;
            } else if (winNew == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (winNew >= 0) {
                b_y = (uint32_T)winNew;
              } else if (winNew == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-winNew;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (winNew < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
          /* Set intial window length */
          n = winNew;
          Start -= 2;
          for (j = b_i; j <= NDetectionsFace_FR; j++) {
            Start++;

            /* Subtract value at start of previous window */
            /* Element cast to type int32. */
            Sum -= ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[Start
              - 1] + 228];

            /* Take mean:        */
            n--;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }
        }

        /* end function */
        /* ============================================================================================= */
        /* Code-generation and build script */
        /* ============================================================================================= */
        /* Code-generation and build script used to generate C-language code and create the compiled version  */
        /* (MovMean_mex) of the function. */
        /* { */
        /*  */
        /* %%%%% Specify variable-size input arguments %%%%%% */
        /*  */
        /* See Matlab documentation for coder.typeof. */
        /*                         Example Code               Upp. Bounds   Var. Size (T/F)  Type */
        /* ROICode  = coder.typeof( zeros(50, 2, 'int16'),     [500, 2],      [1, 0] );        %int16 */
        /*  */
        /*  */
        /* %%%%% Specify fixed-size input arguments %%%%%% */
        /*  */
        /* winCode = double(0); */
        /* NRowsROI = int32(0); */
        /* NColsROI = int32(0);          */
        /*     */
        /* %%%%% Set configurations to increase performance %%%%%% */
        /*  */
        /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
        /* "Optimization Strategies" */
        /* cfg = coder.config('mex'); */
        /* cfg.GlobalDataSyncMethod = 'NoSync'; */
        /* cfg.ConstantInputs = 'IgnoreValues'; */
        /* cfg.ExtrinsicCalls = false; */
        /* cfg.SaturateOnIntegerOverflow = false; */
        /* cfg.IntegrityChecks = false; */
        /* cfg.ResponsivenessChecks = false; */
        /*  */
        /*  */
        /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
        /*  */
        /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
        /*  */
        /* The flags are specified as part of the code-generation configuration object. A custom function, */
        /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
        /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
        /* Matlab guidance found in */
        /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
        /*  */
        /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
        /* a character vector prior to execution of the codegen command. */
        /*  */
        /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
        /*  */
        /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
        /* is not present in the base workspace. */
        /*  */
        /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
        /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each  */
        /* character vector to maintain the charater vector, */
        /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
        /*  */
        /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
        /*  */
        /* Assign to code-generation configuration object */
        /* cfg.PostCodeGenCommand = setbuildargsAsText; */
        /*  */
        /*  */
        /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
        /*  */
        /* codegen MovMean.m -report -config cfg -args {ROICode, winCode, NRowsROI, NColsROI} */
        /*   */
        /* } */
        /* %%%%% --- Moving-mean smoothing on widths and heights %%%%%% */
        /* Assign unsmoothed widths and heights for later step */
        /* Only extract ROIs corresponding to a face-detection algorithm detection. */
        /* N detections x 2 matrix; type int16.               */
        Sum = SmoothedXYColumn->size[0];
        for (i = 0; i < Sum; i++) {
          ROINoPrevCallsBlock_FR[ROIBlockDetectionSkinLinIdx[i]] =
            SmoothedXYColumn->data[i];
        }

        for (i = 0; i < FrameByFrameSmoothingWin_WHHalf; i++) {
          ROIWidthHeightPreSmooth_data[i] =
            ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[i] + 457];
        }

        for (i = 0; i < Sum; i++) {
          ROINoPrevCallsBlock_FR[ROIBlockDetectionSkinLinIdx[i] + 229] =
            SmoothedXYColumn->data[i + SmoothedXYColumn->size[0]];
        }

        for (i = 0; i < FrameByFrameSmoothingWin_WHHalf; i++) {
          ROIWidthHeightPreSmooth_data[i + FrameByFrameSmoothingWin_WHHalf] =
            ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[i] + 686];
        }

        /* Smooth face-detection algorithm ROI widths and heights with those of other face-detection  */
        /* algorithm ROIs. */
        /* The moving-mean smoothing window is relatively large to increase stability of ROI size */
        /* across frames. */
        /* M x 4 matrix; type int16. */
        /* Note: MovMean is a custom function located within folder 'FacePulseRate'. */
        /*  smoothing window */
        /*  the number or rows of the input matrix */
        /*  the number or columns of the input matrix */
        /* MovMean   Moving mean column-wise smoother. */
        /*  */
        /*     Helper function to function FacePulseRate.  */
        /*     Within function FacePulseRate, called by functions ROIMSIR_DetectionSmooth and */
        /*     ROIMSIR_FrameByFrameSmooth. */
        /*  */
        /*     Code generation:  */
        /*  */
        /*     Can be called as a Matlab function or used for C-language code generation. */
        /*  */
        /*     Description: */
        /*  */
        /*     Use a moving mean to conduct column-wise smoothing to a matrix. Weight rows corresponding to */
        /*     linear index WeightLinIdx by weight Weight. */
        /*  */
        /*     Inputs: */
        /*  */
        /*         ROI          = Matrix of values to be smoothed. M x :4 matrix; type int16.  */
        /*         Win          = Moving-mean window. Scalar; type double. */
        /*         NRowsROI     = The number of rows of the input matrix. Scalar; int32. */
        /*         NColsROI     = The number of columns of the input matrix. Scalar; int32. */
        /*  */
        /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
        /*     the Responsible AI License (RAIL). */
        /* Inline function */
        /* %%%%% Setup %%%%%% */
        /* Take half of window for use during operations */
        Idx = 16;

        /* Make the full window equal twice the value of the half-window:  */
        winNew = 31;

        /* Assert maximum number of columns to prevent dynamic memory allocation by the colon operator */
        /* Preallocate output */
        i = SmoothedXYColumn->size[0] * SmoothedXYColumn->size[1];
        SmoothedXYColumn->size[0] = NDetectionsFace_FR;
        SmoothedXYColumn->size[1] = 2;
        emxEnsureCapacity_int16_T(SmoothedXYColumn, i);

        /* %%%%% Reduce size of window if window cannot move %%%%%% */
        if (NDetectionsFace_FR <= 31) {
          /* Take one-fourth of window rather than one-half for use during operations */
          Idx = 8;

          /* Make the full window equal twice the value of the half-window:  */
          winNew = 15;
        }

        /* %%%%% If window still cannot move %%%%%% */
        if (NDetectionsFace_FR <= winNew) {
          /* Loop across columns */
          /* Initialize accumulator */
          Sum = 0;

          /* Sum rows across window           */
          for (j = 0; j < NDetectionsFace_FR; j++) {
            /* Element cast to type int32. */
            Sum += ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[j] +
              457];
          }

          /* Take the mean */
          if (Sum >= 0) {
            d_x = (uint32_T)Sum;
          } else if (Sum == MIN_int32_T) {
            d_x = 2147483648U;
          } else {
            d_x = (uint32_T)-Sum;
          }

          q = d_x / NDetectionsFace_FR;
          d_x -= q * NDetectionsFace_FR;
          if ((d_x > 0U) && (d_x >= ((uint32_T)NDetectionsFace_FR >> 1U) +
                             (NDetectionsFace_FR & 1U))) {
            q++;
          }

          Idx = (int32_T)q;
          if (Sum < 0) {
            Idx = -(int32_T)q;
          }

          /* Assign the mean to all rows of column i */
          /* Initialize accumulator */
          Sum = 0;

          /* Sum rows across window           */
          for (j = 0; j < NDetectionsFace_FR; j++) {
            SmoothedXYColumn->data[j] = (int16_T)Idx;

            /* Element cast to type int32. */
            Sum += ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[j] +
              686];
          }

          /* Take the mean */
          if (Sum >= 0) {
            d_x = (uint32_T)Sum;
          } else if (Sum == MIN_int32_T) {
            d_x = 2147483648U;
          } else {
            d_x = (uint32_T)-Sum;
          }

          q = d_x / NDetectionsFace_FR;
          d_x -= q * NDetectionsFace_FR;
          if ((d_x > 0U) && (d_x >= ((uint32_T)NDetectionsFace_FR >> 1U) +
                             (NDetectionsFace_FR & 1U))) {
            q++;
          }

          Idx = (int32_T)q;
          if (Sum < 0) {
            Idx = -(int32_T)q;
          }

          /* Assign the mean to all rows of column i */
          for (j = 0; j < NDetectionsFace_FR; j++) {
            SmoothedXYColumn->data[j + SmoothedXYColumn->size[0]] = (int16_T)Idx;
          }

          /* %%%%% If window can move %%%%%%     */
        } else {
          /* Loop across columns */
          i = Idx + 1;
          i1 = NDetectionsFace_FR - Idx;
          b_i = i1 + 2;

          /* Initialize */
          Sum = 0;

          /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
          /* Set intial window end index */
          /* Sum across truncated window           */
          for (j = 0; j < Idx; j++) {
            /* Cast to type int32 and add */
            Sum += ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[j] +
              457];
          }

          /* Take mean */
          if (Sum >= 0) {
            d_x = (uint32_T)Sum;
          } else if (Sum == MIN_int32_T) {
            d_x = 2147483648U;
          } else {
            d_x = (uint32_T)-Sum;
          }

          q = d_x / Idx;
          d_x -= q * Idx;
          if ((d_x > 0U) && (d_x >= ((uint32_T)Idx >> 1U) + (Idx & 1U))) {
            q++;
          }

          z = (int32_T)q;
          if (Sum < 0) {
            z = -(int32_T)q;
          }

          SmoothedXYColumn->data[0] = (int16_T)z;

          /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
          /* Set initial truncated window length */
          n = Idx;

          /* Loop across rows */
          for (j = 2; j <= Idx; j++) {
            /* Set window end index for jth row */
            /* Add value at end of current window */
            /* Element cast to type int32. */
            Sum += ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[(j +
              Idx) - 2] + 457];

            /* Take mean:                 */
            n++;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
          /* Loop across rows */
          for (j = i; j <= i1 + 1; j++) {
            /* Set window start index for jth row */
            Start = (j - Idx) + 1;

            /* Set window end index for jth row */
            /* Subtract value at start of previous window.  */
            /* Then, add value at end of current window. */
            /* Element cast to type int32. */
            Sum = (Sum -
                   ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[Start
                   - 2] + 457]) +
              ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[(j + Idx) -
              2] + 457];

            /* Take mean */
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            q = d_x / winNew;
            d_x -= q * winNew;
            if ((d_x > 0U) && (d_x >= ((uint32_T)winNew >> 1U) + (winNew & 1U)))
            {
              q++;
            }

            z = (int32_T)q;
            if (Sum < 0) {
              z = -(int32_T)q;
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
          /* Set intial window length */
          n = winNew;
          Start -= 2;
          for (j = b_i; j <= NDetectionsFace_FR; j++) {
            Start++;

            /* Subtract value at start of previous window */
            /* Element cast to type int32. */
            Sum -= ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[Start
              - 1] + 457];

            /* Take mean:        */
            n--;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* Initialize */
          Sum = 0;

          /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
          /* Set intial window end index */
          /* Sum across truncated window           */
          for (j = 0; j < Idx; j++) {
            /* Cast to type int32 and add */
            Sum += ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[j] +
              686];
          }

          /* Take mean */
          if (Sum >= 0) {
            d_x = (uint32_T)Sum;
          } else if (Sum == MIN_int32_T) {
            d_x = 2147483648U;
          } else {
            d_x = (uint32_T)-Sum;
          }

          q = d_x / Idx;
          d_x -= q * Idx;
          if ((d_x > 0U) && (d_x >= ((uint32_T)Idx >> 1U) + (Idx & 1U))) {
            q++;
          }

          z = (int32_T)q;
          if (Sum < 0) {
            z = -(int32_T)q;
          }

          SmoothedXYColumn->data[SmoothedXYColumn->size[0]] = (int16_T)z;

          /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
          /* Set initial truncated window length */
          n = Idx;

          /* Loop across rows */
          for (j = 2; j <= Idx; j++) {
            /* Set window end index for jth row */
            /* Add value at end of current window */
            /* Element cast to type int32. */
            Sum += ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[(j +
              Idx) - 2] + 686];

            /* Take mean:                 */
            n++;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
          /* Loop across rows */
          for (j = i; j <= i1 + 1; j++) {
            /* Set window start index for jth row */
            Start = (j - Idx) + 1;

            /* Set window end index for jth row */
            /* Subtract value at start of previous window.  */
            /* Then, add value at end of current window. */
            /* Element cast to type int32. */
            Sum = (Sum -
                   ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[Start
                   - 2] + 686]) +
              ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[(j + Idx) -
              2] + 686];

            /* Take mean */
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            q = d_x / winNew;
            d_x -= q * winNew;
            if ((d_x > 0U) && (d_x >= ((uint32_T)winNew >> 1U) + (winNew & 1U)))
            {
              q++;
            }

            z = (int32_T)q;
            if (Sum < 0) {
              z = -(int32_T)q;
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
          /* Set intial window length */
          n = winNew;
          Start -= 2;
          for (j = b_i; j <= NDetectionsFace_FR; j++) {
            Start++;

            /* Subtract value at start of previous window */
            /* Element cast to type int32. */
            Sum -= ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[Start
              - 1] + 686];

            /* Take mean:        */
            n--;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }
        }

        /* end function */
        /* ============================================================================================= */
        /* Code-generation and build script */
        /* ============================================================================================= */
        /* Code-generation and build script used to generate C-language code and create the compiled version  */
        /* (MovMean_mex) of the function. */
        /* { */
        /*  */
        /* %%%%% Specify variable-size input arguments %%%%%% */
        /*  */
        /* See Matlab documentation for coder.typeof. */
        /*                         Example Code               Upp. Bounds   Var. Size (T/F)  Type */
        /* ROICode  = coder.typeof( zeros(50, 2, 'int16'),     [500, 2],      [1, 0] );        %int16 */
        /*  */
        /*  */
        /* %%%%% Specify fixed-size input arguments %%%%%% */
        /*  */
        /* winCode = double(0); */
        /* NRowsROI = int32(0); */
        /* NColsROI = int32(0);          */
        /*     */
        /* %%%%% Set configurations to increase performance %%%%%% */
        /*  */
        /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
        /* "Optimization Strategies" */
        /* cfg = coder.config('mex'); */
        /* cfg.GlobalDataSyncMethod = 'NoSync'; */
        /* cfg.ConstantInputs = 'IgnoreValues'; */
        /* cfg.ExtrinsicCalls = false; */
        /* cfg.SaturateOnIntegerOverflow = false; */
        /* cfg.IntegrityChecks = false; */
        /* cfg.ResponsivenessChecks = false; */
        /*  */
        /*  */
        /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
        /*  */
        /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
        /*  */
        /* The flags are specified as part of the code-generation configuration object. A custom function, */
        /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
        /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
        /* Matlab guidance found in */
        /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
        /*  */
        /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
        /* a character vector prior to execution of the codegen command. */
        /*  */
        /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
        /*  */
        /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
        /* is not present in the base workspace. */
        /*  */
        /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
        /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each  */
        /* character vector to maintain the charater vector, */
        /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
        /*  */
        /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
        /*  */
        /* Assign to code-generation configuration object */
        /* cfg.PostCodeGenCommand = setbuildargsAsText; */
        /*  */
        /*  */
        /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
        /*  */
        /* codegen MovMean.m -report -config cfg -args {ROICode, winCode, NRowsROI, NColsROI} */
        /*   */
        /* } */
        Sum = SmoothedXYColumn->size[0];
        for (i = 0; i < Sum; i++) {
          ROINoPrevCallsBlock_FR[ROIBlockDetectionSkinLinIdx[i] + 458] =
            SmoothedXYColumn->data[i];
        }

        for (i = 0; i < Sum; i++) {
          ROINoPrevCallsBlock_FR[ROIBlockDetectionSkinLinIdx[i] + 687] =
            SmoothedXYColumn->data[i + SmoothedXYColumn->size[0]];
        }

        /* %%%%% --- Adjust X- and Y-coordinates to correspond to adjustments in widths and heights %%%%%% */
        /* Loop across ROIs corresponding to face-detection algorithm detections */
        for (b_i = 0; b_i < NDetectionsFace_FR; b_i++) {
          /* Extract index corresponding to detection  */
          /* Half of difference between unmatched widths and height and adjusted widths and  */
          /* heights. */
          /* Optimize division by two by bit-wise operation. */
          /* Add the half-differences to the X- and Y-coordinates */
          /* M x 4 matrix (229 x 4 during first-read operations); type int16. */
          /* Note: if there were negative differences, the half-differences will be subtracted from   */
          /* the X- and Y-coordinates. */
          u = c_ROIBlockDetectionFaceLinIdx_F[b_i];
          ROINoPrevCallsBlock_FR[u - 1] = (int16_T)(ROINoPrevCallsBlock_FR[u - 1]
            + ((int16_T)(ROIWidthHeightPreSmooth_data[b_i] -
                         ROINoPrevCallsBlock_FR[u + 457]) >> 1));
          ROINoPrevCallsBlock_FR[u + 228] = (int16_T)(ROINoPrevCallsBlock_FR[u +
            228] + ((int16_T)(ROIWidthHeightPreSmooth_data[b_i +
                              FrameByFrameSmoothingWin_WHHalf] -
                              ROINoPrevCallsBlock_FR[u + 686]) >> 1));
        }
      }

      /* %%%%% Skin-detection algorithm detection smoothing %%%%%% */
      /* Note: used during all calls: during the first-read operations and during both the pre-processing */
      /* and post-processing steps of the second-read operations. */
      /* During the second-read pre-processing step, smooth skin-detection ROIs near the beginning of the  */
      /* video that were smoothed during the first read. During the second-read post-processing step, */
      /* smooth skin-detection ROIs near the beginning of the video based on recent skin-detection */
      /* algorithm ROI detections. */
      /* Don't need to smooth if no ROIs correspond to skin-detections. */
      FaceOrSkinTF = (NDetectionsSkin_FR > 0);
      if (FaceOrSkinTF) {
        /* Only apply smoothing in this section to the skin-detection algorithm ROIs as the   */
        /* face-detection algorithm ROIs have already been smoothed. In order to use the ROIs from the  */
        /* face-detection algorithms as information in the smoothing, include ROIs from the  */
        /* face-detection algorithm; however, after smoothing, only retain the smoothed skin-detection  */
        /* ROIs so that the face-detection ROIs don't retain this additional smoothing. To do so, store  */
        /* the smoothed ROIs to a temporary variable and then extract only the skin-detection ROIs. */
        /* %%%%% --- Find positions of skin detections in detection-only ROI matrix %%%%%% */
        /* Find the positions in ROIBlockDetectionFaceSkinLinIdx where ROIBlockDetectionSkinLinIdx  */
        /* matches ROIBlockDetectionFaceSkinLinIdx. In other words, where in vector */
        /* ROIBlockDetectionFaceSkinLinIdx are the skin detections located. This index is used in a  */
        /* couple sections that follow.  */
        /* Column vector; int32. */
        /* Note: PositionsIn is a custom function located within folder 'FacePulseRate'. */
        /*  set A */
        /*  set B */
        /*  length of set A */
        /* PositionsIn   Return the index indicating where elements in set A are positioned in set B.  */
        /*  */
        /*     Helper function to function FacePulseRate.  */
        /*     Within function FacePulseRate, called by functions ROIMSIR_DetectionSmooth and  */
        /*     ROIMSIR_FaceDetectionLightSmooth. */
        /*  */
        /*     Code generation:  */
        /*  */
        /*     Can be called as a Matlab function or used for C-language code generation. */
        /*  */
        /*     Description: */
        /*  */
        /*     Return the index indicating where elements in set A are positioned in set B. Various  */
        /*     assumptions are made to increase efficiency.  */
        /*  */
        /*         Assumptions */
        /*     */
        /*     - Elements of set A are entirely nested within set B. */
        /*     - Within each set, values do not repeat and are ordered such that they increase monotonically. */
        /*  */
        /*     Example: */
        /*  */
        /*     A = [4, 5, 6]; */
        /*     B = [2, 3, 4, 5, 6]; */
        /*     A_Length = numel(A); */
        /*  */
        /*     PositionsIn(A, B, A_Length) */
        /*     >> [3; 4; 5] */
        /*  */
        /*     Note: */
        /*  */
        /*     The return values are equivalent to those returned by int32( find( ismember(B, A) )' ); */
        /* Inline function */
        /* Index of B on a given iteration */
        winNew = 0;

        /* Preallocate output */
        i = ROIBlockDetectionSkinLinIdx_SR->size[0];
        ROIBlockDetectionSkinLinIdx_SR->size[0] = NDetectionsSkin_FR;
        emxEnsureCapacity_int32_T(ROIBlockDetectionSkinLinIdx_SR, i);

        /* Loop across elements of A */
        for (b_i = 0; b_i < NDetectionsSkin_FR; b_i++) {
          do {
            winNew++;
          } while (!(c_ROIBlockDetectionSkinLinIdx_F[b_i] ==
                     f_ROIBlockDetectionFaceSkinLinI[winNew - 1]));

          /* Position (index) of ith index of A in B. */
          ROIBlockDetectionSkinLinIdx_SR->data[b_i] = winNew;
        }

        /* end function */
        /* %%%%% --- Assign temporary ROI matrix %%%%%% */
        /* Assign temporary ROI matrix that consists of ROIs that correspond to face or skin detections. */
        /* Rows of the matrix that correspond to face detections will be discarded at the end of   */
        /* skin-detection smoothing procedure.  */
        /* Preallocate:  */
        /* N face-or-skin detections x 4 matrix; type int16. */
        /* Assign ROIs that correspond to face or skin detections:    */
        /* Loop across columns */
        /* Loop across rows */
        for (j = 0; j < NDetectionsFaceSkin_FR; j++) {
          ROIBlockFaceSkin_Temp_data[j] =
            ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[j] - 1];
        }

        /* Loop across rows */
        for (j = 0; j < NDetectionsFaceSkin_FR; j++) {
          ROIBlockFaceSkin_Temp_data[j + NDetectionsFaceSkin_FR] =
            ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[j] + 228];
        }

        /* Loop across rows */
        for (j = 0; j < NDetectionsFaceSkin_FR; j++) {
          ROIBlockFaceSkin_Temp_data[j + NDetectionsFaceSkin_FR * 2] =
            ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[j] + 457];
        }

        /* Loop across rows */
        for (j = 0; j < NDetectionsFaceSkin_FR; j++) {
          ROIBlockFaceSkin_Temp_data[j + NDetectionsFaceSkin_FR * 3] =
            ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[j] + 686];
        }

        /* %%%%% --- Moving-mean smoothing on widths and heights %%%%%%     */
        /* Smooth with face-detection and/or skin-detection algorithm ROI widths and heights with those   */
        /* of other face-detection and/or skin-detection algorithm ROIs. As mentioned previously, any  */
        /* smoothing on ROIs that correspond to face detections will be discarded later. */
        /* The moving-mean smoothing window is relatively large to increase stability of ROI size across */
        /* frames. */
        /* Note: MovMean is a custom function located within folder 'FacePulseRate'. */
        /*  smoothing window */
        /*  the number of rows of the input matrix */
        /*  the number of columns of the input matrix */
        /* MovMean   Moving mean column-wise smoother. */
        /*  */
        /*     Helper function to function FacePulseRate.  */
        /*     Within function FacePulseRate, called by functions ROIMSIR_DetectionSmooth and */
        /*     ROIMSIR_FrameByFrameSmooth. */
        /*  */
        /*     Code generation:  */
        /*  */
        /*     Can be called as a Matlab function or used for C-language code generation. */
        /*  */
        /*     Description: */
        /*  */
        /*     Use a moving mean to conduct column-wise smoothing to a matrix. Weight rows corresponding to */
        /*     linear index WeightLinIdx by weight Weight. */
        /*  */
        /*     Inputs: */
        /*  */
        /*         ROI          = Matrix of values to be smoothed. M x :4 matrix; type int16.  */
        /*         Win          = Moving-mean window. Scalar; type double. */
        /*         NRowsROI     = The number of rows of the input matrix. Scalar; int32. */
        /*         NColsROI     = The number of columns of the input matrix. Scalar; int32. */
        /*  */
        /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
        /*     the Responsible AI License (RAIL). */
        /* Inline function */
        /* %%%%% Setup %%%%%% */
        /* Take half of window for use during operations */
        Idx = 16;

        /* Make the full window equal twice the value of the half-window:  */
        winNew = 31;

        /* Assert maximum number of columns to prevent dynamic memory allocation by the colon operator */
        /* Preallocate output */
        i = SmoothedXYColumn->size[0] * SmoothedXYColumn->size[1];
        SmoothedXYColumn->size[0] = NDetectionsFaceSkin_FR;
        SmoothedXYColumn->size[1] = 2;
        emxEnsureCapacity_int16_T(SmoothedXYColumn, i);

        /* %%%%% Reduce size of window if window cannot move %%%%%% */
        if (NDetectionsFaceSkin_FR <= 31) {
          /* Take one-fourth of window rather than one-half for use during operations */
          Idx = 8;

          /* Make the full window equal twice the value of the half-window:  */
          winNew = 15;
        }

        /* %%%%% If window still cannot move %%%%%% */
        if (NDetectionsFaceSkin_FR <= winNew) {
          /* Loop across columns */
          /* Initialize accumulator */
          Sum = 0;

          /* Sum rows across window           */
          for (j = 0; j < NDetectionsFaceSkin_FR; j++) {
            /* Element cast to type int32. */
            Sum += ROIBlockFaceSkin_Temp_data[j + NDetectionsFaceSkin_FR * 2];
          }

          /* Take the mean */
          if (NDetectionsFaceSkin_FR == 0) {
            if (Sum == 0) {
              Idx = 0;
            } else if (Sum < 0) {
              Idx = MIN_int32_T;
            } else {
              Idx = MAX_int32_T;
            }
          } else if (NDetectionsFaceSkin_FR == 1) {
            Idx = Sum;
          } else {
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            if ((uint32_T)NDetectionsFaceSkin_FR == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / NDetectionsFaceSkin_FR;
            }

            d_x -= q * NDetectionsFaceSkin_FR;
            if ((d_x > 0U) && (d_x >= ((uint32_T)NDetectionsFaceSkin_FR >> 1U) +
                               (NDetectionsFaceSkin_FR & 1U))) {
              q++;
            }

            Idx = (int32_T)q;
            if (Sum < 0) {
              Idx = -(int32_T)q;
            }
          }

          /* Assign the mean to all rows of column i */
          /* Initialize accumulator */
          Sum = 0;

          /* Sum rows across window           */
          for (j = 0; j < NDetectionsFaceSkin_FR; j++) {
            SmoothedXYColumn->data[j] = (int16_T)Idx;

            /* Element cast to type int32. */
            Sum += ROIBlockFaceSkin_Temp_data[j + NDetectionsFaceSkin_FR * 3];
          }

          /* Take the mean */
          if (NDetectionsFaceSkin_FR == 0) {
            if (Sum == 0) {
              Idx = 0;
            } else if (Sum < 0) {
              Idx = MIN_int32_T;
            } else {
              Idx = MAX_int32_T;
            }
          } else if (NDetectionsFaceSkin_FR == 1) {
            Idx = Sum;
          } else {
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            if ((uint32_T)NDetectionsFaceSkin_FR == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / NDetectionsFaceSkin_FR;
            }

            d_x -= q * NDetectionsFaceSkin_FR;
            if ((d_x > 0U) && (d_x >= ((uint32_T)NDetectionsFaceSkin_FR >> 1U) +
                               (NDetectionsFaceSkin_FR & 1U))) {
              q++;
            }

            Idx = (int32_T)q;
            if (Sum < 0) {
              Idx = -(int32_T)q;
            }
          }

          /* Assign the mean to all rows of column i */
          for (j = 0; j < NDetectionsFaceSkin_FR; j++) {
            SmoothedXYColumn->data[j + SmoothedXYColumn->size[0]] = (int16_T)Idx;
          }

          /* %%%%% If window can move %%%%%%     */
        } else {
          /* Loop across columns */
          i = Idx + 1;
          i1 = NDetectionsFaceSkin_FR - Idx;
          b_i = i1 + 2;

          /* Initialize */
          Sum = 0;

          /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
          /* Set intial window end index */
          /* Sum across truncated window           */
          for (j = 0; j < Idx; j++) {
            /* Cast to type int32 and add */
            Sum += ROIBlockFaceSkin_Temp_data[j + NDetectionsFaceSkin_FR * 2];
          }

          /* Take mean */
          if (Sum >= 0) {
            d_x = (uint32_T)Sum;
          } else if (Sum == MIN_int32_T) {
            d_x = 2147483648U;
          } else {
            d_x = (uint32_T)-Sum;
          }

          q = d_x / Idx;
          d_x -= q * Idx;
          if ((d_x > 0U) && (d_x >= ((uint32_T)Idx >> 1U) + (Idx & 1U))) {
            q++;
          }

          z = (int32_T)q;
          if (Sum < 0) {
            z = -(int32_T)q;
          }

          SmoothedXYColumn->data[0] = (int16_T)z;

          /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
          /* Set initial truncated window length */
          n = Idx;

          /* Loop across rows */
          for (j = 2; j <= Idx; j++) {
            /* Set window end index for jth row */
            /* Add value at end of current window */
            /* Element cast to type int32. */
            Sum += ROIBlockFaceSkin_Temp_data[((j + Idx) +
              NDetectionsFaceSkin_FR * 2) - 2];

            /* Take mean:                 */
            n++;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
          /* Loop across rows */
          for (j = i; j <= i1 + 1; j++) {
            /* Set window start index for jth row */
            Start = (j - Idx) + 1;

            /* Set window end index for jth row */
            /* Subtract value at start of previous window.  */
            /* Then, add value at end of current window. */
            /* Element cast to type int32. */
            Sum = (Sum - ROIBlockFaceSkin_Temp_data[(Start +
                    NDetectionsFaceSkin_FR * 2) - 2]) +
              ROIBlockFaceSkin_Temp_data[((j + Idx) + NDetectionsFaceSkin_FR * 2)
              - 2];

            /* Take mean */
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            q = d_x / winNew;
            d_x -= q * winNew;
            if ((d_x > 0U) && (d_x >= ((uint32_T)winNew >> 1U) + (winNew & 1U)))
            {
              q++;
            }

            z = (int32_T)q;
            if (Sum < 0) {
              z = -(int32_T)q;
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
          /* Set intial window length */
          n = winNew;
          Start -= 2;
          for (j = b_i; j <= NDetectionsFaceSkin_FR; j++) {
            Start++;

            /* Subtract value at start of previous window */
            /* Element cast to type int32. */
            Sum -= ROIBlockFaceSkin_Temp_data[(Start + NDetectionsFaceSkin_FR *
              2) - 1];

            /* Take mean:        */
            n--;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* Initialize */
          Sum = 0;

          /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
          /* Set intial window end index */
          /* Sum across truncated window           */
          for (j = 0; j < Idx; j++) {
            /* Cast to type int32 and add */
            Sum += ROIBlockFaceSkin_Temp_data[j + NDetectionsFaceSkin_FR * 3];
          }

          /* Take mean */
          if (Sum >= 0) {
            d_x = (uint32_T)Sum;
          } else if (Sum == MIN_int32_T) {
            d_x = 2147483648U;
          } else {
            d_x = (uint32_T)-Sum;
          }

          q = d_x / Idx;
          d_x -= q * Idx;
          if ((d_x > 0U) && (d_x >= ((uint32_T)Idx >> 1U) + (Idx & 1U))) {
            q++;
          }

          z = (int32_T)q;
          if (Sum < 0) {
            z = -(int32_T)q;
          }

          SmoothedXYColumn->data[SmoothedXYColumn->size[0]] = (int16_T)z;

          /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
          /* Set initial truncated window length */
          n = Idx;

          /* Loop across rows */
          for (j = 2; j <= Idx; j++) {
            /* Set window end index for jth row */
            /* Add value at end of current window */
            /* Element cast to type int32. */
            Sum += ROIBlockFaceSkin_Temp_data[((j + Idx) +
              NDetectionsFaceSkin_FR * 3) - 2];

            /* Take mean:                 */
            n++;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
          /* Loop across rows */
          for (j = i; j <= i1 + 1; j++) {
            /* Set window start index for jth row */
            Start = (j - Idx) + 1;

            /* Set window end index for jth row */
            /* Subtract value at start of previous window.  */
            /* Then, add value at end of current window. */
            /* Element cast to type int32. */
            Sum = (Sum - ROIBlockFaceSkin_Temp_data[(Start +
                    NDetectionsFaceSkin_FR * 3) - 2]) +
              ROIBlockFaceSkin_Temp_data[((j + Idx) + NDetectionsFaceSkin_FR * 3)
              - 2];

            /* Take mean */
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            q = d_x / winNew;
            d_x -= q * winNew;
            if ((d_x > 0U) && (d_x >= ((uint32_T)winNew >> 1U) + (winNew & 1U)))
            {
              q++;
            }

            z = (int32_T)q;
            if (Sum < 0) {
              z = -(int32_T)q;
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
          /* Set intial window length */
          n = winNew;
          Start -= 2;
          for (j = b_i; j <= NDetectionsFaceSkin_FR; j++) {
            Start++;

            /* Subtract value at start of previous window */
            /* Element cast to type int32. */
            Sum -= ROIBlockFaceSkin_Temp_data[(Start + NDetectionsFaceSkin_FR *
              3) - 1];

            /* Take mean:        */
            n--;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }
        }

        /* end function */
        /* ============================================================================================= */
        /* Code-generation and build script */
        /* ============================================================================================= */
        /* Code-generation and build script used to generate C-language code and create the compiled version  */
        /* (MovMean_mex) of the function. */
        /* { */
        /*  */
        /* %%%%% Specify variable-size input arguments %%%%%% */
        /*  */
        /* See Matlab documentation for coder.typeof. */
        /*                         Example Code               Upp. Bounds   Var. Size (T/F)  Type */
        /* ROICode  = coder.typeof( zeros(50, 2, 'int16'),     [500, 2],      [1, 0] );        %int16 */
        /*  */
        /*  */
        /* %%%%% Specify fixed-size input arguments %%%%%% */
        /*  */
        /* winCode = double(0); */
        /* NRowsROI = int32(0); */
        /* NColsROI = int32(0);          */
        /*     */
        /* %%%%% Set configurations to increase performance %%%%%% */
        /*  */
        /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
        /* "Optimization Strategies" */
        /* cfg = coder.config('mex'); */
        /* cfg.GlobalDataSyncMethod = 'NoSync'; */
        /* cfg.ConstantInputs = 'IgnoreValues'; */
        /* cfg.ExtrinsicCalls = false; */
        /* cfg.SaturateOnIntegerOverflow = false; */
        /* cfg.IntegrityChecks = false; */
        /* cfg.ResponsivenessChecks = false; */
        /*  */
        /*  */
        /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
        /*  */
        /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
        /*  */
        /* The flags are specified as part of the code-generation configuration object. A custom function, */
        /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
        /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
        /* Matlab guidance found in */
        /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
        /*  */
        /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
        /* a character vector prior to execution of the codegen command. */
        /*  */
        /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
        /*  */
        /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
        /* is not present in the base workspace. */
        /*  */
        /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
        /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each  */
        /* character vector to maintain the charater vector, */
        /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
        /*  */
        /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
        /*  */
        /* Assign to code-generation configuration object */
        /* cfg.PostCodeGenCommand = setbuildargsAsText; */
        /*  */
        /*  */
        /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
        /*  */
        /* codegen MovMean.m -report -config cfg -args {ROICode, winCode, NRowsROI, NColsROI} */
        /*   */
        /* } */
        Sum = SmoothedXYColumn->size[0];
        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp_data[i + NDetectionsFaceSkin_FR * 2] =
            SmoothedXYColumn->data[i];
        }

        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp_data[i + NDetectionsFaceSkin_FR * 3] =
            SmoothedXYColumn->data[i + SmoothedXYColumn->size[0]];
        }

        /* %%%%% --- Adjust X- and Y-coordinates as a result of adjustments in widths and heights %%%%%% */
        /* Adjust X- and Y-coordinates corresponding to skin detections as a result of adjustments in  */
        /* widths and heights. */
        /* Loop across columns */
        /* Loop across rows */
        for (j = 0; j < NDetectionsSkin_FR; j++) {
          /* Index of position of jth ROI corresponding to a skin detection in face-or-skin  */
          /* detection matrix. */
          /* Index of position of jth ROI corresponding to a skin detection in the ROI block */
          /*  Add the half-difference to the X- or Y-coordinate */
          /*  (If there were a negative difference, this would imply the abs value of the */
          /*  half-difference is subtracted from the coordinate). */
          /*  Take half of the difference (optimize division by 2 with bit-wise division) */
          /*  Difference between unsmoothed width and height and smoothed width and */
          /*  height. */
          Idx = (uint8_T)ROIBlockDetectionSkinLinIdx_SR->data[j] - 1;
          ROIBlockFaceSkin_Temp_data[Idx] = (int16_T)
            (ROIBlockFaceSkin_Temp_data[Idx] + ((int16_T)
              (ROINoPrevCallsBlock_FR[c_ROIBlockDetectionSkinLinIdx_F[j] + 457]
               - ROIBlockFaceSkin_Temp_data[Idx + NDetectionsFaceSkin_FR * 2]) >>
              1));
        }

        /* Loop across rows */
        for (j = 0; j < NDetectionsSkin_FR; j++) {
          /* Index of position of jth ROI corresponding to a skin detection in face-or-skin  */
          /* detection matrix. */
          /* Index of position of jth ROI corresponding to a skin detection in the ROI block */
          /*  Add the half-difference to the X- or Y-coordinate */
          /*  (If there were a negative difference, this would imply the abs value of the */
          /*  half-difference is subtracted from the coordinate). */
          /*  Take half of the difference (optimize division by 2 with bit-wise division) */
          /*  Difference between unsmoothed width and height and smoothed width and */
          /*  height. */
          Idx = (uint8_T)ROIBlockDetectionSkinLinIdx_SR->data[j] - 1;
          VideoReadConfig_FrameIdx_Length = Idx + NDetectionsFaceSkin_FR;
          ROIBlockFaceSkin_Temp_data[VideoReadConfig_FrameIdx_Length] = (int16_T)
            (ROIBlockFaceSkin_Temp_data[VideoReadConfig_FrameIdx_Length] +
             ((int16_T)(ROINoPrevCallsBlock_FR[c_ROIBlockDetectionSkinLinIdx_F[j]
                        + 686] - ROIBlockFaceSkin_Temp_data[Idx +
                        NDetectionsFaceSkin_FR * 3]) >> 1));
        }

        /* %%%%% --- Moving-mean smoothing on X- and Y-coordinates %%%%%% */
        /* Smooth with face-detection and/or skin-detection algorithm ROI X- and Y-coordinates with those   */
        /* of other face-detection and/or skin-detection algorithm ROIs. As mentioned previously, any   */
        /* smoothing on ROIs that correspond to face detections will be discarded later. */
        /* The moving-mean smoothing window is specified by argument ROISkinSmoothingWindow to function  */
        /* FacePulseRate.   */
        /* Note: MovMean is a custom function located within folder 'FacePulseRate'. */
        /*  smoothing window */
        /*  the number of rows of the input matrix */
        /*  the number of columns of the input matrix */
        /* MovMean   Moving mean column-wise smoother. */
        /*  */
        /*     Helper function to function FacePulseRate.  */
        /*     Within function FacePulseRate, called by functions ROIMSIR_DetectionSmooth and */
        /*     ROIMSIR_FrameByFrameSmooth. */
        /*  */
        /*     Code generation:  */
        /*  */
        /*     Can be called as a Matlab function or used for C-language code generation. */
        /*  */
        /*     Description: */
        /*  */
        /*     Use a moving mean to conduct column-wise smoothing to a matrix. Weight rows corresponding to */
        /*     linear index WeightLinIdx by weight Weight. */
        /*  */
        /*     Inputs: */
        /*  */
        /*         ROI          = Matrix of values to be smoothed. M x :4 matrix; type int16.  */
        /*         Win          = Moving-mean window. Scalar; type double. */
        /*         NRowsROI     = The number of rows of the input matrix. Scalar; int32. */
        /*         NColsROI     = The number of columns of the input matrix. Scalar; int32. */
        /*  */
        /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
        /*     the Responsible AI License (RAIL). */
        /* Inline function */
        /* %%%%% Setup %%%%%% */
        /* Take half of window for use during operations */
        Idx = (int32_T)muDoubleScalarFloor(c_SkinDetectConfig_ROISkinSmoot / 2.0)
          + 1;

        /* Make the full window equal twice the value of the half-window:  */
        winNew = ((Idx - 1) << 1) + 1;

        /* Assert maximum number of columns to prevent dynamic memory allocation by the colon operator */
        /* Preallocate output */
        i = SmoothedXYColumn->size[0] * SmoothedXYColumn->size[1];
        SmoothedXYColumn->size[0] = NDetectionsFaceSkin_FR;
        SmoothedXYColumn->size[1] = 2;
        emxEnsureCapacity_int16_T(SmoothedXYColumn, i);

        /* %%%%% Reduce size of window if window cannot move %%%%%% */
        if (NDetectionsFaceSkin_FR <= winNew) {
          /* Take one-fourth of window rather than one-half for use during operations */
          Idx = (int32_T)muDoubleScalarFloor(c_SkinDetectConfig_ROISkinSmoot /
            4.0) + 1;

          /* Make the full window equal twice the value of the half-window:  */
          winNew = ((Idx - 1) << 1) + 1;
        }

        /* %%%%% If window still cannot move %%%%%% */
        if (NDetectionsFaceSkin_FR <= winNew) {
          /* Loop across columns */
          /* Initialize accumulator */
          Sum = 0;

          /* Sum rows across window           */
          for (j = 0; j < NDetectionsFaceSkin_FR; j++) {
            /* Element cast to type int32. */
            Sum += ROIBlockFaceSkin_Temp_data[j];
          }

          /* Take the mean */
          if (NDetectionsFaceSkin_FR == 0) {
            if (Sum == 0) {
              Idx = 0;
            } else if (Sum < 0) {
              Idx = MIN_int32_T;
            } else {
              Idx = MAX_int32_T;
            }
          } else if (NDetectionsFaceSkin_FR == 1) {
            Idx = Sum;
          } else {
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            if ((uint32_T)NDetectionsFaceSkin_FR == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / NDetectionsFaceSkin_FR;
            }

            d_x -= q * NDetectionsFaceSkin_FR;
            if ((d_x > 0U) && (d_x >= ((uint32_T)NDetectionsFaceSkin_FR >> 1U) +
                               (NDetectionsFaceSkin_FR & 1U))) {
              q++;
            }

            Idx = (int32_T)q;
            if (Sum < 0) {
              Idx = -(int32_T)q;
            }
          }

          /* Assign the mean to all rows of column i */
          /* Initialize accumulator */
          Sum = 0;

          /* Sum rows across window           */
          for (j = 0; j < NDetectionsFaceSkin_FR; j++) {
            SmoothedXYColumn->data[j] = (int16_T)Idx;

            /* Element cast to type int32. */
            Sum += ROIBlockFaceSkin_Temp_data[j + NDetectionsFaceSkin_FR];
          }

          /* Take the mean */
          if (NDetectionsFaceSkin_FR == 0) {
            if (Sum == 0) {
              Idx = 0;
            } else if (Sum < 0) {
              Idx = MIN_int32_T;
            } else {
              Idx = MAX_int32_T;
            }
          } else if (NDetectionsFaceSkin_FR == 1) {
            Idx = Sum;
          } else {
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            if ((uint32_T)NDetectionsFaceSkin_FR == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / NDetectionsFaceSkin_FR;
            }

            d_x -= q * NDetectionsFaceSkin_FR;
            if ((d_x > 0U) && (d_x >= ((uint32_T)NDetectionsFaceSkin_FR >> 1U) +
                               (NDetectionsFaceSkin_FR & 1U))) {
              q++;
            }

            Idx = (int32_T)q;
            if (Sum < 0) {
              Idx = -(int32_T)q;
            }
          }

          /* Assign the mean to all rows of column i */
          for (j = 0; j < NDetectionsFaceSkin_FR; j++) {
            SmoothedXYColumn->data[j + SmoothedXYColumn->size[0]] = (int16_T)Idx;
          }

          /* %%%%% If window can move %%%%%%     */
        } else {
          /* Loop across columns */
          i = Idx + 1;
          i1 = NDetectionsFaceSkin_FR - Idx;
          b_i = i1 + 2;

          /* Initialize */
          Sum = 0;

          /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
          /* Set intial window end index */
          /* Sum across truncated window           */
          for (j = 0; j < Idx; j++) {
            /* Cast to type int32 and add */
            Sum += ROIBlockFaceSkin_Temp_data[j];
          }

          /* Take mean */
          if (Idx == 0) {
            if (Sum == 0) {
              z = 0;
            } else if (Sum < 0) {
              z = MIN_int32_T;
            } else {
              z = MAX_int32_T;
            }
          } else if (Idx == 1) {
            z = Sum;
          } else if (Idx == -1) {
            z = -Sum;
          } else {
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            if (Idx >= 0) {
              b_y = (uint32_T)Idx;
            } else if (Idx == MIN_int32_T) {
              b_y = 2147483648U;
            } else {
              b_y = (uint32_T)-Idx;
            }

            if (b_y == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / b_y;
            }

            d_x -= q * b_y;
            if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
              q++;
            }

            z = (int32_T)q;
            if ((Sum < 0) != (Idx < 0)) {
              z = -(int32_T)q;
            }
          }

          SmoothedXYColumn->data[0] = (int16_T)z;

          /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
          /* Set initial truncated window length */
          n = Idx;

          /* Loop across rows */
          for (j = 2; j <= Idx; j++) {
            /* Set window end index for jth row */
            /* Add value at end of current window */
            /* Element cast to type int32. */
            Sum += ROIBlockFaceSkin_Temp_data[(j + Idx) - 2];

            /* Take mean:                 */
            n++;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
          /* Loop across rows */
          for (j = i; j <= i1 + 1; j++) {
            /* Set window start index for jth row */
            Start = (j - Idx) + 1;

            /* Set window end index for jth row */
            /* Subtract value at start of previous window.  */
            /* Then, add value at end of current window. */
            /* Element cast to type int32. */
            Sum = (Sum - ROIBlockFaceSkin_Temp_data[Start - 2]) +
              ROIBlockFaceSkin_Temp_data[(j + Idx) - 2];

            /* Take mean */
            if (winNew == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (winNew == 1) {
              z = Sum;
            } else if (winNew == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (winNew >= 0) {
                b_y = (uint32_T)winNew;
              } else if (winNew == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-winNew;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (winNew < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
          /* Set intial window length */
          n = winNew;
          Start -= 2;
          for (j = b_i; j <= NDetectionsFaceSkin_FR; j++) {
            Start++;

            /* Subtract value at start of previous window */
            /* Element cast to type int32. */
            Sum -= ROIBlockFaceSkin_Temp_data[Start - 1];

            /* Take mean:        */
            n--;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* Initialize */
          Sum = 0;

          /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
          /* Set intial window end index */
          /* Sum across truncated window           */
          for (j = 0; j < Idx; j++) {
            /* Cast to type int32 and add */
            Sum += ROIBlockFaceSkin_Temp_data[j + NDetectionsFaceSkin_FR];
          }

          /* Take mean */
          if (Idx == 0) {
            if (Sum == 0) {
              z = 0;
            } else if (Sum < 0) {
              z = MIN_int32_T;
            } else {
              z = MAX_int32_T;
            }
          } else if (Idx == 1) {
            z = Sum;
          } else if (Idx == -1) {
            z = -Sum;
          } else {
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            if (Idx >= 0) {
              b_y = (uint32_T)Idx;
            } else if (Idx == MIN_int32_T) {
              b_y = 2147483648U;
            } else {
              b_y = (uint32_T)-Idx;
            }

            if (b_y == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / b_y;
            }

            d_x -= q * b_y;
            if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
              q++;
            }

            z = (int32_T)q;
            if ((Sum < 0) != (Idx < 0)) {
              z = -(int32_T)q;
            }
          }

          SmoothedXYColumn->data[SmoothedXYColumn->size[0]] = (int16_T)z;

          /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
          /* Set initial truncated window length */
          n = Idx;

          /* Loop across rows */
          for (j = 2; j <= Idx; j++) {
            /* Set window end index for jth row */
            /* Add value at end of current window */
            /* Element cast to type int32. */
            Sum += ROIBlockFaceSkin_Temp_data[((j + Idx) +
              NDetectionsFaceSkin_FR) - 2];

            /* Take mean:                 */
            n++;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
          /* Loop across rows */
          for (j = i; j <= i1 + 1; j++) {
            /* Set window start index for jth row */
            Start = (j - Idx) + 1;

            /* Set window end index for jth row */
            /* Subtract value at start of previous window.  */
            /* Then, add value at end of current window. */
            /* Element cast to type int32. */
            Sum = (Sum - ROIBlockFaceSkin_Temp_data[(Start +
                    NDetectionsFaceSkin_FR) - 2]) + ROIBlockFaceSkin_Temp_data
              [((j + Idx) + NDetectionsFaceSkin_FR) - 2];

            /* Take mean */
            if (winNew == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (winNew == 1) {
              z = Sum;
            } else if (winNew == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (winNew >= 0) {
                b_y = (uint32_T)winNew;
              } else if (winNew == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-winNew;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (winNew < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
          /* Set intial window length */
          n = winNew;
          Start -= 2;
          for (j = b_i; j <= NDetectionsFaceSkin_FR; j++) {
            Start++;

            /* Subtract value at start of previous window */
            /* Element cast to type int32. */
            Sum -= ROIBlockFaceSkin_Temp_data[(Start + NDetectionsFaceSkin_FR) -
              1];

            /* Take mean:        */
            n--;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }
        }

        /* end function */
        /* ============================================================================================= */
        /* Code-generation and build script */
        /* ============================================================================================= */
        /* Code-generation and build script used to generate C-language code and create the compiled version  */
        /* (MovMean_mex) of the function. */
        /* { */
        /*  */
        /* %%%%% Specify variable-size input arguments %%%%%% */
        /*  */
        /* See Matlab documentation for coder.typeof. */
        /*                         Example Code               Upp. Bounds   Var. Size (T/F)  Type */
        /* ROICode  = coder.typeof( zeros(50, 2, 'int16'),     [500, 2],      [1, 0] );        %int16 */
        /*  */
        /*  */
        /* %%%%% Specify fixed-size input arguments %%%%%% */
        /*  */
        /* winCode = double(0); */
        /* NRowsROI = int32(0); */
        /* NColsROI = int32(0);          */
        /*     */
        /* %%%%% Set configurations to increase performance %%%%%% */
        /*  */
        /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
        /* "Optimization Strategies" */
        /* cfg = coder.config('mex'); */
        /* cfg.GlobalDataSyncMethod = 'NoSync'; */
        /* cfg.ConstantInputs = 'IgnoreValues'; */
        /* cfg.ExtrinsicCalls = false; */
        /* cfg.SaturateOnIntegerOverflow = false; */
        /* cfg.IntegrityChecks = false; */
        /* cfg.ResponsivenessChecks = false; */
        /*  */
        /*  */
        /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
        /*  */
        /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
        /*  */
        /* The flags are specified as part of the code-generation configuration object. A custom function, */
        /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
        /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
        /* Matlab guidance found in */
        /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
        /*  */
        /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
        /* a character vector prior to execution of the codegen command. */
        /*  */
        /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
        /*  */
        /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
        /* is not present in the base workspace. */
        /*  */
        /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
        /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each  */
        /* character vector to maintain the charater vector, */
        /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
        /*  */
        /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
        /*  */
        /* Assign to code-generation configuration object */
        /* cfg.PostCodeGenCommand = setbuildargsAsText; */
        /*  */
        /*  */
        /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
        /*  */
        /* codegen MovMean.m -report -config cfg -args {ROICode, winCode, NRowsROI, NColsROI} */
        /*   */
        /* } */
        Sum = SmoothedXYColumn->size[0];
        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp_data[i] = SmoothedXYColumn->data[i];
        }

        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp_data[i + NDetectionsFaceSkin_FR] =
            SmoothedXYColumn->data[i + SmoothedXYColumn->size[0]];
        }

        /* %%%%% --- Discard recent smoothing for ROIs corresponding to face-detection algorithm detections %%%%%% */
        /* Discard smoothing for ROIs corresponding to face-detection algorithm detections where   */
        /* smoothing was applied that included skin-detection algorithm ROIs. This removes the influence */
        /* of skin-detection algorithm ROIs on face-detection algorithm ROIs. This is conducted because */
        /* face-detection algorithm ROIs are assumed to be more accurate than skin-detection algorithm  */
        /* ROIs. */
        /* Keep only ROIs corresponding to skin-detection algorithm detections  */
        /* M x 4 matrix (229 x 4 during first-read operations); type int16. */
        /* Loop across columns */
        /* Loop across rows */
        for (j = 0; j < NDetectionsSkin_FR; j++) {
          /* Index of position of jth ROI corresponding to a skin detection in the ROI block  */
          /* Index of position of jth ROI corresponding to a skin detection in face-or-skin  */
          /* detection matrix. */
          ROINoPrevCallsBlock_FR[c_ROIBlockDetectionSkinLinIdx_F[j] - 1] =
            ROIBlockFaceSkin_Temp_data[(uint8_T)
            ROIBlockDetectionSkinLinIdx_SR->data[j] - 1];
        }

        /* Loop across rows */
        for (j = 0; j < NDetectionsSkin_FR; j++) {
          /* Index of position of jth ROI corresponding to a skin detection in the ROI block  */
          /* Index of position of jth ROI corresponding to a skin detection in face-or-skin  */
          /* detection matrix. */
          ROINoPrevCallsBlock_FR[c_ROIBlockDetectionSkinLinIdx_F[j] + 228] =
            ROIBlockFaceSkin_Temp_data[((uint8_T)
            ROIBlockDetectionSkinLinIdx_SR->data[j] + NDetectionsFaceSkin_FR) -
            1];
        }

        /* Loop across rows */
        for (j = 0; j < NDetectionsSkin_FR; j++) {
          /* Index of position of jth ROI corresponding to a skin detection in the ROI block  */
          /* Index of position of jth ROI corresponding to a skin detection in face-or-skin  */
          /* detection matrix. */
          ROINoPrevCallsBlock_FR[c_ROIBlockDetectionSkinLinIdx_F[j] + 457] =
            ROIBlockFaceSkin_Temp_data[((uint8_T)
            ROIBlockDetectionSkinLinIdx_SR->data[j] + NDetectionsFaceSkin_FR * 2)
            - 1];
        }

        /* Loop across rows */
        for (j = 0; j < NDetectionsSkin_FR; j++) {
          /* Index of position of jth ROI corresponding to a skin detection in the ROI block  */
          /* Index of position of jth ROI corresponding to a skin detection in face-or-skin  */
          /* detection matrix. */
          ROINoPrevCallsBlock_FR[c_ROIBlockDetectionSkinLinIdx_F[j] + 686] =
            ROIBlockFaceSkin_Temp_data[((uint8_T)
            ROIBlockDetectionSkinLinIdx_SR->data[j] + NDetectionsFaceSkin_FR * 3)
            - 1];
        }

        /* %%%%% --- Lightly smooth ROIs corresponding to face-detection algorithm detections %%%%%% */
        /* The previous step (discarding smoothing for face-detection algorithm ROIs) may result in some  */
        /* undesired jumps of the ROI between face-detection algorithm detections and skin-detection  */
        /* algorithm detections. To smooth these jumps, the face-detection algorithm detections are */
        /* smoothed with a set of ROIs that include skin-detection algorithm detections. To reduce the */
        /* influence of skin-detection algorithm detections on face-detection algorithm detections --  */
        /* which was the purpose of the discarding step -- a small smoothing window of 3 is used. */
        /* Also assign a variable, NoPrevCallsBlock_ROIDetections, that only contains ROIs that  */
        /* correspond to a detection. This variable would have been assigned in the next section ("Assign   */
        /* an ROI matrix that contains only ROIs that correspond to a detection"), but it is assigned  */
        /* here for efficiency. */
        /* Return smoothed ROIs that correspond to either a face- or skin-detection algorithm detection */
        if (NDetectionsFace_FR != 0) {
          /* Note: ROIMSIR_FaceDetectionLightSmooth is a custom function located within folder  */
          /* 'FacePulseRate'. */
          /*  229 x 4 matrix; type int16 */
          /*  Index of positions of face detections in */
          /*  NoPrevCallsBlock_ROIDetections. */
          /* ROIMSIR_FaceDetectionLightSmooth   Lightly smooth ROIs corresponding to face detections. */
          /*  */
          /*     Helper function to function FacePulseRate.  */
          /*     Within function FacePulseRate, called by function ROIMSIR_DetectionSmooth. */
          /*  */
          /*  */
          /*     Code Generation */
          /*     --------------- */
          /*  */
          /*     Can be called as a Matlab function or used for C-language code generation. */
          /*  */
          /*  */
          /*     Description */
          /*     ----------- */
          /*  */
          /*     Lightly smooth ROIs corresponding to face detections:  */
          /*  */
          /*     (1) Smooth the height and width of each ROI. */
          /*     (2) Adjust the X- and Y-coordinates of each ROI to correspond to the previous changes to the  */
          /*         height and width. */
          /*     (3) Smooth the X- and Y-coordinates of each ROI. */
          /*  */
          /*     Return a matrix of ROIs that correspond to either face- or skin-detection algorithm  */
          /*     detections. Although this function only smooths ROIs corresponding to face detections, ROIs  */
          /*     corresponding to skin detections are also included in the output for efficient use in other  */
          /*     functions. Vector FaceIdxFit is an index that indicates which rows in the output matrix  */
          /*     correspond to the smoothed ROIs from face detections. */
          /*  */
          /*     Under certain conditions, even if a face-detection ROI is present, the ROI may not be  */
          /*     smoothed. In this case, there will not be a corresponding index in FaceIdxFit. */
          /*      */
          /*     Assumptions: */
          /*     */
          /*     - Neither NFaceSkinIdx nor NFaceIdx equal 0. */
          /*     - Elements of set FaceIdx are entirely nested within set FaceSkinIdx.       */
          /*     - Within each of these sets, values do not repeat and are ordered such that they increase */
          /*       monotonically. */
          /*  */
          /*  */
          /*     Copyright */
          /*     --------- */
          /*  */
          /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
          /*     the Responsible AI License (RAIL). */
          /* Inline function */
          /* Preallocate ROI matrix where ROIs correspond to either face- or skin-detection algorithm  */
          /* detections. */
          /* Preallocate index indicating position of smoothed ROIs that correspond to face-detection algorithm  */
          /* within variable ROIDetections. */
          /* If this variable is returned as 0, this indicates that no ROIs were smoothed within this function. */
          c_ROIBlockDetectionSkinLinIdx_F[0] = 0;

          /* If a smoothing window of 3 is possible */
          if (NDetectionsFaceSkin_FR > 2) {
            /* %%%%% --- Widths and heights and tentative X- and Y-coordinates %%%%%%       */
            /* Initialize face-detection algorithm detection counter */
            VideoReadConfig_FrameIdx_Length = 1;

            /* Loop across rows corresponding to a detection (either from face-detection or skin-detection */
            /* algorithm). */
            /* Note: the value of NFaceSkinIdx equals the length of FaceSkinIdx.  */
            for (b_i = 0; b_i < NDetectionsFaceSkin_FR; b_i++) {
              /* Index of ith face- or skin-detection */
              u = f_ROIBlockDetectionFaceSkinLinI[b_i];

              /* If the ith row corresponds to a face-detection algorithm detection */
              /* Note: this comparison method is possible because ... */
              /* (1) Set FaceIdx is completed nested within set FaceSkinIdx.  */
              /* (2) Both FaceIdx and FaceSkinIdx are sets of non-repeating monotonically increasing  */
              /* values. */
              /*  prevent FaceIdxCounter from indexing beyond length of FaceIdx */
              if ((VideoReadConfig_FrameIdx_Length <= NDetectionsFace_FR) && (u ==
                   c_ROIBlockDetectionFaceLinIdx_F[VideoReadConfig_FrameIdx_Length
                   - 1])) {
                /* the ith row corresponds to a face detection        */
                /* For first and last detections, do not smooth because a smoothing window of 3 cannot be */
                /* used. */
                if ((b_i + 1 == 1) || (b_i + 1 == NDetectionsFaceSkin_FR)) {
                  /* If first row of ROIDetections                */
                  if (b_i + 1 == 1) {
                    e_NoPrevCallsBlock_ROIDetection[0] =
                      ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[0]
                      - 1];
                    e_NoPrevCallsBlock_ROIDetection[NDetectionsFaceSkin_FR] =
                      ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[0]
                      + 228];
                    e_NoPrevCallsBlock_ROIDetection[NDetectionsFaceSkin_FR * 2] =
                      ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[0]
                      + 457];
                    e_NoPrevCallsBlock_ROIDetection[NDetectionsFaceSkin_FR * 3] =
                      ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[0]
                      + 686];

                    /* If last row of ROIDetections                      */
                  } else {
                    /*  i == NFaceSkinIdx                     */
                    e_NoPrevCallsBlock_ROIDetection[NDetectionsFaceSkin_FR - 1] =
                      ROINoPrevCallsBlock_FR[u - 1];
                    e_NoPrevCallsBlock_ROIDetection[(NDetectionsFaceSkin_FR +
                      NDetectionsFaceSkin_FR) - 1] = ROINoPrevCallsBlock_FR[u +
                      228];
                    e_NoPrevCallsBlock_ROIDetection[(NDetectionsFaceSkin_FR +
                      NDetectionsFaceSkin_FR * 2) - 1] =
                      ROINoPrevCallsBlock_FR[u + 457];
                    e_NoPrevCallsBlock_ROIDetection[(NDetectionsFaceSkin_FR +
                      NDetectionsFaceSkin_FR * 3) - 1] =
                      ROINoPrevCallsBlock_FR[u + 686];
                  }
                } else {
                  /* Loop across width and height columns */
                  /* ijth ROI */
                  /* Smooth ijth ROI  */
                  /* Scalar; int16. */
                  /* Note: as only three elements are summed, the data type will not overflow.                     */
                  winNew = f_ROIBlockDetectionFaceSkinLinI[b_i - 1];
                  Start = f_ROIBlockDetectionFaceSkinLinI[b_i + 1];
                  Idx = ROINoPrevCallsBlock_FR[u + 457];
                  Height_ith = (int16_T)((int16_T)(ROINoPrevCallsBlock_FR[winNew
                    + 457] + Idx) + ROINoPrevCallsBlock_FR[Start + 457]);
                  if (Height_ith >= 0) {
                    e_x = (uint16_T)Height_ith;
                  } else if (Height_ith == -32768) {
                    e_x = 32768U;
                  } else {
                    e_x = (uint16_T)-Height_ith;
                  }

                  b_q = (uint16_T)(e_x / 3U);
                  e_x = (uint16_T)((uint32_T)e_x - b_q * 3);
                  if ((e_x > 0) && (e_x >= 2)) {
                    b_q++;
                  }

                  WidthNew_ith = (int16_T)b_q;
                  if (Height_ith < 0) {
                    WidthNew_ith = (int16_T)-b_q;
                  }

                  /* Assign width or height: */
                  e_NoPrevCallsBlock_ROIDetection[b_i + NDetectionsFaceSkin_FR *
                    2] = WidthNew_ith;

                  /* Adjust X- or Y-coordinate to correspond to changes in width or height: */
                  /* (1) Take half of difference between old and new widths/heights */
                  /* (2) Add to X- or Y-coordinate */
                  /* Optimize division by 2 with bitwise operation. */
                  /* Width was smoothed -> Adjust X-coordinate */
                  e_NoPrevCallsBlock_ROIDetection[b_i] = (int16_T)
                    (ROINoPrevCallsBlock_FR[u - 1] + ((int16_T)(Idx -
                       WidthNew_ith) >> 1));

                  /* Height was smoothed -> Adjust Y-coordinate */
                  /* ijth ROI */
                  /* Smooth ijth ROI  */
                  /* Scalar; int16. */
                  /* Note: as only three elements are summed, the data type will not overflow.                     */
                  Idx = ROINoPrevCallsBlock_FR[u + 686];
                  Height_ith = (int16_T)((int16_T)(ROINoPrevCallsBlock_FR[winNew
                    + 686] + Idx) + ROINoPrevCallsBlock_FR[Start + 686]);
                  if (Height_ith >= 0) {
                    e_x = (uint16_T)Height_ith;
                  } else if (Height_ith == -32768) {
                    e_x = 32768U;
                  } else {
                    e_x = (uint16_T)-Height_ith;
                  }

                  b_q = (uint16_T)(e_x / 3U);
                  e_x = (uint16_T)((uint32_T)e_x - b_q * 3);
                  if ((e_x > 0) && (e_x >= 2)) {
                    b_q++;
                  }

                  WidthNew_ith = (int16_T)b_q;
                  if (Height_ith < 0) {
                    WidthNew_ith = (int16_T)-b_q;
                  }

                  /* Assign width or height: */
                  e_NoPrevCallsBlock_ROIDetection[b_i + NDetectionsFaceSkin_FR *
                    3] = WidthNew_ith;

                  /* Adjust X- or Y-coordinate to correspond to changes in width or height: */
                  /* (1) Take half of difference between old and new widths/heights */
                  /* (2) Add to X- or Y-coordinate */
                  /* Optimize division by 2 with bitwise operation. */
                  e_NoPrevCallsBlock_ROIDetection[b_i + NDetectionsFaceSkin_FR] =
                    (int16_T)(ROINoPrevCallsBlock_FR[u + 228] + ((int16_T)(Idx -
                    WidthNew_ith) >> 1));

                  /* Position of ROI does not permit smoothing window of length 3 */
                }

                /* Advance counter of face-detection algorithm detections */
                VideoReadConfig_FrameIdx_Length++;

                /* If the ith detection is not a face-detection algorithm detection */
                /* I.e., it is a skin-detection algorithm detection. */
              } else {
                e_NoPrevCallsBlock_ROIDetection[b_i] = ROINoPrevCallsBlock_FR[u
                  - 1];
                e_NoPrevCallsBlock_ROIDetection[b_i + NDetectionsFaceSkin_FR] =
                  ROINoPrevCallsBlock_FR[u + 228];
                e_NoPrevCallsBlock_ROIDetection[b_i + NDetectionsFaceSkin_FR * 2]
                  = ROINoPrevCallsBlock_FR[u + 457];
                e_NoPrevCallsBlock_ROIDetection[b_i + NDetectionsFaceSkin_FR * 3]
                  = ROINoPrevCallsBlock_FR[u + 686];
              }
            }

            /* %%%%% --- Final X- and Y-coordinates %%%%%%              */
            /* Preallocate column of smoothed ROI elements that correspond to the X- and Y-coordinates of */
            /* face-detection algorithm detections.  */
            /* Smoothed ROI elements are assigned to this variable rather than variable ROIDetections to  */
            /* prevent elements that have been smoothed from being included in the smoothing windows of  */
            /* subsequent elements. After the loop, the smoothed elements are assigned to ROIDetections.     */
            /* Assign the first and/or last rows of SmoothedXYColumn if there is a match to the first and/or  */
            /* last rows of ROIDetections: */
            /* This assignment is made here because these rows will not be assigned later. */
            if (c_ROIBlockDetectionFaceLinIdx_F[0] ==
                f_ROIBlockDetectionFaceSkinLinI[0]) {
              ROIWidthHeightPreSmooth_data[0] = e_NoPrevCallsBlock_ROIDetection
                [0];
              ROIWidthHeightPreSmooth_data[NDetectionsFace_FR] =
                e_NoPrevCallsBlock_ROIDetection[NDetectionsFaceSkin_FR];
            }

            if (c_ROIBlockDetectionFaceLinIdx_F[NDetectionsFace_FR - 1] ==
                f_ROIBlockDetectionFaceSkinLinI[NDetectionsFaceSkin_FR - 1]) {
              ROIWidthHeightPreSmooth_data[NDetectionsFace_FR - 1] =
                e_NoPrevCallsBlock_ROIDetection[NDetectionsFaceSkin_FR - 1];
              ROIWidthHeightPreSmooth_data[(NDetectionsFace_FR +
                NDetectionsFace_FR) - 1] = e_NoPrevCallsBlock_ROIDetection
                [(NDetectionsFaceSkin_FR + NDetectionsFaceSkin_FR) - 1];
            }

            /* Smooth X- and Y-coordinates: */
            /* Find the positions of FaceIdx in FaceSkinIdx  */
            /* Column vector; int32. */
            /* Note: PositionsIn is a custom function located within folder 'FacePulseRate'. */
            /*  set A */
            /*  set B */
            /*  length of set A */
            /* PositionsIn   Return the index indicating where elements in set A are positioned in set B.  */
            /*  */
            /*     Helper function to function FacePulseRate.  */
            /*     Within function FacePulseRate, called by functions ROIMSIR_DetectionSmooth and  */
            /*     ROIMSIR_FaceDetectionLightSmooth. */
            /*  */
            /*     Code generation:  */
            /*  */
            /*     Can be called as a Matlab function or used for C-language code generation. */
            /*  */
            /*     Description: */
            /*  */
            /*     Return the index indicating where elements in set A are positioned in set B. Various  */
            /*     assumptions are made to increase efficiency.  */
            /*  */
            /*         Assumptions */
            /*     */
            /*     - Elements of set A are entirely nested within set B. */
            /*     - Within each set, values do not repeat and are ordered such that they increase monotonically. */
            /*  */
            /*     Example: */
            /*  */
            /*     A = [4, 5, 6]; */
            /*     B = [2, 3, 4, 5, 6]; */
            /*     A_Length = numel(A); */
            /*  */
            /*     PositionsIn(A, B, A_Length) */
            /*     >> [3; 4; 5] */
            /*  */
            /*     Note: */
            /*  */
            /*     The return values are equivalent to those returned by int32( find( ismember(B, A) )' ); */
            /* Inline function */
            /* Index of B on a given iteration */
            winNew = 0;

            /* Preallocate output */
            i = ROIBlockDetectionSkinLinIdx_SR->size[0];
            ROIBlockDetectionSkinLinIdx_SR->size[0] = NDetectionsFace_FR;
            emxEnsureCapacity_int32_T(ROIBlockDetectionSkinLinIdx_SR, i);

            /* Loop across elements of A */
            for (b_i = 0; b_i < NDetectionsFace_FR; b_i++) {
              do {
                winNew++;
              } while (!(c_ROIBlockDetectionFaceLinIdx_F[b_i] ==
                         f_ROIBlockDetectionFaceSkinLinI[winNew - 1]));

              /* Position (index) of ith index of A in B. */
              ROIBlockDetectionSkinLinIdx_SR->data[b_i] = winNew;
            }

            /* end function */
            Sum = ROIBlockDetectionSkinLinIdx_SR->size[0];
            for (i = 0; i < Sum; i++) {
              c_ROIBlockDetectionSkinLinIdx_F[i] =
                ROIBlockDetectionSkinLinIdx_SR->data[i];
            }

            /* Loop across rows corresponding to a face detection  */
            /* Note: the value of NFaceIdx equals the length of FaceIdx.  */
            for (b_i = 0; b_i < NDetectionsFace_FR; b_i++) {
              i = ROIBlockDetectionSkinLinIdx_SR->data[b_i];

              /* For first and last detections, do not smooth because a smoothing window of 3 cannot be */
              /* used. */
              if (((uint8_T)ROIBlockDetectionSkinLinIdx_SR->data[b_i] != 1) &&
                  ((uint8_T)ROIBlockDetectionSkinLinIdx_SR->data[b_i] !=
                   NDetectionsFaceSkin_FR)) {
                /* Loop across X- and Y-coordinate columns */
                /* Smooth ijth ROI and assign to SmoothedXYColumn */
                /* (See note where SmoothedColumn preallocated). */
                /* Scalar; int16. */
                /* Note: as only three elements are summed, the data type will not overflow.                     */
                Height_ith = (int16_T)((int16_T)
                  (e_NoPrevCallsBlock_ROIDetection[(uint8_T)i - 2] +
                   e_NoPrevCallsBlock_ROIDetection[(uint8_T)i - 1]) +
                  e_NoPrevCallsBlock_ROIDetection[(uint8_T)i]);
                if (Height_ith >= 0) {
                  e_x = (uint16_T)Height_ith;
                } else if (Height_ith == -32768) {
                  e_x = 32768U;
                } else {
                  e_x = (uint16_T)-Height_ith;
                }

                b_q = (uint16_T)(e_x / 3U);
                e_x = (uint16_T)((uint32_T)e_x - b_q * 3);
                if ((e_x > 0) && (e_x >= 2)) {
                  b_q++;
                }

                ROIWidthHeightPreSmooth_data[b_i] = (int16_T)b_q;
                if (Height_ith < 0) {
                  ROIWidthHeightPreSmooth_data[b_i] = (int16_T)-b_q;
                }

                /* Smooth ijth ROI and assign to SmoothedXYColumn */
                /* (See note where SmoothedColumn preallocated). */
                /* Scalar; int16. */
                /* Note: as only three elements are summed, the data type will not overflow.                     */
                winNew = (uint8_T)i + NDetectionsFaceSkin_FR;
                Height_ith = (int16_T)((int16_T)
                  (e_NoPrevCallsBlock_ROIDetection[winNew - 2] +
                   e_NoPrevCallsBlock_ROIDetection[winNew - 1]) +
                  e_NoPrevCallsBlock_ROIDetection[winNew]);
                if (Height_ith >= 0) {
                  e_x = (uint16_T)Height_ith;
                } else if (Height_ith == -32768) {
                  e_x = 32768U;
                } else {
                  e_x = (uint16_T)-Height_ith;
                }

                b_q = (uint16_T)(e_x / 3U);
                e_x = (uint16_T)((uint32_T)e_x - b_q * 3);
                if ((e_x > 0) && (e_x >= 2)) {
                  b_q++;
                }

                Idx = b_i + NDetectionsFace_FR;
                ROIWidthHeightPreSmooth_data[Idx] = (int16_T)b_q;
                if (Height_ith < 0) {
                  ROIWidthHeightPreSmooth_data[Idx] = (int16_T)-b_q;
                }
              }
            }

            /* Assign final X- and Y-coordinates: */
            /* Loop across X- and Y-coordinate columns corresponding to detections */
            /* Loop across rows corresponding to a face detection  */
            /* Note: the value of NFaceIdx equals the length of FaceIdx.  */
            for (j = 0; j < NDetectionsFace_FR; j++) {
              e_NoPrevCallsBlock_ROIDetection[(uint8_T)
                ROIBlockDetectionSkinLinIdx_SR->data[j] - 1] =
                ROIWidthHeightPreSmooth_data[j];
            }

            /* Loop across rows corresponding to a face detection  */
            /* Note: the value of NFaceIdx equals the length of FaceIdx.  */
            for (j = 0; j < NDetectionsFace_FR; j++) {
              e_NoPrevCallsBlock_ROIDetection[((uint8_T)
                ROIBlockDetectionSkinLinIdx_SR->data[j] + NDetectionsFaceSkin_FR)
                - 1] = ROIWidthHeightPreSmooth_data[j + NDetectionsFace_FR];
            }

            /* A smoothing window of 3 is not possible */
            /* ROINoPrevCallsBlock_ROIDetections will not be empty. */
          } else if (NDetectionsFaceSkin_FR > 0) {
            for (b_i = 0; b_i < NDetectionsFaceSkin_FR; b_i++) {
              u = f_ROIBlockDetectionFaceSkinLinI[b_i];
              e_NoPrevCallsBlock_ROIDetection[b_i] = ROINoPrevCallsBlock_FR[u -
                1];
              e_NoPrevCallsBlock_ROIDetection[b_i + NDetectionsFaceSkin_FR] =
                ROINoPrevCallsBlock_FR[u + 228];
              e_NoPrevCallsBlock_ROIDetection[b_i + NDetectionsFaceSkin_FR * 2] =
                ROINoPrevCallsBlock_FR[u + 457];
              e_NoPrevCallsBlock_ROIDetection[b_i + NDetectionsFaceSkin_FR * 3] =
                ROINoPrevCallsBlock_FR[u + 686];
            }

            /* A smoothing window of 3 is not possible */
            /* ROINoPrevCallsBlock_ROIDetections will be empty.     */
          } else {
            /* NDetectionsFaceSkin == 0 */
            d_NoPrevCallsBlock_ROIDetection = 0;
          }

          /* end function */
          /* Assign smoothed ROIs corresponding to face detections to ROI matrix: */
          /* Loop across columns */
          /* Loop across rows         */
          for (j = 0; j < NDetectionsFace_FR; j++) {
            /* Position of jth face-detection in ROINoPrevCallsBlock  */
            /* Position of jth face-detection in NoPrevCallsBlock_ROIDetections  */
            ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[j] - 1] =
              e_NoPrevCallsBlock_ROIDetection[c_ROIBlockDetectionSkinLinIdx_F[j]
              - 1];
          }

          /* Loop across rows         */
          for (j = 0; j < NDetectionsFace_FR; j++) {
            /* Position of jth face-detection in ROINoPrevCallsBlock  */
            /* Position of jth face-detection in NoPrevCallsBlock_ROIDetections  */
            ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[j] + 228] =
              e_NoPrevCallsBlock_ROIDetection[(c_ROIBlockDetectionSkinLinIdx_F[j]
              + d_NoPrevCallsBlock_ROIDetection) - 1];
          }

          /* Loop across rows         */
          for (j = 0; j < NDetectionsFace_FR; j++) {
            /* Position of jth face-detection in ROINoPrevCallsBlock  */
            /* Position of jth face-detection in NoPrevCallsBlock_ROIDetections  */
            ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[j] + 457] =
              e_NoPrevCallsBlock_ROIDetection[(c_ROIBlockDetectionSkinLinIdx_F[j]
              + d_NoPrevCallsBlock_ROIDetection * 2) - 1];
          }

          /* Loop across rows         */
          for (j = 0; j < NDetectionsFace_FR; j++) {
            /* Position of jth face-detection in ROINoPrevCallsBlock  */
            /* Position of jth face-detection in NoPrevCallsBlock_ROIDetections  */
            ROINoPrevCallsBlock_FR[c_ROIBlockDetectionFaceLinIdx_F[j] + 686] =
              e_NoPrevCallsBlock_ROIDetection[(c_ROIBlockDetectionSkinLinIdx_F[j]
              + d_NoPrevCallsBlock_ROIDetection * 3) - 1];
          }
        }
      }

      /* %%%%% Assign an ROI matrix that contains only ROIs that correspond to a detection %%%%%% */
      /* This variable contains all ROIs that correspond to either a face- or skin-detection algorthm  */
      /* detection. This variable will be used as input to functions ROIMSIR_Interpolate and  */
      /* ROIMSIR_FrameByFrameSmooth. */
      /* If no skin-detection ROIs were smoothed or if the number of face detections equals 0. */
      /* In either case, variable NoPrevCallsBlock_ROIDetections would not have been previously assigned.  */
      if ((!FaceOrSkinTF) || (NDetectionsFace_FR == 0)) {
        /* If no ROIs in the block correspond to detections by either the skin-detection algorithm or the */
        /* face-detection algorithm. */
        if (NDetectionsFaceSkin_FR == 0) {
          d_NoPrevCallsBlock_ROIDetection = 0;

          /* If at least one ROI in block corresponds to a detection         */
        } else {
          /* Loop across columns */
          /* Loop across rows     */
          for (j = 0; j < NDetectionsFaceSkin_FR; j++) {
            /* jjth index corresponding to a detection */
            e_NoPrevCallsBlock_ROIDetection[j] =
              ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[j] - 1];
          }

          /* Loop across rows     */
          for (j = 0; j < NDetectionsFaceSkin_FR; j++) {
            /* jjth index corresponding to a detection */
            e_NoPrevCallsBlock_ROIDetection[j + d_NoPrevCallsBlock_ROIDetection]
              = ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[j] + 228];
          }

          /* Loop across rows     */
          for (j = 0; j < NDetectionsFaceSkin_FR; j++) {
            /* jjth index corresponding to a detection */
            e_NoPrevCallsBlock_ROIDetection[j + d_NoPrevCallsBlock_ROIDetection *
              2] = ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[j] +
              457];
          }

          /* Loop across rows     */
          for (j = 0; j < NDetectionsFaceSkin_FR; j++) {
            /* jjth index corresponding to a detection */
            e_NoPrevCallsBlock_ROIDetection[j + d_NoPrevCallsBlock_ROIDetection *
              3] = ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[j] +
              686];
          }
        }
      }

      /* %%%%% Adjust ROI(s) that exceed frame dimensions %%%%%%    */
      /* Although ROI(s) are also checked later in function ROIMSIR, check here as well so that any */
      /* overshoots from smoothing don't affect the interpolation operations in function  */
      /* ROIMSIR_Interpolate, which occurs before the check by ROIMSIR. Also, before the check by ROIMSIR, */
      /* ROIs returned here will influence variable ROIOutBeforeFrameByFrameSmoothing_FR or  */
      /* ROIOutBeforeFrameByFrameSmoothing_SR (assigned in function ROIMSIR), and this variable needs to be */
      /* within frame dimensions for later use in function WriteFaceVideo.  */
      /* Note: used during all calls: during the first read and during both the pre-processing and */
      /* post-processing steps of the second read.  */
      /* Note: although it may seem unlikely for the smoothing of ROIs to result in values outside of frame */
      /* dimensions, this might occur when, for example, both the width and the X-coordinate increased or   */
      /* both the height and the Y-coordinate increased. */
      /* Adjust any coordinates that exceed frame dimensions */
      /* M x 4 matrix (229 x 4 during first-read operations); type int16. */
      /* Note: ROIAdjustIfExceedsFrameDims is a custom function located within folder 'FacePulseRate'. */
      i = ROIBlockFaceSkin_Temp->size[0] * ROIBlockFaceSkin_Temp->size[1];
      ROIBlockFaceSkin_Temp->size[0] = d_ROIBlockDetectionFaceSkinLinI;
      ROIBlockFaceSkin_Temp->size[1] = 4;
      emxEnsureCapacity_int16_T(ROIBlockFaceSkin_Temp, i);
      for (i = 0; i < d_ROIBlockDetectionFaceSkinLinI; i++) {
        ROIBlockFaceSkin_Temp->data[i] =
          ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] - 1];
      }

      for (i = 0; i < d_ROIBlockDetectionFaceSkinLinI; i++) {
        ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0]] =
          ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] + 228];
      }

      for (i = 0; i < d_ROIBlockDetectionFaceSkinLinI; i++) {
        ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 2] =
          ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] + 457];
      }

      for (i = 0; i < d_ROIBlockDetectionFaceSkinLinI; i++) {
        ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 3] =
          ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] + 686];
      }

      /* ROIAdjustIfExceedsFrameDims   Verify whether proposed widths and heights of ROIs exceed frame  */
      /*                               dimensions and, if so, modify them to conform to frame dimensions. */
      /*                                */
      /*     Helper function to function FacePulseRate. */
      /*     Within function FacePulseRate, called by functions ROIResize, ROIMeans_FirstRead_Extrapolate, */
      /*     SkinDetect_EnlargeROI, ROIMSIR, ROIMSIR_MatchSize, ROIMSIR_DetectionSmooth,   */
      /*     ROIMSIR_Interpolate, and ROIMSIR_FrameByFrameSmooth.    */
      /*  */
      /*  */
      /*     Code Generation */
      /*     --------------- */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /*  */
      /*  */
      /*     Description */
      /*     ----------- */
      /*  */
      /*     This function verifies that ROIs that have had modifications to their sizes are still within */
      /*     the dimensions of the frame. If not, this function adjusts the dimensions (and, consequently,   */
      /*     the spatial coordinates) to conform to the frame dimensions. */
      /*  */
      /*     Note:  */
      /*  */
      /*     Intended only for use with integer types as rounding is not conducted. For modification for  */
      /*     use with floating-point types, rounding would be necessary as ROI values should be integers. */
      /*  */
      /*  */
      /*     Copyright */
      /*     --------- */
      /*  */
      /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
      /*     the Responsible AI License (RAIL). */
      /* %%%%% Validate inputs %%%%%% */
      /* Exit if empty */
      if (d_ROIBlockDetectionFaceSkinLinI != 0) {
        /* Validate whether input ROIsProposed is type int16. */
        /* Must be an integer type because no rounding is conducted. */
        /* Should be type int16 because the function is implemented to assign values of this type. */
        /* A non-matching type would be due to an implementation error. */
        /* %%%%% Running in code generation %%%%%% */
        /* When running in code generation, use for-loops. When running in Matlab code, use vectorization. */
        /* code generation running */
        /* Inline function */
        for (b_i = 0; b_i < d_ROIBlockDetectionFaceSkinLinI; b_i++) {
          /* %%%%% --- Verify, and adjust if necessary, X-coordinates and widths %%%%%% */
          /* Adjust left-side X-coordinate if exceeds frame dimensions: */
          WidthNew_ith = ROIBlockFaceSkin_Temp->data[b_i];
          if (WidthNew_ith < 1) {
            WidthNew_ith = 1;

            /* recent code mod */
            ROIBlockFaceSkin_Temp->data[b_i] = 1;
          } else {
            if (WidthNew_ith > VidObjWidth) {
              WidthNew_ith = VidObjWidth;

              /* recent code mod */
              ROIBlockFaceSkin_Temp->data[b_i] = VidObjWidth;
            }
          }

          /* Adjust right-side X-coordinate if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(WidthNew_ith +
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 2])
                                - 1);
          if (Width_ith > VidObjWidth) {
            Width_ith = VidObjWidth;
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 2]
              = (int16_T)((int16_T)(VidObjWidth - WidthNew_ith) + 1);
          } else {
            if (Width_ith < 1) {
              Width_ith = 1;
              WidthNew_ith = 1;
              ROIBlockFaceSkin_Temp->data[b_i] = 1;
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                2] = 1;
            }
          }

          /* Adjust width if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(Width_ith - WidthNew_ith) + 1);
          if (Width_ith > VidObjWidth) {
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 2]
              = VidObjWidth;
          } else {
            if (Width_ith < 1) {
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                2] = 1;
            }
          }

          /* %%%%% --- Verify, and adjust if necessary, Y-coordinates and heights %%%%%% */
          /* Adjust top-side Y-coordinate if exceeds frame dimensions: */
          Height_ith = ROIBlockFaceSkin_Temp->data[b_i +
            ROIBlockFaceSkin_Temp->size[0]];
          if (Height_ith < 1) {
            Height_ith = 1;

            /* recent code mod */
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0]] =
              1;
          } else {
            if (Height_ith > VidObjHeight) {
              Height_ith = VidObjHeight;

              /* recent code mod */
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0]] =
                VidObjHeight;
            }
          }

          /* Adjust bottom-side Y-coordinate if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(Height_ith +
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 3])
                                - 1);
          if (Width_ith > VidObjHeight) {
            Width_ith = VidObjHeight;
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 3]
              = (int16_T)((int16_T)(VidObjHeight - Height_ith) + 1);
          } else {
            if (Width_ith < 1) {
              Width_ith = 1;
              Height_ith = 1;
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0]] =
                1;
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                3] = 1;
            }
          }

          /* Adjust height value if exceeds frame dimensions: */
          HeightNew_ith = (int16_T)((int16_T)(Width_ith - Height_ith) + 1);
          if (HeightNew_ith > VidObjHeight) {
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 3]
              = VidObjHeight;
          } else {
            if (HeightNew_ith < 1) {
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                3] = 1;
            }
          }
        }

        /* %%%%% Code generation not running %%%%%% */
      } else {
        /* Exit function */
      }

      /* end function */
      /* ============================================================================================= */
      /* Code-generation and build script */
      /* ============================================================================================= */
      /* Code-generation and build script used to generate C-language code and create the compiled version  */
      /* (ROIAdjustIfExceedsFrameDims_mex) of the function. */
      /* { */
      /*  */
      /* %%%%% Specify variable-size input arguments %%%%%% */
      /*  */
      /* See Matlab documentation for coder.typeof. */
      /*  */
      /*                                   Example Code               Upp. Bounds   Var. Size (T/F)  Type */
      /* ROIsProposedCode   = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],     [1, 0] );        %int16 */
      /*            */
      /*        */
      /* %%%%% Specify fixed-size input arguments %%%%%% */
      /*  */
      /* VidObjWidthCode  = int16(0);          */
      /* VidObjHeightCode = int16(0); */
      /*                    */
      /*  */
      /* %%%%% Set configurations to increase performance %%%%%% */
      /*  */
      /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
      /* "Optimization Strategies" */
      /*  */
      /* cfg = coder.config('mex'); */
      /* cfg.GlobalDataSyncMethod = 'NoSync'; */
      /* cfg.ConstantInputs = 'IgnoreValues'; */
      /* cfg.ExtrinsicCalls = true; %permit to show assert error */
      /* cfg.SaturateOnIntegerOverflow = false; */
      /* cfg.IntegrityChecks = false; */
      /* cfg.ResponsivenessChecks = false; */
      /*  */
      /*  */
      /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
      /*  */
      /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
      /*  */
      /* The flags are specified as part of the code-generation configuration object. A custom function, */
      /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
      /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
      /* Matlab guidance found in */
      /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
      /*  */
      /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
      /* a character vector prior to execution of the codegen command. */
      /*  */
      /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
      /*  */
      /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
      /* is not present in the base workspace. */
      /*  */
      /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
      /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
      /* character vector to maintain the charater vector, */
      /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
      /*  */
      /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
      /*  */
      /* Assign to code-generation configuration object */
      /* cfg.PostCodeGenCommand = setbuildargsAsText; */
      /*  */
      /*  */
      /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
      /*  */
      /* codegen ROIAdjustIfExceedsFrameDims.m -report -config cfg -args {ROIsProposedCode, VidObjWidthCode, VidObjHeightCode} */
      /*                  */
      /* } */
      Sum = ROIBlockFaceSkin_Temp->size[0];
      for (i = 0; i < Sum; i++) {
        ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] - 1] =
          ROIBlockFaceSkin_Temp->data[i];
      }

      for (i = 0; i < Sum; i++) {
        ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] + 228] =
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0]];
      }

      for (i = 0; i < Sum; i++) {
        ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] + 457] =
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 2];
      }

      for (i = 0; i < Sum; i++) {
        ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] + 686] =
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 3];
      }

      /* Adjust any coordinates that exceed frame dimensions */
      /* N detections x 4 matrix (:229 x 4 during first-read operations); type int16. */
      /* Note: ROIAdjustIfExceedsFrameDims is a custom function located within folder 'FacePulseRate'. */
      i = ROIBlockFaceSkin_Temp->size[0] * ROIBlockFaceSkin_Temp->size[1];
      ROIBlockFaceSkin_Temp->size[0] = d_NoPrevCallsBlock_ROIDetection;
      ROIBlockFaceSkin_Temp->size[1] = 4;
      emxEnsureCapacity_int16_T(ROIBlockFaceSkin_Temp, i);
      Sum = d_NoPrevCallsBlock_ROIDetection * 4;
      for (i = 0; i < Sum; i++) {
        ROIBlockFaceSkin_Temp->data[i] = e_NoPrevCallsBlock_ROIDetection[i];
      }

      /* ROIAdjustIfExceedsFrameDims   Verify whether proposed widths and heights of ROIs exceed frame  */
      /*                               dimensions and, if so, modify them to conform to frame dimensions. */
      /*                                */
      /*     Helper function to function FacePulseRate. */
      /*     Within function FacePulseRate, called by functions ROIResize, ROIMeans_FirstRead_Extrapolate, */
      /*     SkinDetect_EnlargeROI, ROIMSIR, ROIMSIR_MatchSize, ROIMSIR_DetectionSmooth,   */
      /*     ROIMSIR_Interpolate, and ROIMSIR_FrameByFrameSmooth.    */
      /*  */
      /*  */
      /*     Code Generation */
      /*     --------------- */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /*  */
      /*  */
      /*     Description */
      /*     ----------- */
      /*  */
      /*     This function verifies that ROIs that have had modifications to their sizes are still within */
      /*     the dimensions of the frame. If not, this function adjusts the dimensions (and, consequently,   */
      /*     the spatial coordinates) to conform to the frame dimensions. */
      /*  */
      /*     Note:  */
      /*  */
      /*     Intended only for use with integer types as rounding is not conducted. For modification for  */
      /*     use with floating-point types, rounding would be necessary as ROI values should be integers. */
      /*  */
      /*  */
      /*     Copyright */
      /*     --------- */
      /*  */
      /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
      /*     the Responsible AI License (RAIL). */
      /* %%%%% Validate inputs %%%%%% */
      /* Exit if empty */
      if (d_NoPrevCallsBlock_ROIDetection != 0) {
        /* Validate whether input ROIsProposed is type int16. */
        /* Must be an integer type because no rounding is conducted. */
        /* Should be type int16 because the function is implemented to assign values of this type. */
        /* A non-matching type would be due to an implementation error. */
        /* %%%%% Running in code generation %%%%%% */
        /* When running in code generation, use for-loops. When running in Matlab code, use vectorization. */
        /* code generation running */
        /* Inline function */
        for (b_i = 0; b_i < d_NoPrevCallsBlock_ROIDetection; b_i++) {
          /* %%%%% --- Verify, and adjust if necessary, X-coordinates and widths %%%%%% */
          /* Adjust left-side X-coordinate if exceeds frame dimensions: */
          WidthNew_ith = ROIBlockFaceSkin_Temp->data[b_i];
          if (WidthNew_ith < 1) {
            WidthNew_ith = 1;

            /* recent code mod */
            ROIBlockFaceSkin_Temp->data[b_i] = 1;
          } else {
            if (WidthNew_ith > VidObjWidth) {
              WidthNew_ith = VidObjWidth;

              /* recent code mod */
              ROIBlockFaceSkin_Temp->data[b_i] = VidObjWidth;
            }
          }

          /* Adjust right-side X-coordinate if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(WidthNew_ith +
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 2])
                                - 1);
          if (Width_ith > VidObjWidth) {
            Width_ith = VidObjWidth;
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 2]
              = (int16_T)((int16_T)(VidObjWidth - WidthNew_ith) + 1);
          } else {
            if (Width_ith < 1) {
              Width_ith = 1;
              WidthNew_ith = 1;
              ROIBlockFaceSkin_Temp->data[b_i] = 1;
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                2] = 1;
            }
          }

          /* Adjust width if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(Width_ith - WidthNew_ith) + 1);
          if (Width_ith > VidObjWidth) {
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 2]
              = VidObjWidth;
          } else {
            if (Width_ith < 1) {
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                2] = 1;
            }
          }

          /* %%%%% --- Verify, and adjust if necessary, Y-coordinates and heights %%%%%% */
          /* Adjust top-side Y-coordinate if exceeds frame dimensions: */
          Height_ith = ROIBlockFaceSkin_Temp->data[b_i +
            ROIBlockFaceSkin_Temp->size[0]];
          if (Height_ith < 1) {
            Height_ith = 1;

            /* recent code mod */
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0]] =
              1;
          } else {
            if (Height_ith > VidObjHeight) {
              Height_ith = VidObjHeight;

              /* recent code mod */
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0]] =
                VidObjHeight;
            }
          }

          /* Adjust bottom-side Y-coordinate if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(Height_ith +
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 3])
                                - 1);
          if (Width_ith > VidObjHeight) {
            Width_ith = VidObjHeight;
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 3]
              = (int16_T)((int16_T)(VidObjHeight - Height_ith) + 1);
          } else {
            if (Width_ith < 1) {
              Width_ith = 1;
              Height_ith = 1;
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0]] =
                1;
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                3] = 1;
            }
          }

          /* Adjust height value if exceeds frame dimensions: */
          HeightNew_ith = (int16_T)((int16_T)(Width_ith - Height_ith) + 1);
          if (HeightNew_ith > VidObjHeight) {
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 3]
              = VidObjHeight;
          } else {
            if (HeightNew_ith < 1) {
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                3] = 1;
            }
          }
        }

        /* %%%%% Code generation not running %%%%%% */
      } else {
        /* Exit function */
      }

      /* end function */
      /* ============================================================================================= */
      /* Code-generation and build script */
      /* ============================================================================================= */
      /* Code-generation and build script used to generate C-language code and create the compiled version  */
      /* (ROIAdjustIfExceedsFrameDims_mex) of the function. */
      /* { */
      /*  */
      /* %%%%% Specify variable-size input arguments %%%%%% */
      /*  */
      /* See Matlab documentation for coder.typeof. */
      /*  */
      /*                                   Example Code               Upp. Bounds   Var. Size (T/F)  Type */
      /* ROIsProposedCode   = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],     [1, 0] );        %int16 */
      /*            */
      /*        */
      /* %%%%% Specify fixed-size input arguments %%%%%% */
      /*  */
      /* VidObjWidthCode  = int16(0);          */
      /* VidObjHeightCode = int16(0); */
      /*                    */
      /*  */
      /* %%%%% Set configurations to increase performance %%%%%% */
      /*  */
      /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
      /* "Optimization Strategies" */
      /*  */
      /* cfg = coder.config('mex'); */
      /* cfg.GlobalDataSyncMethod = 'NoSync'; */
      /* cfg.ConstantInputs = 'IgnoreValues'; */
      /* cfg.ExtrinsicCalls = true; %permit to show assert error */
      /* cfg.SaturateOnIntegerOverflow = false; */
      /* cfg.IntegrityChecks = false; */
      /* cfg.ResponsivenessChecks = false; */
      /*  */
      /*  */
      /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
      /*  */
      /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
      /*  */
      /* The flags are specified as part of the code-generation configuration object. A custom function, */
      /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
      /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
      /* Matlab guidance found in */
      /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
      /*  */
      /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
      /* a character vector prior to execution of the codegen command. */
      /*  */
      /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
      /*  */
      /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
      /* is not present in the base workspace. */
      /*  */
      /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
      /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
      /* character vector to maintain the charater vector, */
      /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
      /*  */
      /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
      /*  */
      /* Assign to code-generation configuration object */
      /* cfg.PostCodeGenCommand = setbuildargsAsText; */
      /*  */
      /*  */
      /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
      /*  */
      /* codegen ROIAdjustIfExceedsFrameDims.m -report -config cfg -args {ROIsProposedCode, VidObjWidthCode, VidObjHeightCode} */
      /*                  */
      /* } */
      d_NoPrevCallsBlock_ROIDetection = ROIBlockFaceSkin_Temp->size[0];
      Sum = ROIBlockFaceSkin_Temp->size[0] * ROIBlockFaceSkin_Temp->size[1];
      for (i = 0; i < Sum; i++) {
        e_NoPrevCallsBlock_ROIDetection[i] = ROIBlockFaceSkin_Temp->data[i];
      }

      /* %%%%% Output validation %%%%%% */
      /* First-read operations */
      /* Check whether any ROIs assigned in the current function equal zero. */
      /* The operations of this function were intended to prevent values of zero, so such a value is */
      /* likely due to an implementation error in this function.  */
      /* Loop across columns */
      for (b_i = 0; b_i < 4; b_i++) {
        /* Loop across ROIs rows that correspond to ROIs assigned in the current function */
        for (j = 0; j < NDetectionsFaceSkin_FR; j++) {
          if (ROINoPrevCallsBlock_FR[(f_ROIBlockDetectionFaceSkinLinI[j] + 229 *
               b_i) - 1] == 0) {
            /* Throw error  */
            /* Called as extrinsic so that stack trace can be displayed. */
            b_sprintf(VideoReadConfig_FrameIdx_FR->data[RowToReturnFullLinIdx_FR
                      - 1], r1);
            i = varargin_2->size[0] * varargin_2->size[1];
            varargin_2->size[0] = 1;
            varargin_2->size[1] = r1->size[1] + 248;
            emxEnsureCapacity_char_T(varargin_2, i);
            for (i = 0; i < 62; i++) {
              varargin_2->data[i] = cv21[i];
            }

            for (i = 0; i < 71; i++) {
              varargin_2->data[i + 62] = cv22[i];
            }

            for (i = 0; i < 44; i++) {
              varargin_2->data[i + 133] = cv23[i];
            }

            Sum = r1->size[1];
            for (i = 0; i < Sum; i++) {
              varargin_2->data[i + 177] = r1->data[i];
            }

            for (i = 0; i < 71; i++) {
              varargin_2->data[(i + r1->size[1]) + 177] = cv24[i];
            }

            error(emlrt_marshallOut(cv3), b_emlrt_marshallOut(varargin_2),
                  &j_emlrtMCI);
          }
        }
      }

      /* Check whether the ROI size is unreasonably small */
      /* Such a small size is likely due to an implementation error in this function. */
      /* This check is intended to be run when testing new implementations, as small ROI sizes are an */
      /* indication of a implementation error. As occassional values below 20 may be considered */
      /* acceptable, this check is not intended for use outside of testing. "Occassional" in this case    */
      /* might be defined as a few occurances out of 10,000. Flag ExpectedBehaviorTestTF enables the */
      /* check.     */
      if (ExpectedBehaviorTestTF) {
        i = x->size[0] * x->size[1];
        x->size[0] = d_ROIBlockDetectionFaceSkinLinI;
        x->size[1] = 2;
        emxEnsureCapacity_boolean_T(x, i);
        for (i = 0; i < d_ROIBlockDetectionFaceSkinLinI; i++) {
          x->data[i] = (ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i]
                        + 457] < 20);
        }

        for (i = 0; i < d_ROIBlockDetectionFaceSkinLinI; i++) {
          x->data[i + x->size[0]] =
            (ROINoPrevCallsBlock_FR[f_ROIBlockDetectionFaceSkinLinI[i] + 686] <
             20);
        }

        winNew = x->size[0] << 1;
        c_x = *x;
        d_VideoReadConfig_FrameIdx_FR[0] = winNew;
        c_x.size = &d_VideoReadConfig_FrameIdx_FR[0];
        c_x.numDimensions = 1;
        if (any(&c_x)) {
          /* Note: function warning() not available for code generation; so it must have previously */
          /* been declared as extrinsic. */
          /* Function fprintf can not be used as a substitute for warning() in this case because  */
          /* fprintf can not accept variable-length arguments. */
          /* Note: '%.0f' = floating point with no decimals.          */
          b_sprintf(VideoReadConfig_FrameIdx_FR->data[RowToReturnFullLinIdx_FR -
                    1], r1);
          i = varargin_2->size[0] * varargin_2->size[1];
          varargin_2->size[0] = 1;
          varargin_2->size[1] = r1->size[1] + 307;
          emxEnsureCapacity_char_T(varargin_2, i);
          for (i = 0; i < 72; i++) {
            varargin_2->data[i] = cv26[i];
          }

          for (i = 0; i < 74; i++) {
            varargin_2->data[i + 72] = cv27[i];
          }

          for (i = 0; i < 79; i++) {
            varargin_2->data[i + 146] = cv28[i];
          }

          for (i = 0; i < 11; i++) {
            varargin_2->data[i + 225] = cv29[i];
          }

          Sum = r1->size[1];
          for (i = 0; i < Sum; i++) {
            varargin_2->data[i + 236] = r1->data[i];
          }

          for (i = 0; i < 71; i++) {
            varargin_2->data[(i + r1->size[1]) + 236] = cv24[i];
          }

          warning(emlrt_marshallOut(cv3), b_emlrt_marshallOut(varargin_2),
                  &k_emlrtMCI);
        }
      }

      /* Second-read operations */
      /* end function */
      /* ============================================================================================= */
      /* Code-generation and build script */
      /* ============================================================================================= */
      /* Note: this function is not currently used as a compiled function as it is nested within a */
      /* compiled function, ROIMSIR_mex. */
      /* Code-generation and build script used to generate C-language code and create the compiled version  */
      /* (ROIMSIR_DetectionSmooth_mex) of the function. */
      /* { */
      /*             */
      /*       */
      /* %%%%% Specify variable-size input arguments %%%%%% */
      /*  */
      /* See Matlab documentation for coder.typeof. */
      /*  */
      /*                                                      Example Code                 Upp. Bounds  Var. Size (T/F)  Type */
      /* ROINoPrevCallsBlockCode               = coder.typeof( zeros(500, 4, 'int16'),      [inf, 4],    [1, 0] );        %int16 */
      /* ROIBlockDetectionFaceLogIdxCode       = coder.typeof( false(500, 1),               [inf, 1],    [1, 0] );        %logical */
      /* ROIBlockDetectionSkinLogIdxCode       = coder.typeof( false(500, 1),               [inf, 1],    [1, 0] );        %logical */
      /* ROIBlockDetectionFaceSkinLogIdxCode   = coder.typeof( false(500, 1),               [inf, 1],    [1, 0] );        %logical  */
      /* VideoReadConfig_FrameIdxCode          = coder.typeof( zeros(1, 500, 'int32'),      [1, inf],    [0, 1] );        %uint32  */
      /*                */
      /*     */
      /* %%%%% Specify fixed-size input arguments %%%%%% */
      /*  */
      /* VidObjWidthCode                              = int16(0);          */
      /* VidObjHeightCode                             = int16(0); */
      /* FirstReadTFCode                              = false; */
      /* SecondReadPostProcessingTFCode               = false; */
      /* RowToReturnFullLinIdxCode                    = int32(0); */
      /* FaceDetectConfig_ROIFaceSmoothingWindowCode  = double(0); */
      /* SkinDetectConfig_ROISkinSmoothingWindowCode  = double(0); */
      /*  */
      /*  */
      /* %%%%% Set configurations to increase performance %%%%%% */
      /*  */
      /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
      /* "Optimization Strategies" */
      /* cfg = coder.config('mex'); */
      /* cfg.GlobalDataSyncMethod = 'NoSync'; */
      /* cfg.ConstantInputs = 'IgnoreValues'; */
      /* cfg.ExtrinsicCalls = false; */
      /* cfg.SaturateOnIntegerOverflow = false; */
      /* cfg.IntegrityChecks = false; */
      /* cfg.ResponsivenessChecks = false; */
      /*  */
      /*  */
      /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
      /*  */
      /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
      /*  */
      /* The flags are specified as part of the code-generation configuration object. A custom function, */
      /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
      /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
      /* Matlab guidance found in */
      /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
      /*  */
      /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
      /* a character vector prior to execution of the codegen command. */
      /*  */
      /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
      /*  */
      /* Argument buildInfo: this variable is assign by the caller (the codegen command executed  */
      /* below) and is not present in the base workspace. */
      /*  */
      /* Second argument: specify a cell array of compiler-specific flags, where each flag is a  */
      /* character vector. As function setbuildargs will be evaluated from text, use double ' quotes for  */
      /* each character vector to maintain the charater vector, */
      /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
      /*  */
      /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
      /*  */
      /* Assign to code-generation configuration object */
      /* cfg.PostCodeGenCommand = setbuildargsAsText; */
      /*  */
      /*  */
      /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
      /*  */
      /* codegen ROIMSIR_DetectionSmooth.m -config cfg -args {ROINoPrevCallsBlockCode, ROIBlockDetectionFaceLogIdxCode, ROIBlockDetectionSkinLogIdxCode, ROIBlockDetectionFaceSkinLogIdxCode, VidObjWidthCode, VidObjHeightCode, FaceDetectConfig_ROIFaceSmoothingWindowCode, SkinDetectConfig_ROISkinSmoothingWindowCode, FirstReadTFCode, SecondReadPostProcessingTFCode, VideoReadConfig_FrameIdxCode, RowToReturnFullLinIdxCode} */
      /*               */
      /* } */
      /* Second-read operations         */
    } else {
      /* Note: during the second-read operations, the following arguments are entered but not used: */
      /* VideoReadConfig_FrameIdx_FR and RowToReturnFullLinIdx_FR. */
      /* Note: 0 was previously assigned to variable RowToReturnFullLinIdx_FR.      */
      /*  M x 4 matrix; type int16 */
      /*  N detections x 4 matrix; type int16 */
      /* ROIMSIR_DetectionSmooth   Smooth ROIs that correspond to face-detection and skin-detection     */
      /*                           algorithm detections to help remove the effect of false positives and to  */
      /*                           add stability.  */
      /*  */
      /*     Helper function to function FacePulseRate.  */
      /*     Within function FacePulseRate, called by function ROIMSIR. */
      /*  */
      /*  */
      /*     Code Generation */
      /*     --------------- */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /*  */
      /*  */
      /*     Description */
      /*     ----------- */
      /*  */
      /*     Smooth ROIs that correspond to face-detection and skin-detection algorithm detections to help   */
      /*     remove the effect of false positives and to add stability. False positives may be reduced    */
      /*     because they sometimes occur as outliers, and smoothing should reduce the effect of outliers.    */
      /*     Increasing stability across ROIs may help keep the ROI more oriented on the same area of the   */
      /*     face, which may help increase accuracy of pulse rate calculations. Smooth with a moving mean. */
      /*  */
      /*     The face-detection algorithm ROIs have been observed to be, on average, more accurate than the */
      /*     skin-detection algorithm ROIs, so the smoothing operations have been ordered to increase the  */
      /*     influence of face-detection ROIs. Specifically, the face-detection ROIs will be smoothed first */
      /*     without including skin-detection ROIs; this removes the influence of skin-detection ROIs on  */
      /*     the face-detection ROIs. Second, the skin-detection ROIs are smoothed with the face-detection  */
      /*     ROIs included so that the face-detection ROIs can influence the skin-detection ROIs. Any  */
      /*     face-detection ROIs smoothed in the second operation are not retained to remove the influence  */
      /*     of skin-detection ROIs on face-detection ROIs. */
      /*  */
      /*     All smoothing follows the following pattern: */
      /*  */
      /*     (1) A moving mean is used to smooth the height and width of each ROI. */
      /*     (2) The X- and Y-coordinates of each ROI are adjusted to correspond to the previous changes to   */
      /*         the height and width. */
      /*     (3) A moving mean is used to smooth the X- and Y-coordinates of each ROI. */
      /*  */
      /*  */
      /*     Copyright */
      /*     --------- */
      /*  */
      /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
      /*     the Responsible AI License (RAIL). */
      /* %%%%% Code generation settings %%%%%% */
      /* Inline function */
      /* Call function as extrinsic */
      /* See note where warning() is used. */
      /* Call function as extrinsic so that stack trace can be displayed */
      /* %%%%% Preallocate variables %%%%%% */
      i = c_NoPrevCallsBlock_ROIDetection->size[0] *
        c_NoPrevCallsBlock_ROIDetection->size[1];
      c_NoPrevCallsBlock_ROIDetection->size[0] = NDetectionsFaceSkin_SR;
      c_NoPrevCallsBlock_ROIDetection->size[1] = 4;
      emxEnsureCapacity_int16_T(c_NoPrevCallsBlock_ROIDetection, i);

      /* %%%%% Face-detection algorithm detection smoothing %%%%%% */
      /* Note: used during the first read or during the second read in the pre-processing (but not   */
      /* post-processing) step. */
      /* During the second read pre-processing step, size match ROIs near the beginning of the video that */
      /* were not size matched during the first read. The second read does not use the face-detection */
      /* algorithm, so size matching is not needed during the second read post-processing step. */
      /* Note: during the first read, calls by function ROIMeans_FirstRead; during the second read, calls  */
      /* by function ROIMeans_SecondRead.    */
      /*  first read */
      if ((!SecondReadPostProcessingTF) && (NDetectionsFace_SR > 1)) {
        /*    second read pre-processing step  */
        /* If more than one face-detection algorithm detection within block */
        /* No need to smooth if one or zero detections. */
        /* %%%%% --- Moving-mean smoothing on X- and Y-coordinates %%%%%%         */
        /* Smooth face-detection algorithm ROI X- and Y-coordinates with those of other  */
        /* face-detection algorithm ROIs. */
        /* The moving-mean smoothing window is specified by argument ROIFaceSmoothingWindow to */
        /* function FacePulseRate.  */
        /* M x 4 matrix; type int16. */
        /* Note: MovMean is a custom function located within folder 'FacePulseRate'. */
        /*  Smoothing window */
        /*  The number or rows of the input matrix */
        /*  The number or columns of the input */
        /*  matrix. */
        /* MovMean   Moving mean column-wise smoother. */
        /*  */
        /*     Helper function to function FacePulseRate.  */
        /*     Within function FacePulseRate, called by functions ROIMSIR_DetectionSmooth and */
        /*     ROIMSIR_FrameByFrameSmooth. */
        /*  */
        /*     Code generation:  */
        /*  */
        /*     Can be called as a Matlab function or used for C-language code generation. */
        /*  */
        /*     Description: */
        /*  */
        /*     Use a moving mean to conduct column-wise smoothing to a matrix. Weight rows corresponding to */
        /*     linear index WeightLinIdx by weight Weight. */
        /*  */
        /*     Inputs: */
        /*  */
        /*         ROI          = Matrix of values to be smoothed. M x :4 matrix; type int16.  */
        /*         Win          = Moving-mean window. Scalar; type double. */
        /*         NRowsROI     = The number of rows of the input matrix. Scalar; int32. */
        /*         NColsROI     = The number of columns of the input matrix. Scalar; int32. */
        /*  */
        /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
        /*     the Responsible AI License (RAIL). */
        /* Inline function */
        /* %%%%% Setup %%%%%% */
        /* Take half of window for use during operations */
        Idx = (int32_T)muDoubleScalarFloor(c_FaceDetectConfig_ROIFaceSmoot / 2.0)
          + 1;

        /* Make the full window equal twice the value of the half-window:  */
        winNew = ((Idx - 1) << 1) + 1;

        /* Assert maximum number of columns to prevent dynamic memory allocation by the colon operator */
        /* Preallocate output */
        i = SmoothedXYColumn->size[0] * SmoothedXYColumn->size[1];
        SmoothedXYColumn->size[0] = NDetectionsFace_SR;
        SmoothedXYColumn->size[1] = 2;
        emxEnsureCapacity_int16_T(SmoothedXYColumn, i);

        /* %%%%% Reduce size of window if window cannot move %%%%%% */
        if (NDetectionsFace_SR <= winNew) {
          /* Take one-fourth of window rather than one-half for use during operations */
          Idx = (int32_T)muDoubleScalarFloor(c_FaceDetectConfig_ROIFaceSmoot /
            4.0) + 1;

          /* Make the full window equal twice the value of the half-window:  */
          winNew = ((Idx - 1) << 1) + 1;
        }

        /* %%%%% If window still cannot move %%%%%% */
        if (NDetectionsFace_SR <= winNew) {
          /* Loop across columns */
          /* Initialize accumulator */
          Sum = 0;

          /* Sum rows across window           */
          for (j = 0; j < NDetectionsFace_SR; j++) {
            /* Element cast to type int32. */
            Sum += ROINoPrevCallsBlock_SR->data
              [ROIBlockDetectionFaceLinIdx_SR->data[j] - 1];
          }

          /* Take the mean */
          if (Sum >= 0) {
            d_x = (uint32_T)Sum;
          } else if (Sum == MIN_int32_T) {
            d_x = 2147483648U;
          } else {
            d_x = (uint32_T)-Sum;
          }

          q = d_x / NDetectionsFace_SR;
          d_x -= q * NDetectionsFace_SR;
          if ((d_x > 0U) && (d_x >= ((uint32_T)NDetectionsFace_SR >> 1U) +
                             (NDetectionsFace_SR & 1U))) {
            q++;
          }

          Idx = (int32_T)q;
          if (Sum < 0) {
            Idx = -(int32_T)q;
          }

          /* Assign the mean to all rows of column i */
          /* Initialize accumulator */
          Sum = 0;

          /* Sum rows across window           */
          for (j = 0; j < NDetectionsFace_SR; j++) {
            SmoothedXYColumn->data[j] = (int16_T)Idx;

            /* Element cast to type int32. */
            Sum += ROINoPrevCallsBlock_SR->data
              [(ROIBlockDetectionFaceLinIdx_SR->data[j] +
                ROINoPrevCallsBlock_SR->size[0]) - 1];
          }

          /* Take the mean */
          if (Sum >= 0) {
            d_x = (uint32_T)Sum;
          } else if (Sum == MIN_int32_T) {
            d_x = 2147483648U;
          } else {
            d_x = (uint32_T)-Sum;
          }

          q = d_x / NDetectionsFace_SR;
          d_x -= q * NDetectionsFace_SR;
          if ((d_x > 0U) && (d_x >= ((uint32_T)NDetectionsFace_SR >> 1U) +
                             (NDetectionsFace_SR & 1U))) {
            q++;
          }

          Idx = (int32_T)q;
          if (Sum < 0) {
            Idx = -(int32_T)q;
          }

          /* Assign the mean to all rows of column i */
          for (j = 0; j < NDetectionsFace_SR; j++) {
            SmoothedXYColumn->data[j + SmoothedXYColumn->size[0]] = (int16_T)Idx;
          }

          /* %%%%% If window can move %%%%%%     */
        } else {
          /* Loop across columns */
          i = Idx + 1;
          i1 = NDetectionsFace_SR - Idx;
          b_i = i1 + 2;

          /* Initialize */
          Sum = 0;

          /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
          /* Set intial window end index */
          /* Sum across truncated window           */
          for (j = 0; j < Idx; j++) {
            /* Cast to type int32 and add */
            Sum += ROINoPrevCallsBlock_SR->data
              [ROIBlockDetectionFaceLinIdx_SR->data[j] - 1];
          }

          /* Take mean */
          if (Idx == 0) {
            if (Sum == 0) {
              z = 0;
            } else if (Sum < 0) {
              z = MIN_int32_T;
            } else {
              z = MAX_int32_T;
            }
          } else if (Idx == 1) {
            z = Sum;
          } else if (Idx == -1) {
            z = -Sum;
          } else {
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            if (Idx >= 0) {
              b_y = (uint32_T)Idx;
            } else if (Idx == MIN_int32_T) {
              b_y = 2147483648U;
            } else {
              b_y = (uint32_T)-Idx;
            }

            if (b_y == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / b_y;
            }

            d_x -= q * b_y;
            if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
              q++;
            }

            z = (int32_T)q;
            if ((Sum < 0) != (Idx < 0)) {
              z = -(int32_T)q;
            }
          }

          SmoothedXYColumn->data[0] = (int16_T)z;

          /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
          /* Set initial truncated window length */
          n = Idx;

          /* Loop across rows */
          for (j = 2; j <= Idx; j++) {
            /* Set window end index for jth row */
            /* Add value at end of current window */
            /* Element cast to type int32. */
            Sum += ROINoPrevCallsBlock_SR->data
              [ROIBlockDetectionFaceLinIdx_SR->data[(j + Idx) - 2] - 1];

            /* Take mean:                 */
            n++;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
          /* Loop across rows */
          for (j = i; j <= i1 + 1; j++) {
            /* Set window start index for jth row */
            Start = (j - Idx) + 1;

            /* Set window end index for jth row */
            /* Subtract value at start of previous window.  */
            /* Then, add value at end of current window. */
            /* Element cast to type int32. */
            Sum = (Sum - ROINoPrevCallsBlock_SR->
                   data[ROIBlockDetectionFaceLinIdx_SR->data[Start - 2] - 1]) +
              ROINoPrevCallsBlock_SR->data[ROIBlockDetectionFaceLinIdx_SR->data
              [(j + Idx) - 2] - 1];

            /* Take mean */
            if (winNew == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (winNew == 1) {
              z = Sum;
            } else if (winNew == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (winNew >= 0) {
                b_y = (uint32_T)winNew;
              } else if (winNew == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-winNew;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (winNew < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
          /* Set intial window length */
          n = winNew;
          Start -= 2;
          for (j = b_i; j <= NDetectionsFace_SR; j++) {
            Start++;

            /* Subtract value at start of previous window */
            /* Element cast to type int32. */
            Sum -= ROINoPrevCallsBlock_SR->data
              [ROIBlockDetectionFaceLinIdx_SR->data[Start - 1] - 1];

            /* Take mean:        */
            n--;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* Initialize */
          Sum = 0;

          /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
          /* Set intial window end index */
          /* Sum across truncated window           */
          for (j = 0; j < Idx; j++) {
            /* Cast to type int32 and add */
            Sum += ROINoPrevCallsBlock_SR->data
              [(ROIBlockDetectionFaceLinIdx_SR->data[j] +
                ROINoPrevCallsBlock_SR->size[0]) - 1];
          }

          /* Take mean */
          if (Idx == 0) {
            if (Sum == 0) {
              z = 0;
            } else if (Sum < 0) {
              z = MIN_int32_T;
            } else {
              z = MAX_int32_T;
            }
          } else if (Idx == 1) {
            z = Sum;
          } else if (Idx == -1) {
            z = -Sum;
          } else {
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            if (Idx >= 0) {
              b_y = (uint32_T)Idx;
            } else if (Idx == MIN_int32_T) {
              b_y = 2147483648U;
            } else {
              b_y = (uint32_T)-Idx;
            }

            if (b_y == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / b_y;
            }

            d_x -= q * b_y;
            if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
              q++;
            }

            z = (int32_T)q;
            if ((Sum < 0) != (Idx < 0)) {
              z = -(int32_T)q;
            }
          }

          SmoothedXYColumn->data[SmoothedXYColumn->size[0]] = (int16_T)z;

          /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
          /* Set initial truncated window length */
          n = Idx;

          /* Loop across rows */
          for (j = 2; j <= Idx; j++) {
            /* Set window end index for jth row */
            /* Add value at end of current window */
            /* Element cast to type int32. */
            Sum += ROINoPrevCallsBlock_SR->data
              [(ROIBlockDetectionFaceLinIdx_SR->data[(j + Idx) - 2] +
                ROINoPrevCallsBlock_SR->size[0]) - 1];

            /* Take mean:                 */
            n++;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
          /* Loop across rows */
          for (j = i; j <= i1 + 1; j++) {
            /* Set window start index for jth row */
            Start = (j - Idx) + 1;

            /* Set window end index for jth row */
            /* Subtract value at start of previous window.  */
            /* Then, add value at end of current window. */
            /* Element cast to type int32. */
            Sum = (Sum - ROINoPrevCallsBlock_SR->data
                   [(ROIBlockDetectionFaceLinIdx_SR->data[Start - 2] +
                     ROINoPrevCallsBlock_SR->size[0]) - 1]) +
              ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionFaceLinIdx_SR->
              data[(j + Idx) - 2] + ROINoPrevCallsBlock_SR->size[0]) - 1];

            /* Take mean */
            if (winNew == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (winNew == 1) {
              z = Sum;
            } else if (winNew == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (winNew >= 0) {
                b_y = (uint32_T)winNew;
              } else if (winNew == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-winNew;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (winNew < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
          /* Set intial window length */
          n = winNew;
          Start -= 2;
          for (j = b_i; j <= NDetectionsFace_SR; j++) {
            Start++;

            /* Subtract value at start of previous window */
            /* Element cast to type int32. */
            Sum -= ROINoPrevCallsBlock_SR->data
              [(ROIBlockDetectionFaceLinIdx_SR->data[Start - 1] +
                ROINoPrevCallsBlock_SR->size[0]) - 1];

            /* Take mean:        */
            n--;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }
        }

        /* end function */
        /* ============================================================================================= */
        /* Code-generation and build script */
        /* ============================================================================================= */
        /* Code-generation and build script used to generate C-language code and create the compiled version  */
        /* (MovMean_mex) of the function. */
        /* { */
        /*  */
        /* %%%%% Specify variable-size input arguments %%%%%% */
        /*  */
        /* See Matlab documentation for coder.typeof. */
        /*                         Example Code               Upp. Bounds   Var. Size (T/F)  Type */
        /* ROICode  = coder.typeof( zeros(50, 2, 'int16'),     [500, 2],      [1, 0] );        %int16 */
        /*  */
        /*  */
        /* %%%%% Specify fixed-size input arguments %%%%%% */
        /*  */
        /* winCode = double(0); */
        /* NRowsROI = int32(0); */
        /* NColsROI = int32(0);          */
        /*     */
        /* %%%%% Set configurations to increase performance %%%%%% */
        /*  */
        /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
        /* "Optimization Strategies" */
        /* cfg = coder.config('mex'); */
        /* cfg.GlobalDataSyncMethod = 'NoSync'; */
        /* cfg.ConstantInputs = 'IgnoreValues'; */
        /* cfg.ExtrinsicCalls = false; */
        /* cfg.SaturateOnIntegerOverflow = false; */
        /* cfg.IntegrityChecks = false; */
        /* cfg.ResponsivenessChecks = false; */
        /*  */
        /*  */
        /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
        /*  */
        /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
        /*  */
        /* The flags are specified as part of the code-generation configuration object. A custom function, */
        /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
        /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
        /* Matlab guidance found in */
        /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
        /*  */
        /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
        /* a character vector prior to execution of the codegen command. */
        /*  */
        /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
        /*  */
        /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
        /* is not present in the base workspace. */
        /*  */
        /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
        /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each  */
        /* character vector to maintain the charater vector, */
        /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
        /*  */
        /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
        /*  */
        /* Assign to code-generation configuration object */
        /* cfg.PostCodeGenCommand = setbuildargsAsText; */
        /*  */
        /*  */
        /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
        /*  */
        /* codegen MovMean.m -report -config cfg -args {ROICode, winCode, NRowsROI, NColsROI} */
        /*   */
        /* } */
        /* %%%%% --- Moving-mean smoothing on widths and heights %%%%%% */
        /* Assign unsmoothed widths and heights for later step */
        /* Only extract ROIs corresponding to a face-detection algorithm detection. */
        /* N detections x 2 matrix; type int16.               */
        i = ROIWidthHeightPreSmooth->size[0] * ROIWidthHeightPreSmooth->size[1];
        ROIWidthHeightPreSmooth->size[0] = ROIBlockDetectionFaceLinIdx_SR->size
          [0];
        ROIWidthHeightPreSmooth->size[1] = 2;
        emxEnsureCapacity_int16_T(ROIWidthHeightPreSmooth, i);
        Sum = SmoothedXYColumn->size[0];
        Idx = ROIBlockDetectionFaceLinIdx_SR->size[0];
        for (i = 0; i < Sum; i++) {
          ROINoPrevCallsBlock_SR->data[ROIBlockDetectionFaceLinIdx_SR->data[i] -
            1] = SmoothedXYColumn->data[i];
        }

        for (i = 0; i < Idx; i++) {
          ROIWidthHeightPreSmooth->data[i] = ROINoPrevCallsBlock_SR->data
            [(ROIBlockDetectionFaceLinIdx_SR->data[i] +
              ROINoPrevCallsBlock_SR->size[0] * 2) - 1];
        }

        for (i = 0; i < Sum; i++) {
          ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionFaceLinIdx_SR->data[i]
            + ROINoPrevCallsBlock_SR->size[0]) - 1] = SmoothedXYColumn->data[i +
            SmoothedXYColumn->size[0]];
        }

        for (i = 0; i < Idx; i++) {
          ROIWidthHeightPreSmooth->data[i + ROIWidthHeightPreSmooth->size[0]] =
            ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionFaceLinIdx_SR->data[i]
            + ROINoPrevCallsBlock_SR->size[0] * 3) - 1];
        }

        /* Smooth face-detection algorithm ROI widths and heights with those of other face-detection  */
        /* algorithm ROIs. */
        /* The moving-mean smoothing window is relatively large to increase stability of ROI size */
        /* across frames. */
        /* M x 4 matrix; type int16. */
        /* Note: MovMean is a custom function located within folder 'FacePulseRate'. */
        /*  smoothing window */
        /*  the number or rows of the input matrix */
        /*  the number or columns of the input matrix */
        /* MovMean   Moving mean column-wise smoother. */
        /*  */
        /*     Helper function to function FacePulseRate.  */
        /*     Within function FacePulseRate, called by functions ROIMSIR_DetectionSmooth and */
        /*     ROIMSIR_FrameByFrameSmooth. */
        /*  */
        /*     Code generation:  */
        /*  */
        /*     Can be called as a Matlab function or used for C-language code generation. */
        /*  */
        /*     Description: */
        /*  */
        /*     Use a moving mean to conduct column-wise smoothing to a matrix. Weight rows corresponding to */
        /*     linear index WeightLinIdx by weight Weight. */
        /*  */
        /*     Inputs: */
        /*  */
        /*         ROI          = Matrix of values to be smoothed. M x :4 matrix; type int16.  */
        /*         Win          = Moving-mean window. Scalar; type double. */
        /*         NRowsROI     = The number of rows of the input matrix. Scalar; int32. */
        /*         NColsROI     = The number of columns of the input matrix. Scalar; int32. */
        /*  */
        /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
        /*     the Responsible AI License (RAIL). */
        /* Inline function */
        /* %%%%% Setup %%%%%% */
        /* Take half of window for use during operations */
        Idx = 16;

        /* Make the full window equal twice the value of the half-window:  */
        winNew = 31;

        /* Assert maximum number of columns to prevent dynamic memory allocation by the colon operator */
        /* Preallocate output */
        i = SmoothedXYColumn->size[0] * SmoothedXYColumn->size[1];
        SmoothedXYColumn->size[0] = NDetectionsFace_SR;
        SmoothedXYColumn->size[1] = 2;
        emxEnsureCapacity_int16_T(SmoothedXYColumn, i);

        /* %%%%% Reduce size of window if window cannot move %%%%%% */
        if (NDetectionsFace_SR <= 31) {
          /* Take one-fourth of window rather than one-half for use during operations */
          Idx = 8;

          /* Make the full window equal twice the value of the half-window:  */
          winNew = 15;
        }

        /* %%%%% If window still cannot move %%%%%% */
        if (NDetectionsFace_SR <= winNew) {
          /* Loop across columns */
          /* Initialize accumulator */
          Sum = 0;

          /* Sum rows across window           */
          for (j = 0; j < NDetectionsFace_SR; j++) {
            /* Element cast to type int32. */
            Sum += ROINoPrevCallsBlock_SR->data
              [(ROIBlockDetectionFaceLinIdx_SR->data[j] +
                ROINoPrevCallsBlock_SR->size[0] * 2) - 1];
          }

          /* Take the mean */
          if (Sum >= 0) {
            d_x = (uint32_T)Sum;
          } else if (Sum == MIN_int32_T) {
            d_x = 2147483648U;
          } else {
            d_x = (uint32_T)-Sum;
          }

          q = d_x / NDetectionsFace_SR;
          d_x -= q * NDetectionsFace_SR;
          if ((d_x > 0U) && (d_x >= ((uint32_T)NDetectionsFace_SR >> 1U) +
                             (NDetectionsFace_SR & 1U))) {
            q++;
          }

          Idx = (int32_T)q;
          if (Sum < 0) {
            Idx = -(int32_T)q;
          }

          /* Assign the mean to all rows of column i */
          /* Initialize accumulator */
          Sum = 0;

          /* Sum rows across window           */
          for (j = 0; j < NDetectionsFace_SR; j++) {
            SmoothedXYColumn->data[j] = (int16_T)Idx;

            /* Element cast to type int32. */
            Sum += ROINoPrevCallsBlock_SR->data
              [(ROIBlockDetectionFaceLinIdx_SR->data[j] +
                ROINoPrevCallsBlock_SR->size[0] * 3) - 1];
          }

          /* Take the mean */
          if (Sum >= 0) {
            d_x = (uint32_T)Sum;
          } else if (Sum == MIN_int32_T) {
            d_x = 2147483648U;
          } else {
            d_x = (uint32_T)-Sum;
          }

          q = d_x / NDetectionsFace_SR;
          d_x -= q * NDetectionsFace_SR;
          if ((d_x > 0U) && (d_x >= ((uint32_T)NDetectionsFace_SR >> 1U) +
                             (NDetectionsFace_SR & 1U))) {
            q++;
          }

          Idx = (int32_T)q;
          if (Sum < 0) {
            Idx = -(int32_T)q;
          }

          /* Assign the mean to all rows of column i */
          for (j = 0; j < NDetectionsFace_SR; j++) {
            SmoothedXYColumn->data[j + SmoothedXYColumn->size[0]] = (int16_T)Idx;
          }

          /* %%%%% If window can move %%%%%%     */
        } else {
          /* Loop across columns */
          i = Idx + 1;
          i1 = NDetectionsFace_SR - Idx;
          b_i = i1 + 2;

          /* Initialize */
          Sum = 0;

          /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
          /* Set intial window end index */
          /* Sum across truncated window           */
          for (j = 0; j < Idx; j++) {
            /* Cast to type int32 and add */
            Sum += ROINoPrevCallsBlock_SR->data
              [(ROIBlockDetectionFaceLinIdx_SR->data[j] +
                ROINoPrevCallsBlock_SR->size[0] * 2) - 1];
          }

          /* Take mean */
          if (Sum >= 0) {
            d_x = (uint32_T)Sum;
          } else if (Sum == MIN_int32_T) {
            d_x = 2147483648U;
          } else {
            d_x = (uint32_T)-Sum;
          }

          q = d_x / Idx;
          d_x -= q * Idx;
          if ((d_x > 0U) && (d_x >= ((uint32_T)Idx >> 1U) + (Idx & 1U))) {
            q++;
          }

          z = (int32_T)q;
          if (Sum < 0) {
            z = -(int32_T)q;
          }

          SmoothedXYColumn->data[0] = (int16_T)z;

          /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
          /* Set initial truncated window length */
          n = Idx;

          /* Loop across rows */
          for (j = 2; j <= Idx; j++) {
            /* Set window end index for jth row */
            /* Add value at end of current window */
            /* Element cast to type int32. */
            Sum += ROINoPrevCallsBlock_SR->data
              [(ROIBlockDetectionFaceLinIdx_SR->data[(j + Idx) - 2] +
                ROINoPrevCallsBlock_SR->size[0] * 2) - 1];

            /* Take mean:                 */
            n++;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
          /* Loop across rows */
          for (j = i; j <= i1 + 1; j++) {
            /* Set window start index for jth row */
            Start = (j - Idx) + 1;

            /* Set window end index for jth row */
            /* Subtract value at start of previous window.  */
            /* Then, add value at end of current window. */
            /* Element cast to type int32. */
            Sum = (Sum - ROINoPrevCallsBlock_SR->data
                   [(ROIBlockDetectionFaceLinIdx_SR->data[Start - 2] +
                     ROINoPrevCallsBlock_SR->size[0] * 2) - 1]) +
              ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionFaceLinIdx_SR->
              data[(j + Idx) - 2] + ROINoPrevCallsBlock_SR->size[0] * 2) - 1];

            /* Take mean */
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            q = d_x / winNew;
            d_x -= q * winNew;
            if ((d_x > 0U) && (d_x >= ((uint32_T)winNew >> 1U) + (winNew & 1U)))
            {
              q++;
            }

            z = (int32_T)q;
            if (Sum < 0) {
              z = -(int32_T)q;
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
          /* Set intial window length */
          n = winNew;
          Start -= 2;
          for (j = b_i; j <= NDetectionsFace_SR; j++) {
            Start++;

            /* Subtract value at start of previous window */
            /* Element cast to type int32. */
            Sum -= ROINoPrevCallsBlock_SR->data
              [(ROIBlockDetectionFaceLinIdx_SR->data[Start - 1] +
                ROINoPrevCallsBlock_SR->size[0] * 2) - 1];

            /* Take mean:        */
            n--;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* Initialize */
          Sum = 0;

          /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
          /* Set intial window end index */
          /* Sum across truncated window           */
          for (j = 0; j < Idx; j++) {
            /* Cast to type int32 and add */
            Sum += ROINoPrevCallsBlock_SR->data
              [(ROIBlockDetectionFaceLinIdx_SR->data[j] +
                ROINoPrevCallsBlock_SR->size[0] * 3) - 1];
          }

          /* Take mean */
          if (Sum >= 0) {
            d_x = (uint32_T)Sum;
          } else if (Sum == MIN_int32_T) {
            d_x = 2147483648U;
          } else {
            d_x = (uint32_T)-Sum;
          }

          q = d_x / Idx;
          d_x -= q * Idx;
          if ((d_x > 0U) && (d_x >= ((uint32_T)Idx >> 1U) + (Idx & 1U))) {
            q++;
          }

          z = (int32_T)q;
          if (Sum < 0) {
            z = -(int32_T)q;
          }

          SmoothedXYColumn->data[SmoothedXYColumn->size[0]] = (int16_T)z;

          /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
          /* Set initial truncated window length */
          n = Idx;

          /* Loop across rows */
          for (j = 2; j <= Idx; j++) {
            /* Set window end index for jth row */
            /* Add value at end of current window */
            /* Element cast to type int32. */
            Sum += ROINoPrevCallsBlock_SR->data
              [(ROIBlockDetectionFaceLinIdx_SR->data[(j + Idx) - 2] +
                ROINoPrevCallsBlock_SR->size[0] * 3) - 1];

            /* Take mean:                 */
            n++;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
          /* Loop across rows */
          for (j = i; j <= i1 + 1; j++) {
            /* Set window start index for jth row */
            Start = (j - Idx) + 1;

            /* Set window end index for jth row */
            /* Subtract value at start of previous window.  */
            /* Then, add value at end of current window. */
            /* Element cast to type int32. */
            Sum = (Sum - ROINoPrevCallsBlock_SR->data
                   [(ROIBlockDetectionFaceLinIdx_SR->data[Start - 2] +
                     ROINoPrevCallsBlock_SR->size[0] * 3) - 1]) +
              ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionFaceLinIdx_SR->
              data[(j + Idx) - 2] + ROINoPrevCallsBlock_SR->size[0] * 3) - 1];

            /* Take mean */
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            q = d_x / winNew;
            d_x -= q * winNew;
            if ((d_x > 0U) && (d_x >= ((uint32_T)winNew >> 1U) + (winNew & 1U)))
            {
              q++;
            }

            z = (int32_T)q;
            if (Sum < 0) {
              z = -(int32_T)q;
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
          /* Set intial window length */
          n = winNew;
          Start -= 2;
          for (j = b_i; j <= NDetectionsFace_SR; j++) {
            Start++;

            /* Subtract value at start of previous window */
            /* Element cast to type int32. */
            Sum -= ROINoPrevCallsBlock_SR->data
              [(ROIBlockDetectionFaceLinIdx_SR->data[Start - 1] +
                ROINoPrevCallsBlock_SR->size[0] * 3) - 1];

            /* Take mean:        */
            n--;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }
        }

        /* end function */
        /* ============================================================================================= */
        /* Code-generation and build script */
        /* ============================================================================================= */
        /* Code-generation and build script used to generate C-language code and create the compiled version  */
        /* (MovMean_mex) of the function. */
        /* { */
        /*  */
        /* %%%%% Specify variable-size input arguments %%%%%% */
        /*  */
        /* See Matlab documentation for coder.typeof. */
        /*                         Example Code               Upp. Bounds   Var. Size (T/F)  Type */
        /* ROICode  = coder.typeof( zeros(50, 2, 'int16'),     [500, 2],      [1, 0] );        %int16 */
        /*  */
        /*  */
        /* %%%%% Specify fixed-size input arguments %%%%%% */
        /*  */
        /* winCode = double(0); */
        /* NRowsROI = int32(0); */
        /* NColsROI = int32(0);          */
        /*     */
        /* %%%%% Set configurations to increase performance %%%%%% */
        /*  */
        /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
        /* "Optimization Strategies" */
        /* cfg = coder.config('mex'); */
        /* cfg.GlobalDataSyncMethod = 'NoSync'; */
        /* cfg.ConstantInputs = 'IgnoreValues'; */
        /* cfg.ExtrinsicCalls = false; */
        /* cfg.SaturateOnIntegerOverflow = false; */
        /* cfg.IntegrityChecks = false; */
        /* cfg.ResponsivenessChecks = false; */
        /*  */
        /*  */
        /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
        /*  */
        /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
        /*  */
        /* The flags are specified as part of the code-generation configuration object. A custom function, */
        /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
        /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
        /* Matlab guidance found in */
        /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
        /*  */
        /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
        /* a character vector prior to execution of the codegen command. */
        /*  */
        /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
        /*  */
        /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
        /* is not present in the base workspace. */
        /*  */
        /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
        /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each  */
        /* character vector to maintain the charater vector, */
        /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
        /*  */
        /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
        /*  */
        /* Assign to code-generation configuration object */
        /* cfg.PostCodeGenCommand = setbuildargsAsText; */
        /*  */
        /*  */
        /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
        /*  */
        /* codegen MovMean.m -report -config cfg -args {ROICode, winCode, NRowsROI, NColsROI} */
        /*   */
        /* } */
        Sum = SmoothedXYColumn->size[0];
        for (i = 0; i < Sum; i++) {
          ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionFaceLinIdx_SR->data[i]
            + ROINoPrevCallsBlock_SR->size[0] * 2) - 1] = SmoothedXYColumn->
            data[i];
        }

        for (i = 0; i < Sum; i++) {
          ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionFaceLinIdx_SR->data[i]
            + ROINoPrevCallsBlock_SR->size[0] * 3) - 1] = SmoothedXYColumn->
            data[i + SmoothedXYColumn->size[0]];
        }

        /* %%%%% --- Adjust X- and Y-coordinates to correspond to adjustments in widths and heights %%%%%% */
        /* Loop across ROIs corresponding to face-detection algorithm detections */
        for (b_i = 0; b_i < NDetectionsFace_SR; b_i++) {
          /* Extract index corresponding to detection  */
          /* Half of difference between unmatched widths and height and adjusted widths and  */
          /* heights. */
          /* Optimize division by two by bit-wise operation. */
          /* Add the half-differences to the X- and Y-coordinates */
          /* M x 4 matrix (229 x 4 during first-read operations); type int16. */
          /* Note: if there were negative differences, the half-differences will be subtracted from   */
          /* the X- and Y-coordinates. */
          ROINoPrevCallsBlock_SR->data[ROIBlockDetectionFaceLinIdx_SR->data[b_i]
            - 1] = (int16_T)(ROINoPrevCallsBlock_SR->
                             data[ROIBlockDetectionFaceLinIdx_SR->data[b_i] - 1]
                             + ((int16_T)(ROIWidthHeightPreSmooth->data[b_i] -
            ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionFaceLinIdx_SR->
            data[b_i] + ROINoPrevCallsBlock_SR->size[0] * 2) - 1]) >> 1));
          ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionFaceLinIdx_SR->data[b_i]
            + ROINoPrevCallsBlock_SR->size[0]) - 1] = (int16_T)
            (ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionFaceLinIdx_SR->
              data[b_i] + ROINoPrevCallsBlock_SR->size[0]) - 1] + ((int16_T)
              (ROIWidthHeightPreSmooth->data[b_i + ROIWidthHeightPreSmooth->
               size[0]] - ROINoPrevCallsBlock_SR->data
               [(ROIBlockDetectionFaceLinIdx_SR->data[b_i] +
                 ROINoPrevCallsBlock_SR->size[0] * 3) - 1]) >> 1));
        }
      }

      /* %%%%% Skin-detection algorithm detection smoothing %%%%%% */
      /* Note: used during all calls: during the first-read operations and during both the pre-processing */
      /* and post-processing steps of the second-read operations. */
      /* During the second-read pre-processing step, smooth skin-detection ROIs near the beginning of the  */
      /* video that were smoothed during the first read. During the second-read post-processing step, */
      /* smooth skin-detection ROIs near the beginning of the video based on recent skin-detection */
      /* algorithm ROI detections. */
      /* Don't need to smooth if no ROIs correspond to skin-detections. */
      FaceOrSkinTF = (NDetectionsSkin_SR > 0);
      if (FaceOrSkinTF) {
        /* Only apply smoothing in this section to the skin-detection algorithm ROIs as the   */
        /* face-detection algorithm ROIs have already been smoothed. In order to use the ROIs from the  */
        /* face-detection algorithms as information in the smoothing, include ROIs from the  */
        /* face-detection algorithm; however, after smoothing, only retain the smoothed skin-detection  */
        /* ROIs so that the face-detection ROIs don't retain this additional smoothing. To do so, store  */
        /* the smoothed ROIs to a temporary variable and then extract only the skin-detection ROIs. */
        /* %%%%% --- Find positions of skin detections in detection-only ROI matrix %%%%%% */
        /* Find the positions in ROIBlockDetectionFaceSkinLinIdx where ROIBlockDetectionSkinLinIdx  */
        /* matches ROIBlockDetectionFaceSkinLinIdx. In other words, where in vector */
        /* ROIBlockDetectionFaceSkinLinIdx are the skin detections located. This index is used in a  */
        /* couple sections that follow.  */
        /* Column vector; int32. */
        /* Note: PositionsIn is a custom function located within folder 'FacePulseRate'. */
        /*  set A */
        /*  set B */
        /*  length of set A */
        /* PositionsIn   Return the index indicating where elements in set A are positioned in set B.  */
        /*  */
        /*     Helper function to function FacePulseRate.  */
        /*     Within function FacePulseRate, called by functions ROIMSIR_DetectionSmooth and  */
        /*     ROIMSIR_FaceDetectionLightSmooth. */
        /*  */
        /*     Code generation:  */
        /*  */
        /*     Can be called as a Matlab function or used for C-language code generation. */
        /*  */
        /*     Description: */
        /*  */
        /*     Return the index indicating where elements in set A are positioned in set B. Various  */
        /*     assumptions are made to increase efficiency.  */
        /*  */
        /*         Assumptions */
        /*     */
        /*     - Elements of set A are entirely nested within set B. */
        /*     - Within each set, values do not repeat and are ordered such that they increase monotonically. */
        /*  */
        /*     Example: */
        /*  */
        /*     A = [4, 5, 6]; */
        /*     B = [2, 3, 4, 5, 6]; */
        /*     A_Length = numel(A); */
        /*  */
        /*     PositionsIn(A, B, A_Length) */
        /*     >> [3; 4; 5] */
        /*  */
        /*     Note: */
        /*  */
        /*     The return values are equivalent to those returned by int32( find( ismember(B, A) )' ); */
        /* Inline function */
        /* Index of B on a given iteration */
        winNew = 0;

        /* Preallocate output */
        i = SkinIdxFit->size[0];
        SkinIdxFit->size[0] = NDetectionsSkin_SR;
        emxEnsureCapacity_int32_T(SkinIdxFit, i);

        /* Loop across elements of A */
        for (b_i = 0; b_i < NDetectionsSkin_SR; b_i++) {
          do {
            winNew++;
          } while (!(ROIBlockDetectionSkinLinIdx_SR->data[b_i] ==
                     c_ROIBlockDetectionFaceSkinLinI->data[winNew - 1]));

          /* Position (index) of ith index of A in B. */
          SkinIdxFit->data[b_i] = winNew;
        }

        /* end function */
        /* %%%%% --- Assign temporary ROI matrix %%%%%% */
        /* Assign temporary ROI matrix that consists of ROIs that correspond to face or skin detections. */
        /* Rows of the matrix that correspond to face detections will be discarded at the end of   */
        /* skin-detection smoothing procedure.  */
        /* Preallocate:  */
        /* N face-or-skin detections x 4 matrix; type int16. */
        i = ROIBlockFaceSkin_Temp->size[0] * ROIBlockFaceSkin_Temp->size[1];
        ROIBlockFaceSkin_Temp->size[0] = NDetectionsFaceSkin_SR;
        ROIBlockFaceSkin_Temp->size[1] = 4;
        emxEnsureCapacity_int16_T(ROIBlockFaceSkin_Temp, i);

        /* Assign ROIs that correspond to face or skin detections:    */
        /* Loop across columns */
        /* Loop across rows */
        for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
          ROIBlockFaceSkin_Temp->data[j] = ROINoPrevCallsBlock_SR->
            data[c_ROIBlockDetectionFaceSkinLinI->data[j] - 1];
        }

        /* Loop across rows */
        for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
          ROIBlockFaceSkin_Temp->data[j + ROIBlockFaceSkin_Temp->size[0]] =
            ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->
            data[j] + ROINoPrevCallsBlock_SR->size[0]) - 1];
        }

        /* Loop across rows */
        for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
          ROIBlockFaceSkin_Temp->data[j + ROIBlockFaceSkin_Temp->size[0] * 2] =
            ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->
            data[j] + ROINoPrevCallsBlock_SR->size[0] * 2) - 1];
        }

        /* Loop across rows */
        for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
          ROIBlockFaceSkin_Temp->data[j + ROIBlockFaceSkin_Temp->size[0] * 3] =
            ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->
            data[j] + ROINoPrevCallsBlock_SR->size[0] * 3) - 1];
        }

        /* %%%%% --- Moving-mean smoothing on widths and heights %%%%%%     */
        /* Smooth with face-detection and/or skin-detection algorithm ROI widths and heights with those   */
        /* of other face-detection and/or skin-detection algorithm ROIs. As mentioned previously, any  */
        /* smoothing on ROIs that correspond to face detections will be discarded later. */
        /* The moving-mean smoothing window is relatively large to increase stability of ROI size across */
        /* frames. */
        /* Note: MovMean is a custom function located within folder 'FacePulseRate'. */
        /*  smoothing window */
        /*  the number of rows of the input matrix */
        /*  the number of columns of the input matrix */
        /* MovMean   Moving mean column-wise smoother. */
        /*  */
        /*     Helper function to function FacePulseRate.  */
        /*     Within function FacePulseRate, called by functions ROIMSIR_DetectionSmooth and */
        /*     ROIMSIR_FrameByFrameSmooth. */
        /*  */
        /*     Code generation:  */
        /*  */
        /*     Can be called as a Matlab function or used for C-language code generation. */
        /*  */
        /*     Description: */
        /*  */
        /*     Use a moving mean to conduct column-wise smoothing to a matrix. Weight rows corresponding to */
        /*     linear index WeightLinIdx by weight Weight. */
        /*  */
        /*     Inputs: */
        /*  */
        /*         ROI          = Matrix of values to be smoothed. M x :4 matrix; type int16.  */
        /*         Win          = Moving-mean window. Scalar; type double. */
        /*         NRowsROI     = The number of rows of the input matrix. Scalar; int32. */
        /*         NColsROI     = The number of columns of the input matrix. Scalar; int32. */
        /*  */
        /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
        /*     the Responsible AI License (RAIL). */
        /* Inline function */
        /* %%%%% Setup %%%%%% */
        /* Take half of window for use during operations */
        Idx = 16;

        /* Make the full window equal twice the value of the half-window:  */
        winNew = 31;

        /* Assert maximum number of columns to prevent dynamic memory allocation by the colon operator */
        /* Preallocate output */
        i = SmoothedXYColumn->size[0] * SmoothedXYColumn->size[1];
        SmoothedXYColumn->size[0] = NDetectionsFaceSkin_SR;
        SmoothedXYColumn->size[1] = 2;
        emxEnsureCapacity_int16_T(SmoothedXYColumn, i);

        /* %%%%% Reduce size of window if window cannot move %%%%%% */
        if (NDetectionsFaceSkin_SR <= 31) {
          /* Take one-fourth of window rather than one-half for use during operations */
          Idx = 8;

          /* Make the full window equal twice the value of the half-window:  */
          winNew = 15;
        }

        /* %%%%% If window still cannot move %%%%%% */
        if (NDetectionsFaceSkin_SR <= winNew) {
          /* Loop across columns */
          /* Initialize accumulator */
          Sum = 0;

          /* Sum rows across window           */
          for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
            /* Element cast to type int32. */
            Sum += ROIBlockFaceSkin_Temp->data[j + ROIBlockFaceSkin_Temp->size[0]
              * 2];
          }

          /* Take the mean */
          if (NDetectionsFaceSkin_SR == 0) {
            if (Sum == 0) {
              Idx = 0;
            } else if (Sum < 0) {
              Idx = MIN_int32_T;
            } else {
              Idx = MAX_int32_T;
            }
          } else if (NDetectionsFaceSkin_SR == 1) {
            Idx = Sum;
          } else {
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            if ((uint32_T)NDetectionsFaceSkin_SR == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / NDetectionsFaceSkin_SR;
            }

            d_x -= q * NDetectionsFaceSkin_SR;
            if ((d_x > 0U) && (d_x >= ((uint32_T)NDetectionsFaceSkin_SR >> 1U) +
                               (NDetectionsFaceSkin_SR & 1U))) {
              q++;
            }

            Idx = (int32_T)q;
            if (Sum < 0) {
              Idx = -(int32_T)q;
            }
          }

          /* Assign the mean to all rows of column i */
          /* Initialize accumulator */
          Sum = 0;

          /* Sum rows across window           */
          for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
            SmoothedXYColumn->data[j] = (int16_T)Idx;

            /* Element cast to type int32. */
            Sum += ROIBlockFaceSkin_Temp->data[j + ROIBlockFaceSkin_Temp->size[0]
              * 3];
          }

          /* Take the mean */
          if (NDetectionsFaceSkin_SR == 0) {
            if (Sum == 0) {
              Idx = 0;
            } else if (Sum < 0) {
              Idx = MIN_int32_T;
            } else {
              Idx = MAX_int32_T;
            }
          } else if (NDetectionsFaceSkin_SR == 1) {
            Idx = Sum;
          } else {
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            if ((uint32_T)NDetectionsFaceSkin_SR == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / NDetectionsFaceSkin_SR;
            }

            d_x -= q * NDetectionsFaceSkin_SR;
            if ((d_x > 0U) && (d_x >= ((uint32_T)NDetectionsFaceSkin_SR >> 1U) +
                               (NDetectionsFaceSkin_SR & 1U))) {
              q++;
            }

            Idx = (int32_T)q;
            if (Sum < 0) {
              Idx = -(int32_T)q;
            }
          }

          /* Assign the mean to all rows of column i */
          for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
            SmoothedXYColumn->data[j + SmoothedXYColumn->size[0]] = (int16_T)Idx;
          }

          /* %%%%% If window can move %%%%%%     */
        } else {
          /* Loop across columns */
          i = Idx + 1;
          i1 = NDetectionsFaceSkin_SR - Idx;
          b_i = i1 + 2;

          /* Initialize */
          Sum = 0;

          /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
          /* Set intial window end index */
          /* Sum across truncated window           */
          for (j = 0; j < Idx; j++) {
            /* Cast to type int32 and add */
            Sum += ROIBlockFaceSkin_Temp->data[j + ROIBlockFaceSkin_Temp->size[0]
              * 2];
          }

          /* Take mean */
          if (Sum >= 0) {
            d_x = (uint32_T)Sum;
          } else if (Sum == MIN_int32_T) {
            d_x = 2147483648U;
          } else {
            d_x = (uint32_T)-Sum;
          }

          q = d_x / Idx;
          d_x -= q * Idx;
          if ((d_x > 0U) && (d_x >= ((uint32_T)Idx >> 1U) + (Idx & 1U))) {
            q++;
          }

          z = (int32_T)q;
          if (Sum < 0) {
            z = -(int32_T)q;
          }

          SmoothedXYColumn->data[0] = (int16_T)z;

          /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
          /* Set initial truncated window length */
          n = Idx;

          /* Loop across rows */
          for (j = 2; j <= Idx; j++) {
            /* Set window end index for jth row */
            /* Add value at end of current window */
            /* Element cast to type int32. */
            Sum += ROIBlockFaceSkin_Temp->data[((j + Idx) +
              ROIBlockFaceSkin_Temp->size[0] * 2) - 2];

            /* Take mean:                 */
            n++;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
          /* Loop across rows */
          for (j = i; j <= i1 + 1; j++) {
            /* Set window start index for jth row */
            Start = (j - Idx) + 1;

            /* Set window end index for jth row */
            /* Subtract value at start of previous window.  */
            /* Then, add value at end of current window. */
            /* Element cast to type int32. */
            Sum = (Sum - ROIBlockFaceSkin_Temp->data[(Start +
                    ROIBlockFaceSkin_Temp->size[0] * 2) - 2]) +
              ROIBlockFaceSkin_Temp->data[((j + Idx) +
              ROIBlockFaceSkin_Temp->size[0] * 2) - 2];

            /* Take mean */
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            q = d_x / winNew;
            d_x -= q * winNew;
            if ((d_x > 0U) && (d_x >= ((uint32_T)winNew >> 1U) + (winNew & 1U)))
            {
              q++;
            }

            z = (int32_T)q;
            if (Sum < 0) {
              z = -(int32_T)q;
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
          /* Set intial window length */
          n = winNew;
          Start -= 2;
          for (j = b_i; j <= NDetectionsFaceSkin_SR; j++) {
            Start++;

            /* Subtract value at start of previous window */
            /* Element cast to type int32. */
            Sum -= ROIBlockFaceSkin_Temp->data[(Start +
              ROIBlockFaceSkin_Temp->size[0] * 2) - 1];

            /* Take mean:        */
            n--;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* Initialize */
          Sum = 0;

          /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
          /* Set intial window end index */
          /* Sum across truncated window           */
          for (j = 0; j < Idx; j++) {
            /* Cast to type int32 and add */
            Sum += ROIBlockFaceSkin_Temp->data[j + ROIBlockFaceSkin_Temp->size[0]
              * 3];
          }

          /* Take mean */
          if (Sum >= 0) {
            d_x = (uint32_T)Sum;
          } else if (Sum == MIN_int32_T) {
            d_x = 2147483648U;
          } else {
            d_x = (uint32_T)-Sum;
          }

          q = d_x / Idx;
          d_x -= q * Idx;
          if ((d_x > 0U) && (d_x >= ((uint32_T)Idx >> 1U) + (Idx & 1U))) {
            q++;
          }

          z = (int32_T)q;
          if (Sum < 0) {
            z = -(int32_T)q;
          }

          SmoothedXYColumn->data[SmoothedXYColumn->size[0]] = (int16_T)z;

          /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
          /* Set initial truncated window length */
          n = Idx;

          /* Loop across rows */
          for (j = 2; j <= Idx; j++) {
            /* Set window end index for jth row */
            /* Add value at end of current window */
            /* Element cast to type int32. */
            Sum += ROIBlockFaceSkin_Temp->data[((j + Idx) +
              ROIBlockFaceSkin_Temp->size[0] * 3) - 2];

            /* Take mean:                 */
            n++;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
          /* Loop across rows */
          for (j = i; j <= i1 + 1; j++) {
            /* Set window start index for jth row */
            Start = (j - Idx) + 1;

            /* Set window end index for jth row */
            /* Subtract value at start of previous window.  */
            /* Then, add value at end of current window. */
            /* Element cast to type int32. */
            Sum = (Sum - ROIBlockFaceSkin_Temp->data[(Start +
                    ROIBlockFaceSkin_Temp->size[0] * 3) - 2]) +
              ROIBlockFaceSkin_Temp->data[((j + Idx) +
              ROIBlockFaceSkin_Temp->size[0] * 3) - 2];

            /* Take mean */
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            q = d_x / winNew;
            d_x -= q * winNew;
            if ((d_x > 0U) && (d_x >= ((uint32_T)winNew >> 1U) + (winNew & 1U)))
            {
              q++;
            }

            z = (int32_T)q;
            if (Sum < 0) {
              z = -(int32_T)q;
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
          /* Set intial window length */
          n = winNew;
          Start -= 2;
          for (j = b_i; j <= NDetectionsFaceSkin_SR; j++) {
            Start++;

            /* Subtract value at start of previous window */
            /* Element cast to type int32. */
            Sum -= ROIBlockFaceSkin_Temp->data[(Start +
              ROIBlockFaceSkin_Temp->size[0] * 3) - 1];

            /* Take mean:        */
            n--;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }
        }

        /* end function */
        /* ============================================================================================= */
        /* Code-generation and build script */
        /* ============================================================================================= */
        /* Code-generation and build script used to generate C-language code and create the compiled version  */
        /* (MovMean_mex) of the function. */
        /* { */
        /*  */
        /* %%%%% Specify variable-size input arguments %%%%%% */
        /*  */
        /* See Matlab documentation for coder.typeof. */
        /*                         Example Code               Upp. Bounds   Var. Size (T/F)  Type */
        /* ROICode  = coder.typeof( zeros(50, 2, 'int16'),     [500, 2],      [1, 0] );        %int16 */
        /*  */
        /*  */
        /* %%%%% Specify fixed-size input arguments %%%%%% */
        /*  */
        /* winCode = double(0); */
        /* NRowsROI = int32(0); */
        /* NColsROI = int32(0);          */
        /*     */
        /* %%%%% Set configurations to increase performance %%%%%% */
        /*  */
        /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
        /* "Optimization Strategies" */
        /* cfg = coder.config('mex'); */
        /* cfg.GlobalDataSyncMethod = 'NoSync'; */
        /* cfg.ConstantInputs = 'IgnoreValues'; */
        /* cfg.ExtrinsicCalls = false; */
        /* cfg.SaturateOnIntegerOverflow = false; */
        /* cfg.IntegrityChecks = false; */
        /* cfg.ResponsivenessChecks = false; */
        /*  */
        /*  */
        /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
        /*  */
        /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
        /*  */
        /* The flags are specified as part of the code-generation configuration object. A custom function, */
        /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
        /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
        /* Matlab guidance found in */
        /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
        /*  */
        /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
        /* a character vector prior to execution of the codegen command. */
        /*  */
        /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
        /*  */
        /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
        /* is not present in the base workspace. */
        /*  */
        /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
        /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each  */
        /* character vector to maintain the charater vector, */
        /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
        /*  */
        /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
        /*  */
        /* Assign to code-generation configuration object */
        /* cfg.PostCodeGenCommand = setbuildargsAsText; */
        /*  */
        /*  */
        /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
        /*  */
        /* codegen MovMean.m -report -config cfg -args {ROICode, winCode, NRowsROI, NColsROI} */
        /*   */
        /* } */
        Sum = SmoothedXYColumn->size[0];
        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 2] =
            SmoothedXYColumn->data[i];
        }

        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 3] =
            SmoothedXYColumn->data[i + SmoothedXYColumn->size[0]];
        }

        /* %%%%% --- Adjust X- and Y-coordinates as a result of adjustments in widths and heights %%%%%% */
        /* Adjust X- and Y-coordinates corresponding to skin detections as a result of adjustments in  */
        /* widths and heights. */
        /* Loop across columns */
        /* Loop across rows */
        for (j = 0; j < NDetectionsSkin_SR; j++) {
          /* Index of position of jth ROI corresponding to a skin detection in face-or-skin  */
          /* detection matrix. */
          /* Index of position of jth ROI corresponding to a skin detection in the ROI block */
          /*  Add the half-difference to the X- or Y-coordinate */
          /*  (If there were a negative difference, this would imply the abs value of the */
          /*  half-difference is subtracted from the coordinate). */
          /*  Take half of the difference (optimize division by 2 with bit-wise division) */
          /*  Difference between unsmoothed width and height and smoothed width and */
          /*  height. */
          ROIBlockFaceSkin_Temp->data[SkinIdxFit->data[j] - 1] = (int16_T)
            (ROIBlockFaceSkin_Temp->data[SkinIdxFit->data[j] - 1] + ((int16_T)
              (ROINoPrevCallsBlock_SR->data
               [(ROIBlockDetectionSkinLinIdx_SR->data[j] +
                 ROINoPrevCallsBlock_SR->size[0] * 2) - 1] -
               ROIBlockFaceSkin_Temp->data[(SkinIdxFit->data[j] +
                ROIBlockFaceSkin_Temp->size[0] * 2) - 1]) >> 1));
        }

        /* Loop across rows */
        for (j = 0; j < NDetectionsSkin_SR; j++) {
          /* Index of position of jth ROI corresponding to a skin detection in face-or-skin  */
          /* detection matrix. */
          /* Index of position of jth ROI corresponding to a skin detection in the ROI block */
          /*  Add the half-difference to the X- or Y-coordinate */
          /*  (If there were a negative difference, this would imply the abs value of the */
          /*  half-difference is subtracted from the coordinate). */
          /*  Take half of the difference (optimize division by 2 with bit-wise division) */
          /*  Difference between unsmoothed width and height and smoothed width and */
          /*  height. */
          ROIBlockFaceSkin_Temp->data[(SkinIdxFit->data[j] +
            ROIBlockFaceSkin_Temp->size[0]) - 1] = (int16_T)
            (ROIBlockFaceSkin_Temp->data[(SkinIdxFit->data[j] +
              ROIBlockFaceSkin_Temp->size[0]) - 1] + ((int16_T)
              (ROINoPrevCallsBlock_SR->data
               [(ROIBlockDetectionSkinLinIdx_SR->data[j] +
                 ROINoPrevCallsBlock_SR->size[0] * 3) - 1] -
               ROIBlockFaceSkin_Temp->data[(SkinIdxFit->data[j] +
                ROIBlockFaceSkin_Temp->size[0] * 3) - 1]) >> 1));
        }

        /* %%%%% --- Moving-mean smoothing on X- and Y-coordinates %%%%%% */
        /* Smooth with face-detection and/or skin-detection algorithm ROI X- and Y-coordinates with those   */
        /* of other face-detection and/or skin-detection algorithm ROIs. As mentioned previously, any   */
        /* smoothing on ROIs that correspond to face detections will be discarded later. */
        /* The moving-mean smoothing window is specified by argument ROISkinSmoothingWindow to function  */
        /* FacePulseRate.   */
        /* Note: MovMean is a custom function located within folder 'FacePulseRate'. */
        /*  smoothing window */
        /*  the number of rows of the input matrix */
        /*  the number of columns of the input matrix */
        /* MovMean   Moving mean column-wise smoother. */
        /*  */
        /*     Helper function to function FacePulseRate.  */
        /*     Within function FacePulseRate, called by functions ROIMSIR_DetectionSmooth and */
        /*     ROIMSIR_FrameByFrameSmooth. */
        /*  */
        /*     Code generation:  */
        /*  */
        /*     Can be called as a Matlab function or used for C-language code generation. */
        /*  */
        /*     Description: */
        /*  */
        /*     Use a moving mean to conduct column-wise smoothing to a matrix. Weight rows corresponding to */
        /*     linear index WeightLinIdx by weight Weight. */
        /*  */
        /*     Inputs: */
        /*  */
        /*         ROI          = Matrix of values to be smoothed. M x :4 matrix; type int16.  */
        /*         Win          = Moving-mean window. Scalar; type double. */
        /*         NRowsROI     = The number of rows of the input matrix. Scalar; int32. */
        /*         NColsROI     = The number of columns of the input matrix. Scalar; int32. */
        /*  */
        /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
        /*     the Responsible AI License (RAIL). */
        /* Inline function */
        /* %%%%% Setup %%%%%% */
        /* Take half of window for use during operations */
        Idx = (int32_T)muDoubleScalarFloor(c_SkinDetectConfig_ROISkinSmoot / 2.0)
          + 1;

        /* Make the full window equal twice the value of the half-window:  */
        winNew = ((Idx - 1) << 1) + 1;

        /* Assert maximum number of columns to prevent dynamic memory allocation by the colon operator */
        /* Preallocate output */
        i = SmoothedXYColumn->size[0] * SmoothedXYColumn->size[1];
        SmoothedXYColumn->size[0] = NDetectionsFaceSkin_SR;
        SmoothedXYColumn->size[1] = 2;
        emxEnsureCapacity_int16_T(SmoothedXYColumn, i);

        /* %%%%% Reduce size of window if window cannot move %%%%%% */
        if (NDetectionsFaceSkin_SR <= winNew) {
          /* Take one-fourth of window rather than one-half for use during operations */
          Idx = (int32_T)muDoubleScalarFloor(c_SkinDetectConfig_ROISkinSmoot /
            4.0) + 1;

          /* Make the full window equal twice the value of the half-window:  */
          winNew = ((Idx - 1) << 1) + 1;
        }

        /* %%%%% If window still cannot move %%%%%% */
        if (NDetectionsFaceSkin_SR <= winNew) {
          /* Loop across columns */
          /* Initialize accumulator */
          Sum = 0;

          /* Sum rows across window           */
          for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
            /* Element cast to type int32. */
            Sum += ROIBlockFaceSkin_Temp->data[j];
          }

          /* Take the mean */
          if (NDetectionsFaceSkin_SR == 0) {
            if (Sum == 0) {
              Idx = 0;
            } else if (Sum < 0) {
              Idx = MIN_int32_T;
            } else {
              Idx = MAX_int32_T;
            }
          } else if (NDetectionsFaceSkin_SR == 1) {
            Idx = Sum;
          } else {
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            if ((uint32_T)NDetectionsFaceSkin_SR == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / NDetectionsFaceSkin_SR;
            }

            d_x -= q * NDetectionsFaceSkin_SR;
            if ((d_x > 0U) && (d_x >= ((uint32_T)NDetectionsFaceSkin_SR >> 1U) +
                               (NDetectionsFaceSkin_SR & 1U))) {
              q++;
            }

            Idx = (int32_T)q;
            if (Sum < 0) {
              Idx = -(int32_T)q;
            }
          }

          /* Assign the mean to all rows of column i */
          /* Initialize accumulator */
          Sum = 0;

          /* Sum rows across window           */
          for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
            SmoothedXYColumn->data[j] = (int16_T)Idx;

            /* Element cast to type int32. */
            Sum += ROIBlockFaceSkin_Temp->data[j + ROIBlockFaceSkin_Temp->size[0]];
          }

          /* Take the mean */
          if (NDetectionsFaceSkin_SR == 0) {
            if (Sum == 0) {
              Idx = 0;
            } else if (Sum < 0) {
              Idx = MIN_int32_T;
            } else {
              Idx = MAX_int32_T;
            }
          } else if (NDetectionsFaceSkin_SR == 1) {
            Idx = Sum;
          } else {
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            if ((uint32_T)NDetectionsFaceSkin_SR == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / NDetectionsFaceSkin_SR;
            }

            d_x -= q * NDetectionsFaceSkin_SR;
            if ((d_x > 0U) && (d_x >= ((uint32_T)NDetectionsFaceSkin_SR >> 1U) +
                               (NDetectionsFaceSkin_SR & 1U))) {
              q++;
            }

            Idx = (int32_T)q;
            if (Sum < 0) {
              Idx = -(int32_T)q;
            }
          }

          /* Assign the mean to all rows of column i */
          for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
            SmoothedXYColumn->data[j + SmoothedXYColumn->size[0]] = (int16_T)Idx;
          }

          /* %%%%% If window can move %%%%%%     */
        } else {
          /* Loop across columns */
          i = Idx + 1;
          i1 = NDetectionsFaceSkin_SR - Idx;
          b_i = i1 + 2;

          /* Initialize */
          Sum = 0;

          /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
          /* Set intial window end index */
          /* Sum across truncated window           */
          for (j = 0; j < Idx; j++) {
            /* Cast to type int32 and add */
            Sum += ROIBlockFaceSkin_Temp->data[j];
          }

          /* Take mean */
          if (Idx == 0) {
            if (Sum == 0) {
              z = 0;
            } else if (Sum < 0) {
              z = MIN_int32_T;
            } else {
              z = MAX_int32_T;
            }
          } else if (Idx == 1) {
            z = Sum;
          } else if (Idx == -1) {
            z = -Sum;
          } else {
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            if (Idx >= 0) {
              b_y = (uint32_T)Idx;
            } else if (Idx == MIN_int32_T) {
              b_y = 2147483648U;
            } else {
              b_y = (uint32_T)-Idx;
            }

            if (b_y == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / b_y;
            }

            d_x -= q * b_y;
            if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
              q++;
            }

            z = (int32_T)q;
            if ((Sum < 0) != (Idx < 0)) {
              z = -(int32_T)q;
            }
          }

          SmoothedXYColumn->data[0] = (int16_T)z;

          /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
          /* Set initial truncated window length */
          n = Idx;

          /* Loop across rows */
          for (j = 2; j <= Idx; j++) {
            /* Set window end index for jth row */
            /* Add value at end of current window */
            /* Element cast to type int32. */
            Sum += ROIBlockFaceSkin_Temp->data[(j + Idx) - 2];

            /* Take mean:                 */
            n++;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
          /* Loop across rows */
          for (j = i; j <= i1 + 1; j++) {
            /* Set window start index for jth row */
            Start = (j - Idx) + 1;

            /* Set window end index for jth row */
            /* Subtract value at start of previous window.  */
            /* Then, add value at end of current window. */
            /* Element cast to type int32. */
            Sum = (Sum - ROIBlockFaceSkin_Temp->data[Start - 2]) +
              ROIBlockFaceSkin_Temp->data[(j + Idx) - 2];

            /* Take mean */
            if (winNew == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (winNew == 1) {
              z = Sum;
            } else if (winNew == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (winNew >= 0) {
                b_y = (uint32_T)winNew;
              } else if (winNew == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-winNew;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (winNew < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
          /* Set intial window length */
          n = winNew;
          Start -= 2;
          for (j = b_i; j <= NDetectionsFaceSkin_SR; j++) {
            Start++;

            /* Subtract value at start of previous window */
            /* Element cast to type int32. */
            Sum -= ROIBlockFaceSkin_Temp->data[Start - 1];

            /* Take mean:        */
            n--;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[j - 1] = (int16_T)z;
          }

          /* Initialize */
          Sum = 0;

          /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
          /* Set intial window end index */
          /* Sum across truncated window           */
          for (j = 0; j < Idx; j++) {
            /* Cast to type int32 and add */
            Sum += ROIBlockFaceSkin_Temp->data[j + ROIBlockFaceSkin_Temp->size[0]];
          }

          /* Take mean */
          if (Idx == 0) {
            if (Sum == 0) {
              z = 0;
            } else if (Sum < 0) {
              z = MIN_int32_T;
            } else {
              z = MAX_int32_T;
            }
          } else if (Idx == 1) {
            z = Sum;
          } else if (Idx == -1) {
            z = -Sum;
          } else {
            if (Sum >= 0) {
              d_x = (uint32_T)Sum;
            } else if (Sum == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-Sum;
            }

            if (Idx >= 0) {
              b_y = (uint32_T)Idx;
            } else if (Idx == MIN_int32_T) {
              b_y = 2147483648U;
            } else {
              b_y = (uint32_T)-Idx;
            }

            if (b_y == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / b_y;
            }

            d_x -= q * b_y;
            if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
              q++;
            }

            z = (int32_T)q;
            if ((Sum < 0) != (Idx < 0)) {
              z = -(int32_T)q;
            }
          }

          SmoothedXYColumn->data[SmoothedXYColumn->size[0]] = (int16_T)z;

          /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
          /* Set initial truncated window length */
          n = Idx;

          /* Loop across rows */
          for (j = 2; j <= Idx; j++) {
            /* Set window end index for jth row */
            /* Add value at end of current window */
            /* Element cast to type int32. */
            Sum += ROIBlockFaceSkin_Temp->data[((j + Idx) +
              ROIBlockFaceSkin_Temp->size[0]) - 2];

            /* Take mean:                 */
            n++;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
          /* Loop across rows */
          for (j = i; j <= i1 + 1; j++) {
            /* Set window start index for jth row */
            Start = (j - Idx) + 1;

            /* Set window end index for jth row */
            /* Subtract value at start of previous window.  */
            /* Then, add value at end of current window. */
            /* Element cast to type int32. */
            Sum = (Sum - ROIBlockFaceSkin_Temp->data[(Start +
                    ROIBlockFaceSkin_Temp->size[0]) - 2]) +
              ROIBlockFaceSkin_Temp->data[((j + Idx) +
              ROIBlockFaceSkin_Temp->size[0]) - 2];

            /* Take mean */
            if (winNew == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (winNew == 1) {
              z = Sum;
            } else if (winNew == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (winNew >= 0) {
                b_y = (uint32_T)winNew;
              } else if (winNew == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-winNew;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (winNew < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }

          /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
          /* Set intial window length */
          n = winNew;
          Start -= 2;
          for (j = b_i; j <= NDetectionsFaceSkin_SR; j++) {
            Start++;

            /* Subtract value at start of previous window */
            /* Element cast to type int32. */
            Sum -= ROIBlockFaceSkin_Temp->data[(Start +
              ROIBlockFaceSkin_Temp->size[0]) - 1];

            /* Take mean:        */
            n--;

            /* Mean */
            if (n == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (n == 1) {
              z = Sum;
            } else if (n == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (n >= 0) {
                b_y = (uint32_T)n;
              } else if (n == MIN_int32_T) {
                b_y = 2147483648U;
              } else {
                b_y = (uint32_T)-n;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (n < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
              (int16_T)z;
          }
        }

        /* end function */
        /* ============================================================================================= */
        /* Code-generation and build script */
        /* ============================================================================================= */
        /* Code-generation and build script used to generate C-language code and create the compiled version  */
        /* (MovMean_mex) of the function. */
        /* { */
        /*  */
        /* %%%%% Specify variable-size input arguments %%%%%% */
        /*  */
        /* See Matlab documentation for coder.typeof. */
        /*                         Example Code               Upp. Bounds   Var. Size (T/F)  Type */
        /* ROICode  = coder.typeof( zeros(50, 2, 'int16'),     [500, 2],      [1, 0] );        %int16 */
        /*  */
        /*  */
        /* %%%%% Specify fixed-size input arguments %%%%%% */
        /*  */
        /* winCode = double(0); */
        /* NRowsROI = int32(0); */
        /* NColsROI = int32(0);          */
        /*     */
        /* %%%%% Set configurations to increase performance %%%%%% */
        /*  */
        /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
        /* "Optimization Strategies" */
        /* cfg = coder.config('mex'); */
        /* cfg.GlobalDataSyncMethod = 'NoSync'; */
        /* cfg.ConstantInputs = 'IgnoreValues'; */
        /* cfg.ExtrinsicCalls = false; */
        /* cfg.SaturateOnIntegerOverflow = false; */
        /* cfg.IntegrityChecks = false; */
        /* cfg.ResponsivenessChecks = false; */
        /*  */
        /*  */
        /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
        /*  */
        /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
        /*  */
        /* The flags are specified as part of the code-generation configuration object. A custom function, */
        /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
        /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
        /* Matlab guidance found in */
        /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
        /*  */
        /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
        /* a character vector prior to execution of the codegen command. */
        /*  */
        /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
        /*  */
        /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
        /* is not present in the base workspace. */
        /*  */
        /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
        /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each  */
        /* character vector to maintain the charater vector, */
        /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
        /*  */
        /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
        /*  */
        /* Assign to code-generation configuration object */
        /* cfg.PostCodeGenCommand = setbuildargsAsText; */
        /*  */
        /*  */
        /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
        /*  */
        /* codegen MovMean.m -report -config cfg -args {ROICode, winCode, NRowsROI, NColsROI} */
        /*   */
        /* } */
        Sum = SmoothedXYColumn->size[0];
        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp->data[i] = SmoothedXYColumn->data[i];
        }

        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0]] =
            SmoothedXYColumn->data[i + SmoothedXYColumn->size[0]];
        }

        /* %%%%% --- Discard recent smoothing for ROIs corresponding to face-detection algorithm detections %%%%%% */
        /* Discard smoothing for ROIs corresponding to face-detection algorithm detections where   */
        /* smoothing was applied that included skin-detection algorithm ROIs. This removes the influence */
        /* of skin-detection algorithm ROIs on face-detection algorithm ROIs. This is conducted because */
        /* face-detection algorithm ROIs are assumed to be more accurate than skin-detection algorithm  */
        /* ROIs. */
        /* Keep only ROIs corresponding to skin-detection algorithm detections  */
        /* M x 4 matrix (229 x 4 during first-read operations); type int16. */
        /* Loop across columns */
        /* Loop across rows */
        for (j = 0; j < NDetectionsSkin_SR; j++) {
          /* Index of position of jth ROI corresponding to a skin detection in the ROI block  */
          /* Index of position of jth ROI corresponding to a skin detection in face-or-skin  */
          /* detection matrix. */
          ROINoPrevCallsBlock_SR->data[ROIBlockDetectionSkinLinIdx_SR->data[j] -
            1] = ROIBlockFaceSkin_Temp->data[SkinIdxFit->data[j] - 1];
        }

        /* Loop across rows */
        for (j = 0; j < NDetectionsSkin_SR; j++) {
          /* Index of position of jth ROI corresponding to a skin detection in the ROI block  */
          /* Index of position of jth ROI corresponding to a skin detection in face-or-skin  */
          /* detection matrix. */
          ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionSkinLinIdx_SR->data[j]
            + ROINoPrevCallsBlock_SR->size[0]) - 1] =
            ROIBlockFaceSkin_Temp->data[(SkinIdxFit->data[j] +
            ROIBlockFaceSkin_Temp->size[0]) - 1];
        }

        /* Loop across rows */
        for (j = 0; j < NDetectionsSkin_SR; j++) {
          /* Index of position of jth ROI corresponding to a skin detection in the ROI block  */
          /* Index of position of jth ROI corresponding to a skin detection in face-or-skin  */
          /* detection matrix. */
          ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionSkinLinIdx_SR->data[j]
            + ROINoPrevCallsBlock_SR->size[0] * 2) - 1] =
            ROIBlockFaceSkin_Temp->data[(SkinIdxFit->data[j] +
            ROIBlockFaceSkin_Temp->size[0] * 2) - 1];
        }

        /* Loop across rows */
        for (j = 0; j < NDetectionsSkin_SR; j++) {
          /* Index of position of jth ROI corresponding to a skin detection in the ROI block  */
          /* Index of position of jth ROI corresponding to a skin detection in face-or-skin  */
          /* detection matrix. */
          ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionSkinLinIdx_SR->data[j]
            + ROINoPrevCallsBlock_SR->size[0] * 3) - 1] =
            ROIBlockFaceSkin_Temp->data[(SkinIdxFit->data[j] +
            ROIBlockFaceSkin_Temp->size[0] * 3) - 1];
        }

        /* %%%%% --- Lightly smooth ROIs corresponding to face-detection algorithm detections %%%%%% */
        /* The previous step (discarding smoothing for face-detection algorithm ROIs) may result in some  */
        /* undesired jumps of the ROI between face-detection algorithm detections and skin-detection  */
        /* algorithm detections. To smooth these jumps, the face-detection algorithm detections are */
        /* smoothed with a set of ROIs that include skin-detection algorithm detections. To reduce the */
        /* influence of skin-detection algorithm detections on face-detection algorithm detections --  */
        /* which was the purpose of the discarding step -- a small smoothing window of 3 is used. */
        /* Also assign a variable, NoPrevCallsBlock_ROIDetections, that only contains ROIs that  */
        /* correspond to a detection. This variable would have been assigned in the next section ("Assign   */
        /* an ROI matrix that contains only ROIs that correspond to a detection"), but it is assigned  */
        /* here for efficiency. */
        /* Return smoothed ROIs that correspond to either a face- or skin-detection algorithm detection */
        if (NDetectionsFace_SR != 0) {
          /* Note: ROIMSIR_FaceDetectionLightSmooth is a custom function located within folder  */
          /* 'FacePulseRate'. */
          /*  229 x 4 matrix; type int16 */
          /*  Index of positions of face detections in */
          /*  NoPrevCallsBlock_ROIDetections. */
          /* ROIMSIR_FaceDetectionLightSmooth   Lightly smooth ROIs corresponding to face detections. */
          /*  */
          /*     Helper function to function FacePulseRate.  */
          /*     Within function FacePulseRate, called by function ROIMSIR_DetectionSmooth. */
          /*  */
          /*  */
          /*     Code Generation */
          /*     --------------- */
          /*  */
          /*     Can be called as a Matlab function or used for C-language code generation. */
          /*  */
          /*  */
          /*     Description */
          /*     ----------- */
          /*  */
          /*     Lightly smooth ROIs corresponding to face detections:  */
          /*  */
          /*     (1) Smooth the height and width of each ROI. */
          /*     (2) Adjust the X- and Y-coordinates of each ROI to correspond to the previous changes to the  */
          /*         height and width. */
          /*     (3) Smooth the X- and Y-coordinates of each ROI. */
          /*  */
          /*     Return a matrix of ROIs that correspond to either face- or skin-detection algorithm  */
          /*     detections. Although this function only smooths ROIs corresponding to face detections, ROIs  */
          /*     corresponding to skin detections are also included in the output for efficient use in other  */
          /*     functions. Vector FaceIdxFit is an index that indicates which rows in the output matrix  */
          /*     correspond to the smoothed ROIs from face detections. */
          /*  */
          /*     Under certain conditions, even if a face-detection ROI is present, the ROI may not be  */
          /*     smoothed. In this case, there will not be a corresponding index in FaceIdxFit. */
          /*      */
          /*     Assumptions: */
          /*     */
          /*     - Neither NFaceSkinIdx nor NFaceIdx equal 0. */
          /*     - Elements of set FaceIdx are entirely nested within set FaceSkinIdx.       */
          /*     - Within each of these sets, values do not repeat and are ordered such that they increase */
          /*       monotonically. */
          /*  */
          /*  */
          /*     Copyright */
          /*     --------- */
          /*  */
          /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
          /*     the Responsible AI License (RAIL). */
          /* Inline function */
          /* Preallocate ROI matrix where ROIs correspond to either face- or skin-detection algorithm  */
          /* detections. */
          i = c_NoPrevCallsBlock_ROIDetection->size[0] *
            c_NoPrevCallsBlock_ROIDetection->size[1];
          c_NoPrevCallsBlock_ROIDetection->size[0] = NDetectionsFaceSkin_SR;
          c_NoPrevCallsBlock_ROIDetection->size[1] = 4;
          emxEnsureCapacity_int16_T(c_NoPrevCallsBlock_ROIDetection, i);

          /* Preallocate index indicating position of smoothed ROIs that correspond to face-detection algorithm  */
          /* within variable ROIDetections. */
          /* If this variable is returned as 0, this indicates that no ROIs were smoothed within this function. */
          i = ROIBlockDetectionSkinLinIdx_SR->size[0];
          ROIBlockDetectionSkinLinIdx_SR->size[0] = 1;
          emxEnsureCapacity_int32_T(ROIBlockDetectionSkinLinIdx_SR, i);
          ROIBlockDetectionSkinLinIdx_SR->data[0] = 0;

          /* If a smoothing window of 3 is possible */
          if (NDetectionsFaceSkin_SR > 2) {
            /* %%%%% --- Widths and heights and tentative X- and Y-coordinates %%%%%%       */
            /* Initialize face-detection algorithm detection counter */
            VideoReadConfig_FrameIdx_Length = 1;

            /* Loop across rows corresponding to a detection (either from face-detection or skin-detection */
            /* algorithm). */
            /* Note: the value of NFaceSkinIdx equals the length of FaceSkinIdx.  */
            for (b_i = 0; b_i < NDetectionsFaceSkin_SR; b_i++) {
              /* Index of ith face- or skin-detection */
              Idx = c_ROIBlockDetectionFaceSkinLinI->data[b_i];

              /* If the ith row corresponds to a face-detection algorithm detection */
              /* Note: this comparison method is possible because ... */
              /* (1) Set FaceIdx is completed nested within set FaceSkinIdx.  */
              /* (2) Both FaceIdx and FaceSkinIdx are sets of non-repeating monotonically increasing  */
              /* values. */
              /*  prevent FaceIdxCounter from indexing beyond length of FaceIdx */
              if ((VideoReadConfig_FrameIdx_Length <= NDetectionsFace_SR) &&
                  (c_ROIBlockDetectionFaceSkinLinI->data[b_i] ==
                   ROIBlockDetectionFaceLinIdx_SR->
                   data[VideoReadConfig_FrameIdx_Length - 1])) {
                /* the ith row corresponds to a face detection        */
                /* For first and last detections, do not smooth because a smoothing window of 3 cannot be */
                /* used. */
                if ((b_i + 1 == 1) || (b_i + 1 == NDetectionsFaceSkin_SR)) {
                  /* If first row of ROIDetections                */
                  if (b_i + 1 == 1) {
                    c_NoPrevCallsBlock_ROIDetection->data[0] =
                      ROINoPrevCallsBlock_SR->
                      data[c_ROIBlockDetectionFaceSkinLinI->data[0] - 1];
                    c_NoPrevCallsBlock_ROIDetection->
                      data[c_NoPrevCallsBlock_ROIDetection->size[0]] =
                      ROINoPrevCallsBlock_SR->data
                      [(c_ROIBlockDetectionFaceSkinLinI->data[0] +
                        ROINoPrevCallsBlock_SR->size[0]) - 1];
                    c_NoPrevCallsBlock_ROIDetection->
                      data[c_NoPrevCallsBlock_ROIDetection->size[0] * 2] =
                      ROINoPrevCallsBlock_SR->data
                      [(c_ROIBlockDetectionFaceSkinLinI->data[0] +
                        ROINoPrevCallsBlock_SR->size[0] * 2) - 1];
                    c_NoPrevCallsBlock_ROIDetection->
                      data[c_NoPrevCallsBlock_ROIDetection->size[0] * 3] =
                      ROINoPrevCallsBlock_SR->data
                      [(c_ROIBlockDetectionFaceSkinLinI->data[0] +
                        ROINoPrevCallsBlock_SR->size[0] * 3) - 1];

                    /* If last row of ROIDetections                      */
                  } else {
                    /*  i == NFaceSkinIdx                     */
                    c_NoPrevCallsBlock_ROIDetection->data[NDetectionsFaceSkin_SR
                      - 1] = ROINoPrevCallsBlock_SR->data[Idx - 1];
                    c_NoPrevCallsBlock_ROIDetection->data
                      [(NDetectionsFaceSkin_SR +
                        c_NoPrevCallsBlock_ROIDetection->size[0]) - 1] =
                      ROINoPrevCallsBlock_SR->data[(Idx +
                      ROINoPrevCallsBlock_SR->size[0]) - 1];
                    c_NoPrevCallsBlock_ROIDetection->data
                      [(NDetectionsFaceSkin_SR +
                        c_NoPrevCallsBlock_ROIDetection->size[0] * 2) - 1] =
                      ROINoPrevCallsBlock_SR->data[(Idx +
                      ROINoPrevCallsBlock_SR->size[0] * 2) - 1];
                    c_NoPrevCallsBlock_ROIDetection->data
                      [(NDetectionsFaceSkin_SR +
                        c_NoPrevCallsBlock_ROIDetection->size[0] * 3) - 1] =
                      ROINoPrevCallsBlock_SR->data[(Idx +
                      ROINoPrevCallsBlock_SR->size[0] * 3) - 1];
                  }
                } else {
                  /* Loop across width and height columns */
                  /* ijth ROI */
                  Width_ith = ROINoPrevCallsBlock_SR->data[(Idx +
                    ROINoPrevCallsBlock_SR->size[0] * 2) - 1];

                  /* Smooth ijth ROI  */
                  /* Scalar; int16. */
                  /* Note: as only three elements are summed, the data type will not overflow.                     */
                  winNew = c_ROIBlockDetectionFaceSkinLinI->data[b_i - 1] - 1;
                  Start = c_ROIBlockDetectionFaceSkinLinI->data[b_i + 1] - 1;
                  Height_ith = (int16_T)((int16_T)(ROINoPrevCallsBlock_SR->
                    data[winNew + ROINoPrevCallsBlock_SR->size[0] * 2] +
                    Width_ith) + ROINoPrevCallsBlock_SR->data[Start +
                    ROINoPrevCallsBlock_SR->size[0] * 2]);
                  if (Height_ith >= 0) {
                    e_x = (uint16_T)Height_ith;
                  } else if (Height_ith == -32768) {
                    e_x = 32768U;
                  } else {
                    e_x = (uint16_T)-Height_ith;
                  }

                  b_q = (uint16_T)(e_x / 3U);
                  e_x = (uint16_T)((uint32_T)e_x - b_q * 3);
                  if ((e_x > 0) && (e_x >= 2)) {
                    b_q++;
                  }

                  WidthNew_ith = (int16_T)b_q;
                  if (Height_ith < 0) {
                    WidthNew_ith = (int16_T)-b_q;
                  }

                  /* Assign width or height: */
                  c_NoPrevCallsBlock_ROIDetection->data[b_i +
                    c_NoPrevCallsBlock_ROIDetection->size[0] * 2] = WidthNew_ith;

                  /* Adjust X- or Y-coordinate to correspond to changes in width or height: */
                  /* (1) Take half of difference between old and new widths/heights */
                  /* (2) Add to X- or Y-coordinate */
                  /* Optimize division by 2 with bitwise operation. */
                  /* Width was smoothed -> Adjust X-coordinate */
                  c_NoPrevCallsBlock_ROIDetection->data[b_i] = (int16_T)
                    (ROINoPrevCallsBlock_SR->data[Idx - 1] + ((int16_T)
                      (Width_ith - WidthNew_ith) >> 1));

                  /* Height was smoothed -> Adjust Y-coordinate */
                  /* ijth ROI */
                  Width_ith = ROINoPrevCallsBlock_SR->data[(Idx +
                    ROINoPrevCallsBlock_SR->size[0] * 3) - 1];

                  /* Smooth ijth ROI  */
                  /* Scalar; int16. */
                  /* Note: as only three elements are summed, the data type will not overflow.                     */
                  Height_ith = (int16_T)((int16_T)(ROINoPrevCallsBlock_SR->
                    data[winNew + ROINoPrevCallsBlock_SR->size[0] * 3] +
                    Width_ith) + ROINoPrevCallsBlock_SR->data[Start +
                    ROINoPrevCallsBlock_SR->size[0] * 3]);
                  if (Height_ith >= 0) {
                    e_x = (uint16_T)Height_ith;
                  } else if (Height_ith == -32768) {
                    e_x = 32768U;
                  } else {
                    e_x = (uint16_T)-Height_ith;
                  }

                  b_q = (uint16_T)(e_x / 3U);
                  e_x = (uint16_T)((uint32_T)e_x - b_q * 3);
                  if ((e_x > 0) && (e_x >= 2)) {
                    b_q++;
                  }

                  WidthNew_ith = (int16_T)b_q;
                  if (Height_ith < 0) {
                    WidthNew_ith = (int16_T)-b_q;
                  }

                  /* Assign width or height: */
                  c_NoPrevCallsBlock_ROIDetection->data[b_i +
                    c_NoPrevCallsBlock_ROIDetection->size[0] * 3] = WidthNew_ith;

                  /* Adjust X- or Y-coordinate to correspond to changes in width or height: */
                  /* (1) Take half of difference between old and new widths/heights */
                  /* (2) Add to X- or Y-coordinate */
                  /* Optimize division by 2 with bitwise operation. */
                  c_NoPrevCallsBlock_ROIDetection->data[b_i +
                    c_NoPrevCallsBlock_ROIDetection->size[0]] = (int16_T)
                    (ROINoPrevCallsBlock_SR->data[(Idx +
                      ROINoPrevCallsBlock_SR->size[0]) - 1] + ((int16_T)
                      (Width_ith - WidthNew_ith) >> 1));

                  /* Position of ROI does not permit smoothing window of length 3 */
                }

                /* Advance counter of face-detection algorithm detections */
                VideoReadConfig_FrameIdx_Length++;

                /* If the ith detection is not a face-detection algorithm detection */
                /* I.e., it is a skin-detection algorithm detection. */
              } else {
                c_NoPrevCallsBlock_ROIDetection->data[b_i] =
                  ROINoPrevCallsBlock_SR->data[Idx - 1];
                c_NoPrevCallsBlock_ROIDetection->data[b_i +
                  c_NoPrevCallsBlock_ROIDetection->size[0]] =
                  ROINoPrevCallsBlock_SR->data[(Idx +
                  ROINoPrevCallsBlock_SR->size[0]) - 1];
                c_NoPrevCallsBlock_ROIDetection->data[b_i +
                  c_NoPrevCallsBlock_ROIDetection->size[0] * 2] =
                  ROINoPrevCallsBlock_SR->data[(Idx +
                  ROINoPrevCallsBlock_SR->size[0] * 2) - 1];
                c_NoPrevCallsBlock_ROIDetection->data[b_i +
                  c_NoPrevCallsBlock_ROIDetection->size[0] * 3] =
                  ROINoPrevCallsBlock_SR->data[(Idx +
                  ROINoPrevCallsBlock_SR->size[0] * 3) - 1];
              }
            }

            /* %%%%% --- Final X- and Y-coordinates %%%%%%              */
            /* Preallocate column of smoothed ROI elements that correspond to the X- and Y-coordinates of */
            /* face-detection algorithm detections.  */
            /* Smoothed ROI elements are assigned to this variable rather than variable ROIDetections to  */
            /* prevent elements that have been smoothed from being included in the smoothing windows of  */
            /* subsequent elements. After the loop, the smoothed elements are assigned to ROIDetections.     */
            i = SmoothedXYColumn->size[0] * SmoothedXYColumn->size[1];
            SmoothedXYColumn->size[0] = NDetectionsFace_SR;
            SmoothedXYColumn->size[1] = 2;
            emxEnsureCapacity_int16_T(SmoothedXYColumn, i);

            /* Assign the first and/or last rows of SmoothedXYColumn if there is a match to the first and/or  */
            /* last rows of ROIDetections: */
            /* This assignment is made here because these rows will not be assigned later. */
            if (ROIBlockDetectionFaceLinIdx_SR->data[0] ==
                c_ROIBlockDetectionFaceSkinLinI->data[0]) {
              SmoothedXYColumn->data[0] = c_NoPrevCallsBlock_ROIDetection->data
                [0];
              SmoothedXYColumn->data[SmoothedXYColumn->size[0]] =
                c_NoPrevCallsBlock_ROIDetection->
                data[c_NoPrevCallsBlock_ROIDetection->size[0]];
            }

            if (ROIBlockDetectionFaceLinIdx_SR->data[NDetectionsFace_SR - 1] ==
                c_ROIBlockDetectionFaceSkinLinI->data[NDetectionsFaceSkin_SR - 1])
            {
              SmoothedXYColumn->data[NDetectionsFace_SR - 1] =
                c_NoPrevCallsBlock_ROIDetection->data[NDetectionsFaceSkin_SR - 1];
              SmoothedXYColumn->data[(NDetectionsFace_SR +
                SmoothedXYColumn->size[0]) - 1] =
                c_NoPrevCallsBlock_ROIDetection->data[(NDetectionsFaceSkin_SR +
                c_NoPrevCallsBlock_ROIDetection->size[0]) - 1];
            }

            /* Smooth X- and Y-coordinates: */
            /* Find the positions of FaceIdx in FaceSkinIdx  */
            /* Column vector; int32. */
            /* Note: PositionsIn is a custom function located within folder 'FacePulseRate'. */
            /*  set A */
            /*  set B */
            /*  length of set A */
            /* PositionsIn   Return the index indicating where elements in set A are positioned in set B.  */
            /*  */
            /*     Helper function to function FacePulseRate.  */
            /*     Within function FacePulseRate, called by functions ROIMSIR_DetectionSmooth and  */
            /*     ROIMSIR_FaceDetectionLightSmooth. */
            /*  */
            /*     Code generation:  */
            /*  */
            /*     Can be called as a Matlab function or used for C-language code generation. */
            /*  */
            /*     Description: */
            /*  */
            /*     Return the index indicating where elements in set A are positioned in set B. Various  */
            /*     assumptions are made to increase efficiency.  */
            /*  */
            /*         Assumptions */
            /*     */
            /*     - Elements of set A are entirely nested within set B. */
            /*     - Within each set, values do not repeat and are ordered such that they increase monotonically. */
            /*  */
            /*     Example: */
            /*  */
            /*     A = [4, 5, 6]; */
            /*     B = [2, 3, 4, 5, 6]; */
            /*     A_Length = numel(A); */
            /*  */
            /*     PositionsIn(A, B, A_Length) */
            /*     >> [3; 4; 5] */
            /*  */
            /*     Note: */
            /*  */
            /*     The return values are equivalent to those returned by int32( find( ismember(B, A) )' ); */
            /* Inline function */
            /* Index of B on a given iteration */
            winNew = 0;

            /* Preallocate output */
            i = ROIBlockDetectionSkinLinIdx_SR->size[0];
            ROIBlockDetectionSkinLinIdx_SR->size[0] = NDetectionsFace_SR;
            emxEnsureCapacity_int32_T(ROIBlockDetectionSkinLinIdx_SR, i);

            /* Loop across elements of A */
            /* end function */
            /* Loop across rows corresponding to a face detection  */
            /* Note: the value of NFaceIdx equals the length of FaceIdx.  */
            for (b_i = 0; b_i < NDetectionsFace_SR; b_i++) {
              do {
                winNew++;
              } while (!(ROIBlockDetectionFaceLinIdx_SR->data[b_i] ==
                         c_ROIBlockDetectionFaceSkinLinI->data[winNew - 1]));

              /* Position (index) of ith index of A in B. */
              ROIBlockDetectionSkinLinIdx_SR->data[b_i] = winNew;
              i = ROIBlockDetectionSkinLinIdx_SR->data[b_i];

              /* For first and last detections, do not smooth because a smoothing window of 3 cannot be */
              /* used. */
              if ((ROIBlockDetectionSkinLinIdx_SR->data[b_i] != 1) &&
                  (ROIBlockDetectionSkinLinIdx_SR->data[b_i] !=
                   NDetectionsFaceSkin_SR)) {
                /* Loop across X- and Y-coordinate columns */
                /* Smooth ijth ROI and assign to SmoothedXYColumn */
                /* (See note where SmoothedColumn preallocated). */
                /* Scalar; int16. */
                /* Note: as only three elements are summed, the data type will not overflow.                     */
                Height_ith = (int16_T)((int16_T)
                  (c_NoPrevCallsBlock_ROIDetection->data[i - 2] +
                   c_NoPrevCallsBlock_ROIDetection->data[i - 1]) +
                  c_NoPrevCallsBlock_ROIDetection->data[i]);
                if (Height_ith >= 0) {
                  e_x = (uint16_T)Height_ith;
                } else if (Height_ith == -32768) {
                  e_x = 32768U;
                } else {
                  e_x = (uint16_T)-Height_ith;
                }

                b_q = (uint16_T)(e_x / 3U);
                e_x = (uint16_T)((uint32_T)e_x - b_q * 3);
                if ((e_x > 0) && (e_x >= 2)) {
                  b_q++;
                }

                SmoothedXYColumn->data[b_i] = (int16_T)b_q;
                if (Height_ith < 0) {
                  SmoothedXYColumn->data[b_i] = (int16_T)-b_q;
                }

                /* Smooth ijth ROI and assign to SmoothedXYColumn */
                /* (See note where SmoothedColumn preallocated). */
                /* Scalar; int16. */
                /* Note: as only three elements are summed, the data type will not overflow.                     */
                Height_ith = (int16_T)((int16_T)
                  (c_NoPrevCallsBlock_ROIDetection->data[(i +
                  c_NoPrevCallsBlock_ROIDetection->size[0]) - 2] +
                   c_NoPrevCallsBlock_ROIDetection->data[(i +
                  c_NoPrevCallsBlock_ROIDetection->size[0]) - 1]) +
                  c_NoPrevCallsBlock_ROIDetection->data[i +
                  c_NoPrevCallsBlock_ROIDetection->size[0]]);
                if (Height_ith >= 0) {
                  e_x = (uint16_T)Height_ith;
                } else if (Height_ith == -32768) {
                  e_x = 32768U;
                } else {
                  e_x = (uint16_T)-Height_ith;
                }

                b_q = (uint16_T)(e_x / 3U);
                e_x = (uint16_T)((uint32_T)e_x - b_q * 3);
                if ((e_x > 0) && (e_x >= 2)) {
                  b_q++;
                }

                SmoothedXYColumn->data[b_i + SmoothedXYColumn->size[0]] =
                  (int16_T)b_q;
                if (Height_ith < 0) {
                  SmoothedXYColumn->data[b_i + SmoothedXYColumn->size[0]] =
                    (int16_T)-b_q;
                }
              }
            }

            /* Assign final X- and Y-coordinates: */
            /* Loop across X- and Y-coordinate columns corresponding to detections */
            /* Loop across rows corresponding to a face detection  */
            /* Note: the value of NFaceIdx equals the length of FaceIdx.  */
            for (j = 0; j < NDetectionsFace_SR; j++) {
              c_NoPrevCallsBlock_ROIDetection->
                data[ROIBlockDetectionSkinLinIdx_SR->data[j] - 1] =
                SmoothedXYColumn->data[j];
            }

            /* Loop across rows corresponding to a face detection  */
            /* Note: the value of NFaceIdx equals the length of FaceIdx.  */
            for (j = 0; j < NDetectionsFace_SR; j++) {
              c_NoPrevCallsBlock_ROIDetection->data
                [(ROIBlockDetectionSkinLinIdx_SR->data[j] +
                  c_NoPrevCallsBlock_ROIDetection->size[0]) - 1] =
                SmoothedXYColumn->data[j + SmoothedXYColumn->size[0]];
            }

            /* A smoothing window of 3 is not possible */
            /* ROINoPrevCallsBlock_ROIDetections will not be empty. */
          } else if (NDetectionsFaceSkin_SR > 0) {
            for (b_i = 0; b_i < NDetectionsFaceSkin_SR; b_i++) {
              c_NoPrevCallsBlock_ROIDetection->data[b_i] =
                ROINoPrevCallsBlock_SR->data
                [c_ROIBlockDetectionFaceSkinLinI->data[b_i] - 1];
              c_NoPrevCallsBlock_ROIDetection->data[b_i +
                c_NoPrevCallsBlock_ROIDetection->size[0]] =
                ROINoPrevCallsBlock_SR->data
                [(c_ROIBlockDetectionFaceSkinLinI->data[b_i] +
                  ROINoPrevCallsBlock_SR->size[0]) - 1];
              c_NoPrevCallsBlock_ROIDetection->data[b_i +
                c_NoPrevCallsBlock_ROIDetection->size[0] * 2] =
                ROINoPrevCallsBlock_SR->data
                [(c_ROIBlockDetectionFaceSkinLinI->data[b_i] +
                  ROINoPrevCallsBlock_SR->size[0] * 2) - 1];
              c_NoPrevCallsBlock_ROIDetection->data[b_i +
                c_NoPrevCallsBlock_ROIDetection->size[0] * 3] =
                ROINoPrevCallsBlock_SR->data
                [(c_ROIBlockDetectionFaceSkinLinI->data[b_i] +
                  ROINoPrevCallsBlock_SR->size[0] * 3) - 1];
            }

            /* A smoothing window of 3 is not possible */
            /* ROINoPrevCallsBlock_ROIDetections will be empty.     */
          } else {
            /* NDetectionsFaceSkin == 0 */
            c_NoPrevCallsBlock_ROIDetection->size[0] = 0;
            c_NoPrevCallsBlock_ROIDetection->size[1] = 4;
          }

          /* end function */
          /* Assign smoothed ROIs corresponding to face detections to ROI matrix: */
          /* Loop across columns */
          /* Loop across rows         */
          for (j = 0; j < NDetectionsFace_SR; j++) {
            /* Position of jth face-detection in ROINoPrevCallsBlock  */
            /* Position of jth face-detection in NoPrevCallsBlock_ROIDetections  */
            ROINoPrevCallsBlock_SR->data[ROIBlockDetectionFaceLinIdx_SR->data[j]
              - 1] = c_NoPrevCallsBlock_ROIDetection->
              data[ROIBlockDetectionSkinLinIdx_SR->data[j] - 1];
          }

          /* Loop across rows         */
          for (j = 0; j < NDetectionsFace_SR; j++) {
            /* Position of jth face-detection in ROINoPrevCallsBlock  */
            /* Position of jth face-detection in NoPrevCallsBlock_ROIDetections  */
            ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionFaceLinIdx_SR->data[j]
              + ROINoPrevCallsBlock_SR->size[0]) - 1] =
              c_NoPrevCallsBlock_ROIDetection->data
              [(ROIBlockDetectionSkinLinIdx_SR->data[j] +
                c_NoPrevCallsBlock_ROIDetection->size[0]) - 1];
          }

          /* Loop across rows         */
          for (j = 0; j < NDetectionsFace_SR; j++) {
            /* Position of jth face-detection in ROINoPrevCallsBlock  */
            /* Position of jth face-detection in NoPrevCallsBlock_ROIDetections  */
            ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionFaceLinIdx_SR->data[j]
              + ROINoPrevCallsBlock_SR->size[0] * 2) - 1] =
              c_NoPrevCallsBlock_ROIDetection->data
              [(ROIBlockDetectionSkinLinIdx_SR->data[j] +
                c_NoPrevCallsBlock_ROIDetection->size[0] * 2) - 1];
          }

          /* Loop across rows         */
          for (j = 0; j < NDetectionsFace_SR; j++) {
            /* Position of jth face-detection in ROINoPrevCallsBlock  */
            /* Position of jth face-detection in NoPrevCallsBlock_ROIDetections  */
            ROINoPrevCallsBlock_SR->data[(ROIBlockDetectionFaceLinIdx_SR->data[j]
              + ROINoPrevCallsBlock_SR->size[0] * 3) - 1] =
              c_NoPrevCallsBlock_ROIDetection->data
              [(ROIBlockDetectionSkinLinIdx_SR->data[j] +
                c_NoPrevCallsBlock_ROIDetection->size[0] * 3) - 1];
          }
        }
      }

      /* %%%%% Assign an ROI matrix that contains only ROIs that correspond to a detection %%%%%% */
      /* This variable contains all ROIs that correspond to either a face- or skin-detection algorthm  */
      /* detection. This variable will be used as input to functions ROIMSIR_Interpolate and  */
      /* ROIMSIR_FrameByFrameSmooth. */
      /* If no skin-detection ROIs were smoothed or if the number of face detections equals 0. */
      /* In either case, variable NoPrevCallsBlock_ROIDetections would not have been previously assigned.  */
      if ((!FaceOrSkinTF) || (NDetectionsFace_SR == 0)) {
        /* If no ROIs in the block correspond to detections by either the skin-detection algorithm or the */
        /* face-detection algorithm. */
        if (NDetectionsFaceSkin_SR == 0) {
          c_NoPrevCallsBlock_ROIDetection->size[0] = 0;
          c_NoPrevCallsBlock_ROIDetection->size[1] = 4;

          /* If at least one ROI in block corresponds to a detection         */
        } else {
          /* Loop across columns */
          /* Loop across rows     */
          for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
            /* jjth index corresponding to a detection */
            c_NoPrevCallsBlock_ROIDetection->data[j] =
              ROINoPrevCallsBlock_SR->data[c_ROIBlockDetectionFaceSkinLinI->
              data[j] - 1];
          }

          /* Loop across rows     */
          for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
            /* jjth index corresponding to a detection */
            c_NoPrevCallsBlock_ROIDetection->data[j +
              c_NoPrevCallsBlock_ROIDetection->size[0]] =
              ROINoPrevCallsBlock_SR->data
              [(c_ROIBlockDetectionFaceSkinLinI->data[j] +
                ROINoPrevCallsBlock_SR->size[0]) - 1];
          }

          /* Loop across rows     */
          for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
            /* jjth index corresponding to a detection */
            c_NoPrevCallsBlock_ROIDetection->data[j +
              c_NoPrevCallsBlock_ROIDetection->size[0] * 2] =
              ROINoPrevCallsBlock_SR->data
              [(c_ROIBlockDetectionFaceSkinLinI->data[j] +
                ROINoPrevCallsBlock_SR->size[0] * 2) - 1];
          }

          /* Loop across rows     */
          for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
            /* jjth index corresponding to a detection */
            c_NoPrevCallsBlock_ROIDetection->data[j +
              c_NoPrevCallsBlock_ROIDetection->size[0] * 3] =
              ROINoPrevCallsBlock_SR->data
              [(c_ROIBlockDetectionFaceSkinLinI->data[j] +
                ROINoPrevCallsBlock_SR->size[0] * 3) - 1];
          }
        }
      }

      /* %%%%% Adjust ROI(s) that exceed frame dimensions %%%%%%    */
      /* Although ROI(s) are also checked later in function ROIMSIR, check here as well so that any */
      /* overshoots from smoothing don't affect the interpolation operations in function  */
      /* ROIMSIR_Interpolate, which occurs before the check by ROIMSIR. Also, before the check by ROIMSIR, */
      /* ROIs returned here will influence variable ROIOutBeforeFrameByFrameSmoothing_FR or  */
      /* ROIOutBeforeFrameByFrameSmoothing_SR (assigned in function ROIMSIR), and this variable needs to be */
      /* within frame dimensions for later use in function WriteFaceVideo.  */
      /* Note: used during all calls: during the first read and during both the pre-processing and */
      /* post-processing steps of the second read.  */
      /* Note: although it may seem unlikely for the smoothing of ROIs to result in values outside of frame */
      /* dimensions, this might occur when, for example, both the width and the X-coordinate increased or   */
      /* both the height and the Y-coordinate increased. */
      /* Adjust any coordinates that exceed frame dimensions */
      /* M x 4 matrix (229 x 4 during first-read operations); type int16. */
      /* Note: ROIAdjustIfExceedsFrameDims is a custom function located within folder 'FacePulseRate'. */
      i = ROIBlockFaceSkin_Temp->size[0] * ROIBlockFaceSkin_Temp->size[1];
      ROIBlockFaceSkin_Temp->size[0] = c_ROIBlockDetectionFaceSkinLinI->size[0];
      ROIBlockFaceSkin_Temp->size[1] = 4;
      emxEnsureCapacity_int16_T(ROIBlockFaceSkin_Temp, i);
      Sum = c_ROIBlockDetectionFaceSkinLinI->size[0];
      for (i = 0; i < Sum; i++) {
        ROIBlockFaceSkin_Temp->data[i] = ROINoPrevCallsBlock_SR->
          data[c_ROIBlockDetectionFaceSkinLinI->data[i] - 1];
      }

      for (i = 0; i < Sum; i++) {
        ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0]] =
          ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->data[i]
          + ROINoPrevCallsBlock_SR->size[0]) - 1];
      }

      for (i = 0; i < Sum; i++) {
        ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 2] =
          ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->data[i]
          + ROINoPrevCallsBlock_SR->size[0] * 2) - 1];
      }

      for (i = 0; i < Sum; i++) {
        ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 3] =
          ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->data[i]
          + ROINoPrevCallsBlock_SR->size[0] * 3) - 1];
      }

      /* ROIAdjustIfExceedsFrameDims   Verify whether proposed widths and heights of ROIs exceed frame  */
      /*                               dimensions and, if so, modify them to conform to frame dimensions. */
      /*                                */
      /*     Helper function to function FacePulseRate. */
      /*     Within function FacePulseRate, called by functions ROIResize, ROIMeans_FirstRead_Extrapolate, */
      /*     SkinDetect_EnlargeROI, ROIMSIR, ROIMSIR_MatchSize, ROIMSIR_DetectionSmooth,   */
      /*     ROIMSIR_Interpolate, and ROIMSIR_FrameByFrameSmooth.    */
      /*  */
      /*  */
      /*     Code Generation */
      /*     --------------- */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /*  */
      /*  */
      /*     Description */
      /*     ----------- */
      /*  */
      /*     This function verifies that ROIs that have had modifications to their sizes are still within */
      /*     the dimensions of the frame. If not, this function adjusts the dimensions (and, consequently,   */
      /*     the spatial coordinates) to conform to the frame dimensions. */
      /*  */
      /*     Note:  */
      /*  */
      /*     Intended only for use with integer types as rounding is not conducted. For modification for  */
      /*     use with floating-point types, rounding would be necessary as ROI values should be integers. */
      /*  */
      /*  */
      /*     Copyright */
      /*     --------- */
      /*  */
      /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
      /*     the Responsible AI License (RAIL). */
      /* %%%%% Validate inputs %%%%%% */
      /* Exit if empty */
      if (c_ROIBlockDetectionFaceSkinLinI->size[0] != 0) {
        /* Validate whether input ROIsProposed is type int16. */
        /* Must be an integer type because no rounding is conducted. */
        /* Should be type int16 because the function is implemented to assign values of this type. */
        /* A non-matching type would be due to an implementation error. */
        /* %%%%% Running in code generation %%%%%% */
        /* When running in code generation, use for-loops. When running in Matlab code, use vectorization. */
        /* code generation running */
        /* Inline function */
        i = c_ROIBlockDetectionFaceSkinLinI->size[0];
        for (b_i = 0; b_i < i; b_i++) {
          /* %%%%% --- Verify, and adjust if necessary, X-coordinates and widths %%%%%% */
          /* Adjust left-side X-coordinate if exceeds frame dimensions: */
          WidthNew_ith = ROIBlockFaceSkin_Temp->data[b_i];
          if (WidthNew_ith < 1) {
            WidthNew_ith = 1;

            /* recent code mod */
            ROIBlockFaceSkin_Temp->data[b_i] = 1;
          } else {
            if (WidthNew_ith > VidObjWidth) {
              WidthNew_ith = VidObjWidth;

              /* recent code mod */
              ROIBlockFaceSkin_Temp->data[b_i] = VidObjWidth;
            }
          }

          /* Adjust right-side X-coordinate if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(WidthNew_ith +
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 2])
                                - 1);
          if (Width_ith > VidObjWidth) {
            Width_ith = VidObjWidth;
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 2]
              = (int16_T)((int16_T)(VidObjWidth - WidthNew_ith) + 1);
          } else {
            if (Width_ith < 1) {
              Width_ith = 1;
              WidthNew_ith = 1;
              ROIBlockFaceSkin_Temp->data[b_i] = 1;
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                2] = 1;
            }
          }

          /* Adjust width if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(Width_ith - WidthNew_ith) + 1);
          if (Width_ith > VidObjWidth) {
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 2]
              = VidObjWidth;
          } else {
            if (Width_ith < 1) {
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                2] = 1;
            }
          }

          /* %%%%% --- Verify, and adjust if necessary, Y-coordinates and heights %%%%%% */
          /* Adjust top-side Y-coordinate if exceeds frame dimensions: */
          Height_ith = ROIBlockFaceSkin_Temp->data[b_i +
            ROIBlockFaceSkin_Temp->size[0]];
          if (Height_ith < 1) {
            Height_ith = 1;

            /* recent code mod */
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0]] =
              1;
          } else {
            if (Height_ith > VidObjHeight) {
              Height_ith = VidObjHeight;

              /* recent code mod */
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0]] =
                VidObjHeight;
            }
          }

          /* Adjust bottom-side Y-coordinate if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(Height_ith +
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 3])
                                - 1);
          if (Width_ith > VidObjHeight) {
            Width_ith = VidObjHeight;
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 3]
              = (int16_T)((int16_T)(VidObjHeight - Height_ith) + 1);
          } else {
            if (Width_ith < 1) {
              Width_ith = 1;
              Height_ith = 1;
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0]] =
                1;
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                3] = 1;
            }
          }

          /* Adjust height value if exceeds frame dimensions: */
          HeightNew_ith = (int16_T)((int16_T)(Width_ith - Height_ith) + 1);
          if (HeightNew_ith > VidObjHeight) {
            ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] * 3]
              = VidObjHeight;
          } else {
            if (HeightNew_ith < 1) {
              ROIBlockFaceSkin_Temp->data[b_i + ROIBlockFaceSkin_Temp->size[0] *
                3] = 1;
            }
          }
        }

        /* %%%%% Code generation not running %%%%%% */
      } else {
        /* Exit function */
      }

      /* end function */
      /* ============================================================================================= */
      /* Code-generation and build script */
      /* ============================================================================================= */
      /* Code-generation and build script used to generate C-language code and create the compiled version  */
      /* (ROIAdjustIfExceedsFrameDims_mex) of the function. */
      /* { */
      /*  */
      /* %%%%% Specify variable-size input arguments %%%%%% */
      /*  */
      /* See Matlab documentation for coder.typeof. */
      /*  */
      /*                                   Example Code               Upp. Bounds   Var. Size (T/F)  Type */
      /* ROIsProposedCode   = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],     [1, 0] );        %int16 */
      /*            */
      /*        */
      /* %%%%% Specify fixed-size input arguments %%%%%% */
      /*  */
      /* VidObjWidthCode  = int16(0);          */
      /* VidObjHeightCode = int16(0); */
      /*                    */
      /*  */
      /* %%%%% Set configurations to increase performance %%%%%% */
      /*  */
      /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
      /* "Optimization Strategies" */
      /*  */
      /* cfg = coder.config('mex'); */
      /* cfg.GlobalDataSyncMethod = 'NoSync'; */
      /* cfg.ConstantInputs = 'IgnoreValues'; */
      /* cfg.ExtrinsicCalls = true; %permit to show assert error */
      /* cfg.SaturateOnIntegerOverflow = false; */
      /* cfg.IntegrityChecks = false; */
      /* cfg.ResponsivenessChecks = false; */
      /*  */
      /*  */
      /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
      /*  */
      /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
      /*  */
      /* The flags are specified as part of the code-generation configuration object. A custom function, */
      /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
      /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
      /* Matlab guidance found in */
      /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
      /*  */
      /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
      /* a character vector prior to execution of the codegen command. */
      /*  */
      /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
      /*  */
      /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
      /* is not present in the base workspace. */
      /*  */
      /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
      /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
      /* character vector to maintain the charater vector, */
      /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
      /*  */
      /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
      /*  */
      /* Assign to code-generation configuration object */
      /* cfg.PostCodeGenCommand = setbuildargsAsText; */
      /*  */
      /*  */
      /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
      /*  */
      /* codegen ROIAdjustIfExceedsFrameDims.m -report -config cfg -args {ROIsProposedCode, VidObjWidthCode, VidObjHeightCode} */
      /*                  */
      /* } */
      Sum = ROIBlockFaceSkin_Temp->size[0];
      for (i = 0; i < Sum; i++) {
        ROINoPrevCallsBlock_SR->data[c_ROIBlockDetectionFaceSkinLinI->data[i] -
          1] = ROIBlockFaceSkin_Temp->data[i];
      }

      for (i = 0; i < Sum; i++) {
        ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->data[i] +
          ROINoPrevCallsBlock_SR->size[0]) - 1] = ROIBlockFaceSkin_Temp->data[i
          + ROIBlockFaceSkin_Temp->size[0]];
      }

      for (i = 0; i < Sum; i++) {
        ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->data[i] +
          ROINoPrevCallsBlock_SR->size[0] * 2) - 1] =
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 2];
      }

      for (i = 0; i < Sum; i++) {
        ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->data[i] +
          ROINoPrevCallsBlock_SR->size[0] * 3) - 1] =
          ROIBlockFaceSkin_Temp->data[i + ROIBlockFaceSkin_Temp->size[0] * 3];
      }

      /* Adjust any coordinates that exceed frame dimensions */
      /* N detections x 4 matrix (:229 x 4 during first-read operations); type int16. */
      /* Note: ROIAdjustIfExceedsFrameDims is a custom function located within folder 'FacePulseRate'. */
      /* ROIAdjustIfExceedsFrameDims   Verify whether proposed widths and heights of ROIs exceed frame  */
      /*                               dimensions and, if so, modify them to conform to frame dimensions. */
      /*                                */
      /*     Helper function to function FacePulseRate. */
      /*     Within function FacePulseRate, called by functions ROIResize, ROIMeans_FirstRead_Extrapolate, */
      /*     SkinDetect_EnlargeROI, ROIMSIR, ROIMSIR_MatchSize, ROIMSIR_DetectionSmooth,   */
      /*     ROIMSIR_Interpolate, and ROIMSIR_FrameByFrameSmooth.    */
      /*  */
      /*  */
      /*     Code Generation */
      /*     --------------- */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /*  */
      /*  */
      /*     Description */
      /*     ----------- */
      /*  */
      /*     This function verifies that ROIs that have had modifications to their sizes are still within */
      /*     the dimensions of the frame. If not, this function adjusts the dimensions (and, consequently,   */
      /*     the spatial coordinates) to conform to the frame dimensions. */
      /*  */
      /*     Note:  */
      /*  */
      /*     Intended only for use with integer types as rounding is not conducted. For modification for  */
      /*     use with floating-point types, rounding would be necessary as ROI values should be integers. */
      /*  */
      /*  */
      /*     Copyright */
      /*     --------- */
      /*  */
      /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
      /*     the Responsible AI License (RAIL). */
      /* %%%%% Validate inputs %%%%%% */
      /* Exit if empty */
      if (c_NoPrevCallsBlock_ROIDetection->size[0] != 0) {
        /* Validate whether input ROIsProposed is type int16. */
        /* Must be an integer type because no rounding is conducted. */
        /* Should be type int16 because the function is implemented to assign values of this type. */
        /* A non-matching type would be due to an implementation error. */
        /* %%%%% Running in code generation %%%%%% */
        /* When running in code generation, use for-loops. When running in Matlab code, use vectorization. */
        /* code generation running */
        /* Inline function */
        i = c_NoPrevCallsBlock_ROIDetection->size[0];
        for (b_i = 0; b_i < i; b_i++) {
          /* %%%%% --- Verify, and adjust if necessary, X-coordinates and widths %%%%%% */
          /* Adjust left-side X-coordinate if exceeds frame dimensions: */
          WidthNew_ith = c_NoPrevCallsBlock_ROIDetection->data[b_i];
          if (WidthNew_ith < 1) {
            WidthNew_ith = 1;

            /* recent code mod */
            c_NoPrevCallsBlock_ROIDetection->data[b_i] = 1;
          } else {
            if (WidthNew_ith > VidObjWidth) {
              WidthNew_ith = VidObjWidth;

              /* recent code mod */
              c_NoPrevCallsBlock_ROIDetection->data[b_i] = VidObjWidth;
            }
          }

          /* Adjust right-side X-coordinate if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(WidthNew_ith +
            c_NoPrevCallsBlock_ROIDetection->data[b_i +
            c_NoPrevCallsBlock_ROIDetection->size[0] * 2]) - 1);
          if (Width_ith > VidObjWidth) {
            Width_ith = VidObjWidth;
            c_NoPrevCallsBlock_ROIDetection->data[b_i +
              c_NoPrevCallsBlock_ROIDetection->size[0] * 2] = (int16_T)((int16_T)
              (VidObjWidth - WidthNew_ith) + 1);
          } else {
            if (Width_ith < 1) {
              Width_ith = 1;
              WidthNew_ith = 1;
              c_NoPrevCallsBlock_ROIDetection->data[b_i] = 1;
              c_NoPrevCallsBlock_ROIDetection->data[b_i +
                c_NoPrevCallsBlock_ROIDetection->size[0] * 2] = 1;
            }
          }

          /* Adjust width if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(Width_ith - WidthNew_ith) + 1);
          if (Width_ith > VidObjWidth) {
            c_NoPrevCallsBlock_ROIDetection->data[b_i +
              c_NoPrevCallsBlock_ROIDetection->size[0] * 2] = VidObjWidth;
          } else {
            if (Width_ith < 1) {
              c_NoPrevCallsBlock_ROIDetection->data[b_i +
                c_NoPrevCallsBlock_ROIDetection->size[0] * 2] = 1;
            }
          }

          /* %%%%% --- Verify, and adjust if necessary, Y-coordinates and heights %%%%%% */
          /* Adjust top-side Y-coordinate if exceeds frame dimensions: */
          Height_ith = c_NoPrevCallsBlock_ROIDetection->data[b_i +
            c_NoPrevCallsBlock_ROIDetection->size[0]];
          if (Height_ith < 1) {
            Height_ith = 1;

            /* recent code mod */
            c_NoPrevCallsBlock_ROIDetection->data[b_i +
              c_NoPrevCallsBlock_ROIDetection->size[0]] = 1;
          } else {
            if (Height_ith > VidObjHeight) {
              Height_ith = VidObjHeight;

              /* recent code mod */
              c_NoPrevCallsBlock_ROIDetection->data[b_i +
                c_NoPrevCallsBlock_ROIDetection->size[0]] = VidObjHeight;
            }
          }

          /* Adjust bottom-side Y-coordinate if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(Height_ith +
            c_NoPrevCallsBlock_ROIDetection->data[b_i +
            c_NoPrevCallsBlock_ROIDetection->size[0] * 3]) - 1);
          if (Width_ith > VidObjHeight) {
            Width_ith = VidObjHeight;
            c_NoPrevCallsBlock_ROIDetection->data[b_i +
              c_NoPrevCallsBlock_ROIDetection->size[0] * 3] = (int16_T)((int16_T)
              (VidObjHeight - Height_ith) + 1);
          } else {
            if (Width_ith < 1) {
              Width_ith = 1;
              Height_ith = 1;
              c_NoPrevCallsBlock_ROIDetection->data[b_i +
                c_NoPrevCallsBlock_ROIDetection->size[0]] = 1;
              c_NoPrevCallsBlock_ROIDetection->data[b_i +
                c_NoPrevCallsBlock_ROIDetection->size[0] * 3] = 1;
            }
          }

          /* Adjust height value if exceeds frame dimensions: */
          HeightNew_ith = (int16_T)((int16_T)(Width_ith - Height_ith) + 1);
          if (HeightNew_ith > VidObjHeight) {
            c_NoPrevCallsBlock_ROIDetection->data[b_i +
              c_NoPrevCallsBlock_ROIDetection->size[0] * 3] = VidObjHeight;
          } else {
            if (HeightNew_ith < 1) {
              c_NoPrevCallsBlock_ROIDetection->data[b_i +
                c_NoPrevCallsBlock_ROIDetection->size[0] * 3] = 1;
            }
          }
        }

        /* %%%%% Code generation not running %%%%%% */
      } else {
        /* Exit function */
      }

      /* end function */
      /* ============================================================================================= */
      /* Code-generation and build script */
      /* ============================================================================================= */
      /* Code-generation and build script used to generate C-language code and create the compiled version  */
      /* (ROIAdjustIfExceedsFrameDims_mex) of the function. */
      /* { */
      /*  */
      /* %%%%% Specify variable-size input arguments %%%%%% */
      /*  */
      /* See Matlab documentation for coder.typeof. */
      /*  */
      /*                                   Example Code               Upp. Bounds   Var. Size (T/F)  Type */
      /* ROIsProposedCode   = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],     [1, 0] );        %int16 */
      /*            */
      /*        */
      /* %%%%% Specify fixed-size input arguments %%%%%% */
      /*  */
      /* VidObjWidthCode  = int16(0);          */
      /* VidObjHeightCode = int16(0); */
      /*                    */
      /*  */
      /* %%%%% Set configurations to increase performance %%%%%% */
      /*  */
      /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
      /* "Optimization Strategies" */
      /*  */
      /* cfg = coder.config('mex'); */
      /* cfg.GlobalDataSyncMethod = 'NoSync'; */
      /* cfg.ConstantInputs = 'IgnoreValues'; */
      /* cfg.ExtrinsicCalls = true; %permit to show assert error */
      /* cfg.SaturateOnIntegerOverflow = false; */
      /* cfg.IntegrityChecks = false; */
      /* cfg.ResponsivenessChecks = false; */
      /*  */
      /*  */
      /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
      /*  */
      /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
      /*  */
      /* The flags are specified as part of the code-generation configuration object. A custom function, */
      /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
      /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
      /* Matlab guidance found in */
      /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
      /*  */
      /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
      /* a character vector prior to execution of the codegen command. */
      /*  */
      /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
      /*  */
      /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
      /* is not present in the base workspace. */
      /*  */
      /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
      /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
      /* character vector to maintain the charater vector, */
      /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
      /*  */
      /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
      /*  */
      /* Assign to code-generation configuration object */
      /* cfg.PostCodeGenCommand = setbuildargsAsText; */
      /*  */
      /*  */
      /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
      /*  */
      /* codegen ROIAdjustIfExceedsFrameDims.m -report -config cfg -args {ROIsProposedCode, VidObjWidthCode, VidObjHeightCode} */
      /*                  */
      /* } */
      /* %%%%% Output validation %%%%%% */
      /* First-read operations */
      /* Check whether any ROIs assigned in the current function equal zero. */
      /* The operations of this function were intended to prevent values of zero, so such a value is */
      /* likely due to an implementation error in this function.      */
      /* Loop across columns */
      /* Loop across ROIs rows that correspond to ROIs assigned in the current function */
      for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
        if (ROINoPrevCallsBlock_SR->data[c_ROIBlockDetectionFaceSkinLinI->data[j]
            - 1] == 0) {
          /* Throw exception */
          /* Called as extrinsic so that stack trace can be displayed. */
          /* Note: '%.0f' = floating point with no decimals. */
          error(emlrt_marshallOut(cv3), g_emlrt_marshallOut(cv20), &l_emlrtMCI);
        }
      }

      /* Loop across ROIs rows that correspond to ROIs assigned in the current function */
      for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
        if (ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->
             data[j] + ROINoPrevCallsBlock_SR->size[0]) - 1] == 0) {
          /* Throw exception */
          /* Called as extrinsic so that stack trace can be displayed. */
          /* Note: '%.0f' = floating point with no decimals. */
          error(emlrt_marshallOut(cv3), g_emlrt_marshallOut(cv20), &l_emlrtMCI);
        }
      }

      /* Loop across ROIs rows that correspond to ROIs assigned in the current function */
      for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
        if (ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->
             data[j] + ROINoPrevCallsBlock_SR->size[0] * 2) - 1] == 0) {
          /* Throw exception */
          /* Called as extrinsic so that stack trace can be displayed. */
          /* Note: '%.0f' = floating point with no decimals. */
          error(emlrt_marshallOut(cv3), g_emlrt_marshallOut(cv20), &l_emlrtMCI);
        }
      }

      /* Loop across ROIs rows that correspond to ROIs assigned in the current function */
      for (j = 0; j < NDetectionsFaceSkin_SR; j++) {
        if (ROINoPrevCallsBlock_SR->data[(c_ROIBlockDetectionFaceSkinLinI->
             data[j] + ROINoPrevCallsBlock_SR->size[0] * 3) - 1] == 0) {
          /* Throw exception */
          /* Called as extrinsic so that stack trace can be displayed. */
          /* Note: '%.0f' = floating point with no decimals. */
          error(emlrt_marshallOut(cv3), g_emlrt_marshallOut(cv20), &l_emlrtMCI);
        }
      }

      /* Check whether the ROI size is unreasonably small */
      /* Such a small size is likely due to an implementation error in this function. */
      /* This check is intended to be run when testing new implementations, as small ROI sizes are an */
      /* indication of a implementation error. As occassional values below 20 may be considered */
      /* acceptable, this check is not intended for use outside of testing. "Occassional" in this case    */
      /* might be defined as a few occurances out of 10,000. Flag ExpectedBehaviorTestTF enables the */
      /* check.     */
      if (ExpectedBehaviorTestTF) {
        i = x->size[0] * x->size[1];
        x->size[0] = c_ROIBlockDetectionFaceSkinLinI->size[0];
        x->size[1] = 2;
        emxEnsureCapacity_boolean_T(x, i);
        Sum = c_ROIBlockDetectionFaceSkinLinI->size[0];
        for (i = 0; i < Sum; i++) {
          x->data[i] = (ROINoPrevCallsBlock_SR->data
                        [(c_ROIBlockDetectionFaceSkinLinI->data[i] +
                          ROINoPrevCallsBlock_SR->size[0] * 2) - 1] < 20);
        }

        for (i = 0; i < Sum; i++) {
          x->data[i + x->size[0]] = (ROINoPrevCallsBlock_SR->data
            [(c_ROIBlockDetectionFaceSkinLinI->data[i] +
              ROINoPrevCallsBlock_SR->size[0] * 3) - 1] < 20);
        }

        winNew = x->size[0] << 1;
        c_x = *x;
        e_VideoReadConfig_FrameIdx_FR[0] = winNew;
        c_x.size = &e_VideoReadConfig_FrameIdx_FR[0];
        c_x.numDimensions = 1;
        if (any(&c_x)) {
          /* Display warning */
          /* Note: function warning() not available for code generation, so it must have previously */
          /* been declared as extrinsic. */
          warning(emlrt_marshallOut(cv3), h_emlrt_marshallOut(cv25), &m_emlrtMCI);
        }
      }

      /* end function */
      /* ============================================================================================= */
      /* Code-generation and build script */
      /* ============================================================================================= */
      /* Note: this function is not currently used as a compiled function as it is nested within a */
      /* compiled function, ROIMSIR_mex. */
      /* Code-generation and build script used to generate C-language code and create the compiled version  */
      /* (ROIMSIR_DetectionSmooth_mex) of the function. */
      /* { */
      /*             */
      /*       */
      /* %%%%% Specify variable-size input arguments %%%%%% */
      /*  */
      /* See Matlab documentation for coder.typeof. */
      /*  */
      /*                                                      Example Code                 Upp. Bounds  Var. Size (T/F)  Type */
      /* ROINoPrevCallsBlockCode               = coder.typeof( zeros(500, 4, 'int16'),      [inf, 4],    [1, 0] );        %int16 */
      /* ROIBlockDetectionFaceLogIdxCode       = coder.typeof( false(500, 1),               [inf, 1],    [1, 0] );        %logical */
      /* ROIBlockDetectionSkinLogIdxCode       = coder.typeof( false(500, 1),               [inf, 1],    [1, 0] );        %logical */
      /* ROIBlockDetectionFaceSkinLogIdxCode   = coder.typeof( false(500, 1),               [inf, 1],    [1, 0] );        %logical  */
      /* VideoReadConfig_FrameIdxCode          = coder.typeof( zeros(1, 500, 'int32'),      [1, inf],    [0, 1] );        %uint32  */
      /*                */
      /*     */
      /* %%%%% Specify fixed-size input arguments %%%%%% */
      /*  */
      /* VidObjWidthCode                              = int16(0);          */
      /* VidObjHeightCode                             = int16(0); */
      /* FirstReadTFCode                              = false; */
      /* SecondReadPostProcessingTFCode               = false; */
      /* RowToReturnFullLinIdxCode                    = int32(0); */
      /* FaceDetectConfig_ROIFaceSmoothingWindowCode  = double(0); */
      /* SkinDetectConfig_ROISkinSmoothingWindowCode  = double(0); */
      /*  */
      /*  */
      /* %%%%% Set configurations to increase performance %%%%%% */
      /*  */
      /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
      /* "Optimization Strategies" */
      /* cfg = coder.config('mex'); */
      /* cfg.GlobalDataSyncMethod = 'NoSync'; */
      /* cfg.ConstantInputs = 'IgnoreValues'; */
      /* cfg.ExtrinsicCalls = false; */
      /* cfg.SaturateOnIntegerOverflow = false; */
      /* cfg.IntegrityChecks = false; */
      /* cfg.ResponsivenessChecks = false; */
      /*  */
      /*  */
      /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
      /*  */
      /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
      /*  */
      /* The flags are specified as part of the code-generation configuration object. A custom function, */
      /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
      /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
      /* Matlab guidance found in */
      /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
      /*  */
      /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
      /* a character vector prior to execution of the codegen command. */
      /*  */
      /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
      /*  */
      /* Argument buildInfo: this variable is assign by the caller (the codegen command executed  */
      /* below) and is not present in the base workspace. */
      /*  */
      /* Second argument: specify a cell array of compiler-specific flags, where each flag is a  */
      /* character vector. As function setbuildargs will be evaluated from text, use double ' quotes for  */
      /* each character vector to maintain the charater vector, */
      /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
      /*  */
      /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
      /*  */
      /* Assign to code-generation configuration object */
      /* cfg.PostCodeGenCommand = setbuildargsAsText; */
      /*  */
      /*  */
      /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
      /*  */
      /* codegen ROIMSIR_DetectionSmooth.m -config cfg -args {ROINoPrevCallsBlockCode, ROIBlockDetectionFaceLogIdxCode, ROIBlockDetectionSkinLogIdxCode, ROIBlockDetectionFaceSkinLogIdxCode, VidObjWidthCode, VidObjHeightCode, FaceDetectConfig_ROIFaceSmoothingWindowCode, SkinDetectConfig_ROISkinSmoothingWindowCode, FirstReadTFCode, SecondReadPostProcessingTFCode, VideoReadConfig_FrameIdxCode, RowToReturnFullLinIdxCode} */
      /*               */
      /* } */
    }

    /*  %%%%%%%%%%%%%%%%%% */
    /* %% Interpolation %%% */
    /* %%%%%%%%%%%%%%%%%%%% */
    /* Interpolate or extrapolate ROI(s) that do not have a corresponding face-detection or  */
    /* skin-detection algorithm detection. */
    /* Smooth ROIs that correspond to face-detection and skin-detection algorithm detections to help   */
    /* remove the effect of false positives and to add stability. False positives may be reduced because    */
    /* they sometimes occur as outliers, and smoothing should reduce the effect of outliers. Increasing   */
    /* stability across ROIs may help keep the ROI more oriented on the same area of the face, which may  */
    /* help increase accuracy of pulse rate calculations. Smooth with a moving mean. */
    /* Note: in the first-read condition, tildes (~) indicate output arguments only used in second-read  */
    /* operations; in the second-read condition, tildes indicate output arguments only used in first-read  */
    /* operations. */
    /* Note: ROIMSIR_Interpolate is a custom function located within folder 'FacePulseRate'. */
    /* First-read operations */
    if (FirstReadTF) {
      /*  1 x 4 row vector; type int16 */
      /*  scalar; type int32 */
      /* ROIMSIR_Interpolate    Interpolate or extrapolate ROIs for frames without a detection. */
      /*  */
      /*     Helper function to function FacePulseRate.  */
      /*     Within function FacePulseRate, called by function ROIMSIR. */
      /*  */
      /*  */
      /*     Code Generation */
      /*     --------------- */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /*  */
      /*  */
      /*     Description */
      /*     ----------- */
      /*  */
      /*     Interpolate or extrapolate X-, Y-coordinate, width, and height of ROI(s) that do not have a  */
      /*     corresponding face-detection or skin-detection algorithm detection. A detection will not be  */
      /*     present if no detection algorithm was able to make a detection or if the frame was skipped.   */
      /*  */
      /*     Linear interpolation is used rather than less conservative methods, such as PCHIP, to reduce   */
      /*     sudden fluctuations that do not reflect head movement. For extrapolation, use the  */
      /*     nearest-neighbor method rather than the linear method. */
      /*  */
      /*     Custom function Interp conducts most of the interpolation / extrapolation operations. Interp */
      /*     conducts linear interpolation or nearest-neighbor extrapolation. It also conducts various  */
      /*     checks to determine whether ROI appears valid.  */
      /*  */
      /*     If there are not at least two ROIs that correspond to detections within the block of frames */
      /*     used, linear interpolation / extrapolation is not possible. In this case, there may be at  */
      /*     least one ROI that corresponds to a detection within the block. If this is the case, assign */
      /*     this ROI in place of interpolation / extrapolation. Otherwise, assign the dimensions of the */
      /*     full frame as the ROI; for example, if the frame dimensions are 720 x 1280, assign the ROI as */
      /*     [1, 1, 1280, 720]. During the second read, if there are not two ROIs that correspond to  */
      /*     detections, the frame dimensions are assigned rather than using a single ROI that corresponds */
      /*     to a detection. This is done because the block size for the second read is quite large, and  */
      /*     the single ROI that corresponds to a detection may not be representative of all frames within */
      /*     the block. */
      /*  */
      /*     Arguments to function Interp: */
      /*  */
      /*     Note: see function Interp for a description of input validation. */
      /*  */
      /*    - TimestampBlockDetections                  = Time points used for interpolation. N-Detections    */
      /*                                                  x 1 column vector; type single.                                                  */
      /*    - NoPrevCallsBlock_ROIDetections            = Values used for interpolation. N-Detections x 4 */
      /*                                                  matrix; type int16. */
      /*    - TimestampTarget                           = Time point(s) at which interpolation to be    */
      /*                                                  assigned. For first-read operations, only one  */
      /*                                                  time point used; for second-read operations, many */
      /*                                                  may be used. Scalar or column vector; type  */
      /*                                                  single. */
      /*    - LinearExtrapTF                            = False: use nearest-neighbor rather than linear   */
      /*                                                  method when TimestampTarget is outside of the */
      /*                                                  domain of TimestampBlockDetections (i.e., when */
      /*                                                  extrapolation occurs). See the section below for */
      /*                                                  a description of these checks. Scalar; type  */
      /*                                                  logical. */
      /*    - ValidityChecksTF                          = Flag whether to check whether the interpolated / */
      /*                                                  extrapolated ROI seems reasonable. See function                                                  */
      /*    - ROIGeneralConfig_ROIMSIR_DiffMaxDetection = The threshold specifying the maximum  */
      /*                                                  absolute-value difference between the X- and    */
      /*                                                  Y-coordinates of the interpolated / extrapolated                                                                                         */
      /*                                                  ROI and the ROI corresponding to the     */
      /*                                                  temporally-nearest previous detection. The value */
      /*                                                  for this argument is currently assigned by */
      /*                                                  function ROIGeneralConfig_Setup. Scalar; type */
      /*                                                  int16. */
      /*    - ROINoResizeBlock_Previous                 = ROI X- and Y-coordinates of the previous frames;    */
      /*                                                  checked against threshold                                                    */
      /*                                                  ROIGeneralConfig_ROIMSIR_DiffMaxAdjacent. If size */
      /*                                                  of input is 0 x 2, this check is not conducted. */
      /*                                                  This check is conducted for first-read but not  */
      /*                                                  second-read operations. For second-read  */
      /*                                                  operations, this check is instead conducted after  */
      /*                                                  the call to this function. This is implemented */
      /*                                                  because, during the second-read operations,  */
      /*                                                  there may not be previous frames available at the */
      /*                                                  time the function is called. More specifically, */
      /*                                                  because the second-read ROIs are interpolated */
      /*                                                  at one time within the function, these  */
      /*                                                  interpolated ROIs would not be available for */
      /*                                                  input into function. N x 2 row vector; type  */
      /*                                                  int16.  */
      /*    - ROIGeneralConfig_ROIMSIR_DiffMaxAdjacent  = The threshold specifying the maximum   */
      /*                                                  absolute-value difference between the X- and    */
      /*                                                  Y-coordinates of the interpolated / extrapolated                                                                                       */
      /*                                                  ROI and the ROI of the previous frame. The value */
      /*                                                  for this argument is currently assigned by */
      /*                                                  function ROIGeneralConfig_Setup. Scalar; type  */
      /*                                                  int16.  */
      /*                                                                                                    */
      /*    - VidObjWidth */
      /*    - VidObjHeight  */
      /*  */
      /*    Checks enabled by the ValidityChecksTF argument to function Interp: */
      /*  */
      /*    - Checking whether the difference between an interpolated value and a nearby actual value is */
      /*      within a specified threshold (ROIGeneralConfig_ROIMSIR_DiffMax). If not, this may be an */
      /*      indication of an overshoot; in this case, the interpolated value is changed to the maximum  */
      /*      value specified by the threshold. This check and adjustment are only applied to an  */
      /*      interpolated value corresponding to the X- or Y-coordinate (rather than height or width) of  */
      /*      the ROI. The check is not applied to height or width as testing has indicated that an  */
      /*      overshoot is not as common for height or width.  */
      /*    - Checking whether an interpolated value corresponding to ROI height or width is above 20. If  */
      /*      not, the interpolated value is recalculated by conducting nearest-neighbor extrapolation. A */
      /*      height or width below 20 is considered to be too small for the size of faces expected in a  */
      /*      video.     */
      /*    - Checking whether an interpolated value is within the frame dimensions (minimum of 1 and */
      /*      maximums of VidObjWidth and VidObjHeight). If not, the interpolated value is changed to be */
      /*      bounded by the frame dimensions. */
      /*  */
      /*  */
      /*     Copyright */
      /*     --------- */
      /*  */
      /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), September, 2020. Licensed under the MIT License    */
      /*     and the Responsible AI License (RAIL).  */
      /* %%%%% Code generation settings %%%%%% */
      /* Inline function */
      /* Call function as extrinsic */
      /* See notes where warning() used. */
      /* Call function as extrinsic so that stack trace can be displayed */
      /* Declare variables: */
      /*                                          Upp. Bounds  Var. Size (T/F) */
      /* %%%%% Preallocate variables %%%%%% */
      /* Preallocate linear index of interpolated frame */
      /* Note: If not reassigned, 0 will act as a flag to other functions to indicate no ROIs were  */
      /* interpolated. */
      /* %%%%% Arguments to function Interp common to first- and second-read operations %%%%%% */
      /* False = use the nearest-neighbor method rather than the linear method for extrapolation. */
      /* Conduct checks on the validity of the interpolation / extrapolated ROI(s). */
      /* %%%%% Operations when called from first-read operations %%%%%%       */
      /* Assert row size as zero because this variable not used in first-read operations */
      /* This may help remove dynamic memory allocation for this variable. */
      /* Note: ROIMSIR_InterpolateFR is a custom function located within folder 'FacePulseRate'. */
      /*  1 x 4 row vector; type int16 */
      /*  scalar; type int32 */
      /* ROIMSIR_InterpolateFR   Interpolate or extrapolate an ROI if the target frame does not correspond */
      /*                         to a detection. Used during the first-read operations. */
      /*                          */
      /*     Helper function to function FacePulseRate.  */
      /*     Within function FacePulseRate, called by function ROIMSIR_Interpolate. */
      /*  */
      /*  */
      /*     Code Generation */
      /*     --------------- */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /*  */
      /*  */
      /*     Description */
      /*     ----------- */
      /*  */
      /*     Interpolate or extrapolate an ROI if the target frame does not correspond to a detection. If  */
      /*     there are not at least two ROIs that correspond to detections within the block of frames used, */
      /*     linear interpolation / extrapolation is not possible. In this case, there may be at least one   */
      /*     ROI that corresponds to a detection within the block. If this is the case, assign this ROI in */
      /*     place of interpolation / extrapolation. Otherwise, assign the dimensions of the full frame as */
      /*     the ROI; for example, if the frame dimensions are 720 x 1280, assign the ROI as [1, 1, 1280,  */
      /*     720]. */
      /*          */
      /*     A different function, ROIMSIR_InterpolateSR, conducts interpolation / extrapolation during the */
      /*     second-read operations.  */
      /*  */
      /*     For a more detailed description, see function ROIMSIR_Interpolate. */
      /*  */
      /*  */
      /*     Copyright */
      /*     --------- */
      /*  */
      /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), September, 2020. Licensed under the MIT License    */
      /*     and the Responsible AI License (RAIL). */
      /* %%%%% Code generation settings %%%%%% */
      /* Inline function */
      /* %%%%% Initialize variables %%%%%% */
      /* Note: If not reassigned, 0 will act as a flag to other functions to indicate no ROIs were  */
      /* interpolated. */
      /* %%%%% Operation when detection present for target frame %%%%%%     */
      /* If detection found for target frame */
      /* Note: function IsMember is local function. */
      /*  set A */
      /*  set B */
      /*  length set B */
      /* IsMember  Determine whether scalar a is a member of vector B. */
      /*  */
      /*     Helper function to function FacePulseRate.  */
      /*     Within function FacePulseRate, called by functions ROIMSIR and ROIMSIR_InterpolateFR. */
      /*  */
      /*     Code generation:  */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /* Inline function */
      FaceOrSkinTF = false;
      b_i = 0;
      exitg1 = false;
      while ((!exitg1) && (b_i <= NDetectionsFaceSkin_FR - 1)) {
        if (RowToReturnBlockLinIdx_FR + 2 == f_ROIBlockDetectionFaceSkinLinI[b_i])
        {
          FaceOrSkinTF = true;
          exitg1 = true;
        } else {
          b_i++;
        }
      }

      /* end function */
      if (FaceOrSkinTF) {
        /* A detection is present for the current frame; do not interpolate */
        /* 1 x 4 row vector; type int16. */
        ROIOut_FR[0] = ROINoPrevCallsBlock_FR[RowToReturnBlockLinIdx_FR + 1];
        ROIOut_FR[1] = ROINoPrevCallsBlock_FR[RowToReturnBlockLinIdx_FR + 230];
        ROIOut_FR[2] = ROINoPrevCallsBlock_FR[RowToReturnBlockLinIdx_FR + 459];
        ROIOut_FR[3] = ROINoPrevCallsBlock_FR[RowToReturnBlockLinIdx_FR + 688];

        /* Exit function */
      } else {
        /* %%%%% --- Assign ROIs for frames without detections %%%%%%                */
        /* Linear index of frames where ROIs assigned */
        /* Note: these indices may not necessarily be the result of interpolation / extrapolation if */
        /* too few detections were available on which to base interpolation / extrapolation. In that */
        /* case, ROIs will have been assigned using an alternative method. */
        *InterpolatedLinIdx_FR = RowToReturnFullLinIdx_FR;

        /* %%%%% >>>>>> Interpolate / extrapolate target ROI %%%%%% */
        /* Interpolate / extrapolate X-, Y-coordinate, width, and height of target ROI. */
        /* If at least two detections are present within the block */
        /* The detections counted come from both the face- and skin-detection algorithms. */
        /* At least two ROIs corresponding to detections are needed so that they can be used as the */
        /* basis of interpolation or extrapolation. */
        if (NDetectionsFaceSkin_FR > 1) {
          /* Arguments to function Interp for first-read operations: */
          /* Timestamps in block corresponding to the target frame */
          /* Scalar; type single. */
          HeightRatio_Single = TimestampBlock_FR[RowToReturnBlockLinIdx_FR + 1];

          /* NoPrevCallsBlock_ROIDetections = ROIs corresponding to detections that do not have  */
          /*                                  modifications from previous calls to ROIMSIR but do */
          /*                                  have modifications from the current call to ROIMSIR */
          /*                                  (by functions ROIMSIR_MatchSize and  */
          /*                                  ROIMSIR_DetectionSmooth). */
          /*                                  M x 4 matrix; type int16. */
          /* If this is not the first time the function is called from the first read (function */
          /* ROIMeans_FirstRead_TakeMeans). On the first call, the values of the previous ROI will */
          /* be zeros, but this block relies on the previous ROI containing non-zero values. This */
          /* is required by argument ROINoResizeBlock_Previous. */
          if (RowToReturnFullLinIdx_FR != ROIMSIR_FirstFrameLinIdx_FR) {
            /* Previous ROI X- and Y-coordinates without resizing */
            /* A Non-resized ROI is used because the target ROI has not yet been resized (it will  */
            /* be in the final step of function ROIMSIR).  */
            /* 1 x 4 row vector; type int16. */
            /* Note: for a description of the arguments to function Interp, see the description  */
            /* at top.                 */
            /* Note: Interp is a custom function located within folder 'FacePulseRate'.                     */
            /*  Interpolated ROI */
            /*  Time points used for */
            /*  interpolation. */
            /*  Values used for */
            /*  interpolation. */
            /*  Time point at which */
            /*  interpolation to be */
            /*  assigned. */
            /*  False: use nearest-neighbor */
            /*  method for extrapolation. */
            /* Interp   Conduct linear interpolation/extrapolation or nearest-neighbor extrapolation. */
            /*  */
            /*     Helper function to function FacePulseRate.  */
            /*     Within function FacePulseRate, called by functions ROIMeans_FirstRead_ExtrapolateROI,  */
            /*     ROIMSIR_Interpolate and ROIMSIR_FrameByFrameSmooth_InterpFR. */
            /*      */
            /*  */
            /*     Code Generation */
            /*     --------------- */
            /*  */
            /*     Can be called as a Matlab function or used for C-language code generation. */
            /*  */
            /*  */
            /*     Description */
            /*     ----------- */
            /*  */
            /*     When LinearExtrapTF == true, conduct linear interpolation or extrapolation.  */
            /*     When LinearExtrapTF == false, conduct linear interpolation only when xi falls within domain of  */
            /*     x. Otherwise, conduct nearest-neighbor extrapolation. */
            /*  */
            /*     When ValidityChecksTF == true, conduct checks and adjustments on values returned by linear */
            /*     interpolation / extrapolation. These checks and adjustments include ...   */
            /*  */
            /*     - Checking whether the difference between an interpolated value and a nearby actual value is */
            /*       within a specified threshold (DiffMaxActual). If not, this may be an indication of an   */
            /*       overshoot; in this case, the interpolated value is changed to the maximum value specified by  */
            /*       the threshold. This check and adjustment are only applied to an interpolated value  */
            /*       corresponding to the X- or Y-coordinate (rather than height or width) of the ROI. The check  */
            /*       is not applied to height or width as testing has indicated that an overshoot  is not as   */
            /*       common for height or width. */
            /*  */
            /*     - Checking whether an interpolated value corresponding to ROI height or width is above 20. If */
            /*       not, the interpolated value is recalculated by conducting nearest-neighbor extrapolation. A */
            /*       height or width below 20 is considered to be too small for the size of faces expected in a */
            /*       video. */
            /*  */
            /*     - Checking whether an interpolated value is within the frame dimensions (minimum of 1 and */
            /*       maximums of VidObjWidth and VidObjHeight). If not, the interpolated value is changed to be */
            /*       bounded by the frame dimensions. */
            /*  */
            /*     When YArbitrary is non-empty, conduct checks and adjustments on interpolated / extrapolated */
            /*     values. These checks and adjustments include ...   */
            /*  */
            /*     - Checking whether the difference between an interpolated value and a nearby arbitrary value  */
            /*       is within a specified threshold (DiffMaxArbitrary). If not, this may be an indication of an   */
            /*       overshoot; in this case, the interpolated value is changed to the maximum value specified by  */
            /*       the threshold. This check and adjustment are only applied to an interpolated value  */
            /*       corresponding to the X- or Y-coordinate (rather than height or width) of the ROI. The check  */
            /*       is not applied to height or width as testing has indicated that an overshoot is not as   */
            /*       common for height or width. */
            /*  */
            /*     Restrictions: */
            /*  */
            /*     - x is are assumed to increase monotonically and contain unique values. x must contain at */
            /*       least two elements. The number of elements must equal the number of elements of y.                         */
            /*     - xi is assumed to increase monotonically.  */
            /*     - y is assumed to have 4 columns. y must contain at least two elements. The number of elements  */
            /*       must equal the number of elements of x.  */
            /*  */
            /*     This function uses bounded variable sizes to improve efficiency. Ensure that inputs do not */
            /*     exceed the bounds. */
            /*  */
            /*     Inputs: */
            /*  */
            /*     x                = Time values that correspond to values of y. M x 1 column vector; type  */
            /*                        single. */
            /*     y                = Values from which to interpolate. M x :4 matrix; type int16.                    */
            /*     xi               = Time values at which interpolation will occur. The elements do not need to   */
            /*                        be unique. The number of values is not restricted. Column vector; type  */
            /*                        single.                                         */
            /*     LinearExtrapTF   = If true, use the linear method for extrapolation. If false, use the  */
            /*                        nearest-neighbor method. Scalar; type logical. */
            /*     ValidityChecksTF = If true, check whether the interpolated values appears valid. Scalar;  */
            /*                        type logical. */
            /*     DiffMaxActual    = The threshold specifying the maximum absolute-value difference between an  */
            /*                        interpolated / extrapolated value and a previous actual value. Scalar; type  */
            /*                        int16. Threshold only applied when InterpChecksTF == true;      */
            /*     DiffMaxArbitrary = The threshold specifying the maximum absolute-value difference between an  */
            /*                        interpolated / extrapolated value and an arbitrary X- or Y-coordinate   */
            /*                        value, which is specified by YArbitrary. Scalar; type int16.                      */
            /*     YArbitrary       = Arbitary X- and Y-coordinate values used with the threshold specified by  */
            /*                        DiffMaxArbitrary. To disable DiffMaxArbitrary checks, use 0 x 2 input.                         */
            /*                        0 x 2 or 1 x 2 row vector; type int16.                                                                                     */
            /*     VidObjWidth      = The frame width. Scalar; type int16. */
            /*     VidObjHeight     = The frame height. Scalar; type int16. */
            /*  */
            /*  */
            /*     Copyright */
            /*     --------- */
            /*  */
            /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
            /*     the Responsible AI License (RAIL). */
            /* Inline function */
            /* Whether to conduct arbitrary value check */
            /* Length of input time points */
            /* Length of input interpolation timepoints */
            /* This length will equal the length of yi. */
            /* Assert length to prevent dynamic memory allocation by colon operator */
            /* Preallocate output */
            /* Initialize x_idx at 1  */
            /* x_idx is used to search for the value of x that is greater than xi. */
            /* In while loop, the first operation is to increment j by 1; hence, the effective use of x_idx */
            /* starts at 2. */
            /* By initializing x_idx here, rather than after each iteration of i, it is assumed that both x and   */
            /* xi are sorted in order from least to greatest. This assumption improves performance because values  */
            /* of x already matched are not researched (a qualification is that the implementation does research   */
            /* the immediately previous value of x -- see note within loop). If x or xi is not sorted, the    */
            /* initialization of x_idx (setting x_idx to 1) should occur after each iteration of i. */
            Start = 0;

            /* Loop across interpolation times points */
            /* The ith xi value (the ith interpolation point) */
            /* Find the indices of x: x_before_idx and x_after_idx:       */
            /* If ith xi value is to left of domain of x */
            /* Case of extrapolation. */
            if (HeightRatio_Single < c_TimestampBlockDetections_FR_d[0]) {
              /* If linear extrapolation permitted */
              /* Flag indicating ith xi value is to left of domain of x */
              /* Nearest-neighbor extrapolation */
              /* Local function. */
              /* 1 x nColsY row vector; type int16.    */
              /* end local function */
              /* ============================================================================================= */
              /* ExtrapNearest   Nearest-neighbor extrapolation of y at single time point (xi). */
              /* Inline function */
              /* Preallocate output for ith yi values */
              /* If ith xi value is to left of domain of x */
              /* Loop across columns of y */
              /* Assign from first row of y */
              WidthNew_ith = e_NoPrevCallsBlock_ROIDetection[0];

              /* If arbitary check enabled */
              /* Check whether the interpolated X- or Y-coordinate is within a specified distance  */
              /* (DiffMaxArbitrary) from a specified X- or Y-coordinate. */
              /* Local function. */
              /* Scalar; type int16.             */
              /* end local function */
              /* ============================================================================================= */
              /* ArbitraryCheck_XY   Check whether the interpolated / extrapolated X- or Y-coordinate is within a  */
              /*                     specified distance (DiffMaxArbitrary) from a specified X- or Y-coordinate */
              /*                     ( YArbitrary(j) ). */
              /*  */
              /*     Description: */
              /*  */
              /*     Check whether the interpolated / extrapolated X- or Y-coordinate is within a specified  */
              /*     distance (DiffMaxArbitrary) from a specified for X- or Y-coordinate ( YArbitrary(j) ). If so,  */
              /*     set value at maximum of threshold.  */
              /*  */
              /*     Inputs (subset): */
              /*  */
              /*     YArbitrary(1) = Specified arbitrary X-coordinate. */
              /*     YArbitrary(2) = Specified arbitrary Y-coordinate. */
              /* Inline function */
              /* Index either X- or Y-coordinate from arbitrary ROI */
              Width_ith = (int16_T)(e_NoPrevCallsBlock_ROIDetection[0] -
                                    ROINoResizeBlock_FR[RowToReturnBlockLinIdx_FR]);
              if (Width_ith > d_ROIGeneralConfig_ROIMSIR_Diff) {
                WidthNew_ith = (int16_T)
                  (ROINoResizeBlock_FR[RowToReturnBlockLinIdx_FR] +
                   d_ROIGeneralConfig_ROIMSIR_Diff);
              } else {
                if (Width_ith < (int16_T)-d_ROIGeneralConfig_ROIMSIR_Diff) {
                  WidthNew_ith = (int16_T)
                    (ROINoResizeBlock_FR[RowToReturnBlockLinIdx_FR] -
                     d_ROIGeneralConfig_ROIMSIR_Diff);
                }
              }

              /* end local function */
              /* ============================================================================================= */
              /* Code-generation and build script */
              /* ============================================================================================= */
              /* Code-generation and build script used to generate C-language code and create the compiled version  */
              /* (Interp_mex) of the function. */
              /* { */
              /*  */
              /* %%%%% Specify variable-size input arguments %%%%%% */
              /*  */
              /* See Matlab documentation for coder.typeof. */
              /*                                     Example Code                 Upp. Bounds    Var. Size (T/F)  Type */
              /* xCode                = coder.typeof( zeros(50, 1, 'single'),      [50, 1],       [1, 0] );        %single */
              /* yCode                = coder.typeof( zeros(50, 4, 'int16'),       [50, 4],       [1, 1] );        %int16 */
              /* xiCode               = coder.typeof( zeros(50, 1, 'single'),      [50, 1],       [1, 0] );        %single                                                         */
              /* YArbitraryCode       = coder.typeof( zeros(1, 2, 'int16'),        [1, 2],        [1, 0] );        %int16 */
              /*  */
              /*  */
              /* %%%%% Specify fixed-size input arguments %%%%%% */
              /*  */
              /* LinearExtrapTFCode   = false; */
              /* InterpChecksTFCode   = false; */
              /* DiffMaxActualCode    = int16(0);  */
              /* VidObjWidthCode      = int16(0); */
              /* VidObjHeightCode     = int16(0);            */
              /* DiffMaxArbitraryCode = int16(0);     */
              /*  */
              /*                  */
              /* %%%%% Set configurations to increase performance %%%%%% */
              /*  */
              /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
              /* "Optimization Strategies" */
              /* cfg = coder.config('mex'); */
              /* cfg.GlobalDataSyncMethod = 'NoSync'; */
              /* cfg.ConstantInputs = 'IgnoreValues'; */
              /* cfg.ExtrinsicCalls = false; */
              /* cfg.SaturateOnIntegerOverflow = false; */
              /* cfg.IntegrityChecks = false; */
              /* cfg.ResponsivenessChecks = false; */
              /* cfg.DynamicMemoryAllocation = 'off'; %disabled to improve efficiency as all variables have bounded size */
              /*  */
              /*  */
              /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
              /*  */
              /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
              /*  */
              /* The flags are specified as part of the code-generation configuration object. A custom function, */
              /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
              /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
              /* Matlab guidance found in */
              /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
              /*  */
              /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
              /* a character vector prior to execution of the codegen command. */
              /*  */
              /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
              /*  */
              /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
              /* is not present in the base workspace. */
              /*  */
              /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
              /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each  */
              /* character vector to maintain the charater vector, */
              /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
              /*  */
              /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
              /*  */
              /* Assign to code-generation configuration object */
              /* cfg.PostCodeGenCommand = setbuildargsAsText; */
              /*  */
              /*  */
              /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
              /*  */
              /* codegen Interp.m -report -config cfg -args {xCode, yCode, xiCode, LinearExtrapTFCode, InterpChecksTFCode, DiffMaxActualCode, YArbitraryCode, DiffMaxArbitraryCode, VidObjWidthCode, VidObjHeightCode} */
              /*   */
              /* } */
              ROIOut_FR[0] = WidthNew_ith;

              /* Assign from first row of y */
              WidthNew_ith =
                e_NoPrevCallsBlock_ROIDetection[d_NoPrevCallsBlock_ROIDetection];

              /* If arbitary check enabled */
              /* Check whether the interpolated X- or Y-coordinate is within a specified distance  */
              /* (DiffMaxArbitrary) from a specified X- or Y-coordinate. */
              /* Local function. */
              /* Scalar; type int16.             */
              /* end local function */
              /* ============================================================================================= */
              /* ArbitraryCheck_XY   Check whether the interpolated / extrapolated X- or Y-coordinate is within a  */
              /*                     specified distance (DiffMaxArbitrary) from a specified X- or Y-coordinate */
              /*                     ( YArbitrary(j) ). */
              /*  */
              /*     Description: */
              /*  */
              /*     Check whether the interpolated / extrapolated X- or Y-coordinate is within a specified  */
              /*     distance (DiffMaxArbitrary) from a specified for X- or Y-coordinate ( YArbitrary(j) ). If so,  */
              /*     set value at maximum of threshold.  */
              /*  */
              /*     Inputs (subset): */
              /*  */
              /*     YArbitrary(1) = Specified arbitrary X-coordinate. */
              /*     YArbitrary(2) = Specified arbitrary Y-coordinate. */
              /* Inline function */
              /* Index either X- or Y-coordinate from arbitrary ROI */
              winNew = ROINoResizeBlock_FR[RowToReturnBlockLinIdx_FR + 229];
              Width_ith = (int16_T)(WidthNew_ith - winNew);
              if (Width_ith > d_ROIGeneralConfig_ROIMSIR_Diff) {
                WidthNew_ith = (int16_T)(winNew +
                  d_ROIGeneralConfig_ROIMSIR_Diff);
              } else {
                if (Width_ith < (int16_T)-d_ROIGeneralConfig_ROIMSIR_Diff) {
                  WidthNew_ith = (int16_T)(winNew -
                    d_ROIGeneralConfig_ROIMSIR_Diff);
                }
              }

              /* end local function */
              /* ============================================================================================= */
              /* Code-generation and build script */
              /* ============================================================================================= */
              /* Code-generation and build script used to generate C-language code and create the compiled version  */
              /* (Interp_mex) of the function. */
              /* { */
              /*  */
              /* %%%%% Specify variable-size input arguments %%%%%% */
              /*  */
              /* See Matlab documentation for coder.typeof. */
              /*                                     Example Code                 Upp. Bounds    Var. Size (T/F)  Type */
              /* xCode                = coder.typeof( zeros(50, 1, 'single'),      [50, 1],       [1, 0] );        %single */
              /* yCode                = coder.typeof( zeros(50, 4, 'int16'),       [50, 4],       [1, 1] );        %int16 */
              /* xiCode               = coder.typeof( zeros(50, 1, 'single'),      [50, 1],       [1, 0] );        %single                                                         */
              /* YArbitraryCode       = coder.typeof( zeros(1, 2, 'int16'),        [1, 2],        [1, 0] );        %int16 */
              /*  */
              /*  */
              /* %%%%% Specify fixed-size input arguments %%%%%% */
              /*  */
              /* LinearExtrapTFCode   = false; */
              /* InterpChecksTFCode   = false; */
              /* DiffMaxActualCode    = int16(0);  */
              /* VidObjWidthCode      = int16(0); */
              /* VidObjHeightCode     = int16(0);            */
              /* DiffMaxArbitraryCode = int16(0);     */
              /*  */
              /*                  */
              /* %%%%% Set configurations to increase performance %%%%%% */
              /*  */
              /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
              /* "Optimization Strategies" */
              /* cfg = coder.config('mex'); */
              /* cfg.GlobalDataSyncMethod = 'NoSync'; */
              /* cfg.ConstantInputs = 'IgnoreValues'; */
              /* cfg.ExtrinsicCalls = false; */
              /* cfg.SaturateOnIntegerOverflow = false; */
              /* cfg.IntegrityChecks = false; */
              /* cfg.ResponsivenessChecks = false; */
              /* cfg.DynamicMemoryAllocation = 'off'; %disabled to improve efficiency as all variables have bounded size */
              /*  */
              /*  */
              /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
              /*  */
              /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
              /*  */
              /* The flags are specified as part of the code-generation configuration object. A custom function, */
              /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
              /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
              /* Matlab guidance found in */
              /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
              /*  */
              /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
              /* a character vector prior to execution of the codegen command. */
              /*  */
              /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
              /*  */
              /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
              /* is not present in the base workspace. */
              /*  */
              /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
              /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each  */
              /* character vector to maintain the charater vector, */
              /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
              /*  */
              /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
              /*  */
              /* Assign to code-generation configuration object */
              /* cfg.PostCodeGenCommand = setbuildargsAsText; */
              /*  */
              /*  */
              /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
              /*  */
              /* codegen Interp.m -report -config cfg -args {xCode, yCode, xiCode, LinearExtrapTFCode, InterpChecksTFCode, DiffMaxActualCode, YArbitraryCode, DiffMaxArbitraryCode, VidObjWidthCode, VidObjHeightCode} */
              /*   */
              /* } */
              ROIOut_FR[1] = WidthNew_ith;

              /* Assign from first row of y */
              /* If arbitary check enabled */
              ROIOut_FR[2] =
                e_NoPrevCallsBlock_ROIDetection[d_NoPrevCallsBlock_ROIDetection *
                2];

              /* Assign from first row of y */
              /* If arbitary check enabled */
              ROIOut_FR[3] =
                e_NoPrevCallsBlock_ROIDetection[d_NoPrevCallsBlock_ROIDetection *
                3];

              /* If ith xi value is to right of domain of x     */
              /* If ith xi value is either within domain of x or to right of domain of x       */
            } else {
              /* If xi is within the domain of x, ... */
              /*  - x_before_idx is the index of x where x is less than xi. */
              /*  - x_after_idx is the index of x where x is greater than or equal to xi. */
              /* If xi is to right of the domain of x, ... */
              /*  - both x_before_idx and x_after_idx index x where x is less than xi.  */
              /*  - x at x_before_idx is less than x at x_after_idx. */
              do {
                exitg2 = 0;
                Start++;

                /* If ith xi value is to right of domain of x */
                /* Case of extrapolation. */
                if (Start + 1 >= c_TimestampBlockDetections_FR_s) {
                  /* If linear extrapolation permitted */
                  /* Flag indicating ith xi value is to right of domain of x */
                  /* Nearest-neighbor extrapolation */
                  /* Local function. */
                  /* 1 x nColsY row vector; type int16.    */
                  /* end local function */
                  /* ============================================================================================= */
                  /* ExtrapNearest   Nearest-neighbor extrapolation of y at single time point (xi). */
                  /* Inline function */
                  /* Preallocate output for ith yi values */
                  /* If ith xi value is to left of domain of x */
                  /* Loop across columns of y */
                  /* Assign from last row of y */
                  WidthNew_ith =
                    e_NoPrevCallsBlock_ROIDetection[c_TimestampBlockDetections_FR_s
                    - 1];

                  /* If arbitary check enabled */
                  /* Check whether the interpolated X- or Y-coordinate is within a specified distance  */
                  /* (DiffMaxArbitrary) from a specified X- or Y-coordinate. */
                  /* Local function. */
                  /* Scalar; type int16. */
                  /* end local function */
                  /* ============================================================================================= */
                  /* ArbitraryCheck_XY   Check whether the interpolated / extrapolated X- or Y-coordinate is within a  */
                  /*                     specified distance (DiffMaxArbitrary) from a specified X- or Y-coordinate */
                  /*                     ( YArbitrary(j) ). */
                  /*  */
                  /*     Description: */
                  /*  */
                  /*     Check whether the interpolated / extrapolated X- or Y-coordinate is within a specified  */
                  /*     distance (DiffMaxArbitrary) from a specified for X- or Y-coordinate ( YArbitrary(j) ). If so,  */
                  /*     set value at maximum of threshold.  */
                  /*  */
                  /*     Inputs (subset): */
                  /*  */
                  /*     YArbitrary(1) = Specified arbitrary X-coordinate. */
                  /*     YArbitrary(2) = Specified arbitrary Y-coordinate. */
                  /* Inline function */
                  /* Index either X- or Y-coordinate from arbitrary ROI */
                  Width_ith = (int16_T)(WidthNew_ith -
                                        ROINoResizeBlock_FR[RowToReturnBlockLinIdx_FR]);
                  if (Width_ith > d_ROIGeneralConfig_ROIMSIR_Diff) {
                    WidthNew_ith = (int16_T)
                      (ROINoResizeBlock_FR[RowToReturnBlockLinIdx_FR] +
                       d_ROIGeneralConfig_ROIMSIR_Diff);
                  } else {
                    if (Width_ith < (int16_T)-d_ROIGeneralConfig_ROIMSIR_Diff) {
                      WidthNew_ith = (int16_T)
                        (ROINoResizeBlock_FR[RowToReturnBlockLinIdx_FR] -
                         d_ROIGeneralConfig_ROIMSIR_Diff);
                    }
                  }

                  /* end local function */
                  /* ============================================================================================= */
                  /* Code-generation and build script */
                  /* ============================================================================================= */
                  /* Code-generation and build script used to generate C-language code and create the compiled version  */
                  /* (Interp_mex) of the function. */
                  /* { */
                  /*  */
                  /* %%%%% Specify variable-size input arguments %%%%%% */
                  /*  */
                  /* See Matlab documentation for coder.typeof. */
                  /*                                     Example Code                 Upp. Bounds    Var. Size (T/F)  Type */
                  /* xCode                = coder.typeof( zeros(50, 1, 'single'),      [50, 1],       [1, 0] );        %single */
                  /* yCode                = coder.typeof( zeros(50, 4, 'int16'),       [50, 4],       [1, 1] );        %int16 */
                  /* xiCode               = coder.typeof( zeros(50, 1, 'single'),      [50, 1],       [1, 0] );        %single                                                         */
                  /* YArbitraryCode       = coder.typeof( zeros(1, 2, 'int16'),        [1, 2],        [1, 0] );        %int16 */
                  /*  */
                  /*  */
                  /* %%%%% Specify fixed-size input arguments %%%%%% */
                  /*  */
                  /* LinearExtrapTFCode   = false; */
                  /* InterpChecksTFCode   = false; */
                  /* DiffMaxActualCode    = int16(0);  */
                  /* VidObjWidthCode      = int16(0); */
                  /* VidObjHeightCode     = int16(0);            */
                  /* DiffMaxArbitraryCode = int16(0);     */
                  /*  */
                  /*                  */
                  /* %%%%% Set configurations to increase performance %%%%%% */
                  /*  */
                  /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
                  /* "Optimization Strategies" */
                  /* cfg = coder.config('mex'); */
                  /* cfg.GlobalDataSyncMethod = 'NoSync'; */
                  /* cfg.ConstantInputs = 'IgnoreValues'; */
                  /* cfg.ExtrinsicCalls = false; */
                  /* cfg.SaturateOnIntegerOverflow = false; */
                  /* cfg.IntegrityChecks = false; */
                  /* cfg.ResponsivenessChecks = false; */
                  /* cfg.DynamicMemoryAllocation = 'off'; %disabled to improve efficiency as all variables have bounded size */
                  /*  */
                  /*  */
                  /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
                  /*  */
                  /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
                  /*  */
                  /* The flags are specified as part of the code-generation configuration object. A custom function, */
                  /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
                  /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
                  /* Matlab guidance found in */
                  /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
                  /*  */
                  /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
                  /* a character vector prior to execution of the codegen command. */
                  /*  */
                  /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
                  /*  */
                  /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
                  /* is not present in the base workspace. */
                  /*  */
                  /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
                  /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each  */
                  /* character vector to maintain the charater vector, */
                  /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
                  /*  */
                  /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
                  /*  */
                  /* Assign to code-generation configuration object */
                  /* cfg.PostCodeGenCommand = setbuildargsAsText; */
                  /*  */
                  /*  */
                  /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
                  /*  */
                  /* codegen Interp.m -report -config cfg -args {xCode, yCode, xiCode, LinearExtrapTFCode, InterpChecksTFCode, DiffMaxActualCode, YArbitraryCode, DiffMaxArbitraryCode, VidObjWidthCode, VidObjHeightCode} */
                  /*   */
                  /* } */
                  ROIOut_FR[0] = WidthNew_ith;

                  /* Assign from last row of y */
                  WidthNew_ith = e_NoPrevCallsBlock_ROIDetection
                    [(c_TimestampBlockDetections_FR_s +
                      d_NoPrevCallsBlock_ROIDetection) - 1];

                  /* If arbitary check enabled */
                  /* Check whether the interpolated X- or Y-coordinate is within a specified distance  */
                  /* (DiffMaxArbitrary) from a specified X- or Y-coordinate. */
                  /* Local function. */
                  /* Scalar; type int16. */
                  /* end local function */
                  /* ============================================================================================= */
                  /* ArbitraryCheck_XY   Check whether the interpolated / extrapolated X- or Y-coordinate is within a  */
                  /*                     specified distance (DiffMaxArbitrary) from a specified X- or Y-coordinate */
                  /*                     ( YArbitrary(j) ). */
                  /*  */
                  /*     Description: */
                  /*  */
                  /*     Check whether the interpolated / extrapolated X- or Y-coordinate is within a specified  */
                  /*     distance (DiffMaxArbitrary) from a specified for X- or Y-coordinate ( YArbitrary(j) ). If so,  */
                  /*     set value at maximum of threshold.  */
                  /*  */
                  /*     Inputs (subset): */
                  /*  */
                  /*     YArbitrary(1) = Specified arbitrary X-coordinate. */
                  /*     YArbitrary(2) = Specified arbitrary Y-coordinate. */
                  /* Inline function */
                  /* Index either X- or Y-coordinate from arbitrary ROI */
                  Width_ith = (int16_T)(WidthNew_ith -
                                        ROINoResizeBlock_FR[RowToReturnBlockLinIdx_FR
                                        + 229]);
                  if (Width_ith > d_ROIGeneralConfig_ROIMSIR_Diff) {
                    WidthNew_ith = (int16_T)
                      (ROINoResizeBlock_FR[RowToReturnBlockLinIdx_FR + 229] +
                       d_ROIGeneralConfig_ROIMSIR_Diff);
                  } else {
                    if (Width_ith < (int16_T)-d_ROIGeneralConfig_ROIMSIR_Diff) {
                      WidthNew_ith = (int16_T)
                        (ROINoResizeBlock_FR[RowToReturnBlockLinIdx_FR + 229] -
                         d_ROIGeneralConfig_ROIMSIR_Diff);
                    }
                  }

                  /* end local function */
                  /* ============================================================================================= */
                  /* Code-generation and build script */
                  /* ============================================================================================= */
                  /* Code-generation and build script used to generate C-language code and create the compiled version  */
                  /* (Interp_mex) of the function. */
                  /* { */
                  /*  */
                  /* %%%%% Specify variable-size input arguments %%%%%% */
                  /*  */
                  /* See Matlab documentation for coder.typeof. */
                  /*                                     Example Code                 Upp. Bounds    Var. Size (T/F)  Type */
                  /* xCode                = coder.typeof( zeros(50, 1, 'single'),      [50, 1],       [1, 0] );        %single */
                  /* yCode                = coder.typeof( zeros(50, 4, 'int16'),       [50, 4],       [1, 1] );        %int16 */
                  /* xiCode               = coder.typeof( zeros(50, 1, 'single'),      [50, 1],       [1, 0] );        %single                                                         */
                  /* YArbitraryCode       = coder.typeof( zeros(1, 2, 'int16'),        [1, 2],        [1, 0] );        %int16 */
                  /*  */
                  /*  */
                  /* %%%%% Specify fixed-size input arguments %%%%%% */
                  /*  */
                  /* LinearExtrapTFCode   = false; */
                  /* InterpChecksTFCode   = false; */
                  /* DiffMaxActualCode    = int16(0);  */
                  /* VidObjWidthCode      = int16(0); */
                  /* VidObjHeightCode     = int16(0);            */
                  /* DiffMaxArbitraryCode = int16(0);     */
                  /*  */
                  /*                  */
                  /* %%%%% Set configurations to increase performance %%%%%% */
                  /*  */
                  /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
                  /* "Optimization Strategies" */
                  /* cfg = coder.config('mex'); */
                  /* cfg.GlobalDataSyncMethod = 'NoSync'; */
                  /* cfg.ConstantInputs = 'IgnoreValues'; */
                  /* cfg.ExtrinsicCalls = false; */
                  /* cfg.SaturateOnIntegerOverflow = false; */
                  /* cfg.IntegrityChecks = false; */
                  /* cfg.ResponsivenessChecks = false; */
                  /* cfg.DynamicMemoryAllocation = 'off'; %disabled to improve efficiency as all variables have bounded size */
                  /*  */
                  /*  */
                  /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
                  /*  */
                  /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
                  /*  */
                  /* The flags are specified as part of the code-generation configuration object. A custom function, */
                  /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
                  /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
                  /* Matlab guidance found in */
                  /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
                  /*  */
                  /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
                  /* a character vector prior to execution of the codegen command. */
                  /*  */
                  /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
                  /*  */
                  /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
                  /* is not present in the base workspace. */
                  /*  */
                  /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
                  /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each  */
                  /* character vector to maintain the charater vector, */
                  /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
                  /*  */
                  /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
                  /*  */
                  /* Assign to code-generation configuration object */
                  /* cfg.PostCodeGenCommand = setbuildargsAsText; */
                  /*  */
                  /*  */
                  /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
                  /*  */
                  /* codegen Interp.m -report -config cfg -args {xCode, yCode, xiCode, LinearExtrapTFCode, InterpChecksTFCode, DiffMaxActualCode, YArbitraryCode, DiffMaxArbitraryCode, VidObjWidthCode, VidObjHeightCode} */
                  /*   */
                  /* } */
                  ROIOut_FR[1] = WidthNew_ith;

                  /* Assign from last row of y */
                  /* If arbitary check enabled */
                  ROIOut_FR[2] = e_NoPrevCallsBlock_ROIDetection
                    [(c_TimestampBlockDetections_FR_s +
                      d_NoPrevCallsBlock_ROIDetection * 2) - 1];

                  /* Assign from last row of y */
                  /* If arbitary check enabled */
                  ROIOut_FR[3] = e_NoPrevCallsBlock_ROIDetection
                    [(c_TimestampBlockDetections_FR_s +
                      d_NoPrevCallsBlock_ROIDetection * 3) - 1];

                  /* Set back x_idx by one for use for i+1th xi element. */
                  /* xi is assumed to be sorted, but the values are not assumed to be unique, so x_idx */
                  /* should start back by one in case the next value of xi is the same as the current. */
                  /* Even is all values are unique, floating-point imprecision could effectively cause */
                  /* some to be non-unique. */
                  exitg2 = 1;
                } else {
                  if (c_TimestampBlockDetections_FR_d[Start] >=
                      HeightRatio_Single) {
                    /* Assign x indices */
                    /* Linear interpolation */
                    /* Local function. */
                    /* 1 x nColsY row vector; type int16.                 */
                    /* end main function */
                    /* ============================================================================================= */
                    /* Local functions */
                    /* ============================================================================================= */
                    /* ============================================================================================= */
                    /* InterpLinear   Linear interpolation of y at a single time point (xi). */
                    /* Inline function */
                    /* Preallocate output for ith yi values */
                    /* Assign x values   */
                    /* Scalars; type single. */
                    WidthRatio_Single = c_TimestampBlockDetections_FR_d[Start -
                      1];
                    x_after = c_TimestampBlockDetections_FR_d[Start];

                    /* Proportion of interpolated time interval to actual time interval */
                    /* Scalar; type single. */
                    b_r = (HeightRatio_Single - WidthRatio_Single) /
                      (c_TimestampBlockDetections_FR_d[Start] -
                       WidthRatio_Single);

                    /* Loop across columns of y */
                    /* y value that comes before time point to be interpolated */
                    /* Scalar; type int16. */
                    Height_ith = e_NoPrevCallsBlock_ROIDetection[Start - 1];

                    /* y value that comes after time point to be interpolated */
                    /* Scalar; type int16. */
                    Width_ith = e_NoPrevCallsBlock_ROIDetection[Start];

                    /* %%%%% Skip interpolation %%%%%% */
                    /* If y values same, assign one of them as interpolated value */
                    if (Height_ith == Width_ith) {
                      WidthNew_ith = Height_ith;

                      /* %%%%% Interpolate %%%%%%          */
                    } else {
                      /* Step 1 */
                      /* Interpolated distance of y. */
                      /* Multipy interpolated time-interval proportion by actual change in y. */
                      /* Cast to floating-point type to multiply.   */
                      /* Step 2 */
                      /* Add distance to most immediate previous actual y value. */
                      WidthNew_ith = (int16_T)(Height_ith + (int16_T)
                        muSingleScalarRound((real32_T)(int16_T)(Width_ith -
                        Height_ith) * b_r));

                      /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                      /* Local function. */
                      /* Scalar; type int16. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                      /* Inline function */
                      /* Switch according to column */
                      /* x-coordinate column */
                      /* Local function. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck_XY   Validity check for X- or Y-coordinate. */
                      /*  */
                      /*     Description: */
                      /*  */
                      /*     Check whether difference between before-value and interpolated / extrapolated value is greater   */
                      /*     than specified threshold. If so, set value at maximum of threshold.  */
                      /* Inline function */
                      Width_ith = (int16_T)(WidthNew_ith - Height_ith);
                      if (Width_ith > c_ROIGeneralConfig_ROIMSIR_Diff) {
                        WidthNew_ith = (int16_T)(Height_ith +
                          c_ROIGeneralConfig_ROIMSIR_Diff);
                      } else {
                        if (Width_ith < (int16_T)
                            -c_ROIGeneralConfig_ROIMSIR_Diff) {
                          WidthNew_ith = (int16_T)(Height_ith -
                            c_ROIGeneralConfig_ROIMSIR_Diff);
                        }
                      }
                    }

                    /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                    /* If arbitary check enabled    */
                    /* Check whether the interpolated X- or Y-coordinate is within a specified distance  */
                    /* (DiffMaxArbitrary) from a specified X- or Y-coordinate. */
                    /* Local function. */
                    /* Scalar; type int16. */
                    /* end local function */
                    /* ============================================================================================= */
                    /* ArbitraryCheck_XY   Check whether the interpolated / extrapolated X- or Y-coordinate is within a  */
                    /*                     specified distance (DiffMaxArbitrary) from a specified X- or Y-coordinate */
                    /*                     ( YArbitrary(j) ). */
                    /*  */
                    /*     Description: */
                    /*  */
                    /*     Check whether the interpolated / extrapolated X- or Y-coordinate is within a specified  */
                    /*     distance (DiffMaxArbitrary) from a specified for X- or Y-coordinate ( YArbitrary(j) ). If so,  */
                    /*     set value at maximum of threshold.  */
                    /*  */
                    /*     Inputs (subset): */
                    /*  */
                    /*     YArbitrary(1) = Specified arbitrary X-coordinate. */
                    /*     YArbitrary(2) = Specified arbitrary Y-coordinate. */
                    /* Inline function */
                    /* Index either X- or Y-coordinate from arbitrary ROI */
                    Width_ith = (int16_T)(WidthNew_ith -
                                          ROINoResizeBlock_FR[RowToReturnBlockLinIdx_FR]);
                    if (Width_ith > d_ROIGeneralConfig_ROIMSIR_Diff) {
                      WidthNew_ith = (int16_T)
                        (ROINoResizeBlock_FR[RowToReturnBlockLinIdx_FR] +
                         d_ROIGeneralConfig_ROIMSIR_Diff);
                    } else {
                      if (Width_ith < (int16_T)-d_ROIGeneralConfig_ROIMSIR_Diff)
                      {
                        WidthNew_ith = (int16_T)
                          (ROINoResizeBlock_FR[RowToReturnBlockLinIdx_FR] -
                           d_ROIGeneralConfig_ROIMSIR_Diff);
                      }
                    }

                    /* end local function */
                    /* ============================================================================================= */
                    /* Code-generation and build script */
                    /* ============================================================================================= */
                    /* Code-generation and build script used to generate C-language code and create the compiled version  */
                    /* (Interp_mex) of the function. */
                    /* { */
                    /*  */
                    /* %%%%% Specify variable-size input arguments %%%%%% */
                    /*  */
                    /* See Matlab documentation for coder.typeof. */
                    /*                                     Example Code                 Upp. Bounds    Var. Size (T/F)  Type */
                    /* xCode                = coder.typeof( zeros(50, 1, 'single'),      [50, 1],       [1, 0] );        %single */
                    /* yCode                = coder.typeof( zeros(50, 4, 'int16'),       [50, 4],       [1, 1] );        %int16 */
                    /* xiCode               = coder.typeof( zeros(50, 1, 'single'),      [50, 1],       [1, 0] );        %single                                                         */
                    /* YArbitraryCode       = coder.typeof( zeros(1, 2, 'int16'),        [1, 2],        [1, 0] );        %int16 */
                    /*  */
                    /*  */
                    /* %%%%% Specify fixed-size input arguments %%%%%% */
                    /*  */
                    /* LinearExtrapTFCode   = false; */
                    /* InterpChecksTFCode   = false; */
                    /* DiffMaxActualCode    = int16(0);  */
                    /* VidObjWidthCode      = int16(0); */
                    /* VidObjHeightCode     = int16(0);            */
                    /* DiffMaxArbitraryCode = int16(0);     */
                    /*  */
                    /*                  */
                    /* %%%%% Set configurations to increase performance %%%%%% */
                    /*  */
                    /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
                    /* "Optimization Strategies" */
                    /* cfg = coder.config('mex'); */
                    /* cfg.GlobalDataSyncMethod = 'NoSync'; */
                    /* cfg.ConstantInputs = 'IgnoreValues'; */
                    /* cfg.ExtrinsicCalls = false; */
                    /* cfg.SaturateOnIntegerOverflow = false; */
                    /* cfg.IntegrityChecks = false; */
                    /* cfg.ResponsivenessChecks = false; */
                    /* cfg.DynamicMemoryAllocation = 'off'; %disabled to improve efficiency as all variables have bounded size */
                    /*  */
                    /*  */
                    /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
                    /*  */
                    /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
                    /*  */
                    /* The flags are specified as part of the code-generation configuration object. A custom function, */
                    /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
                    /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
                    /* Matlab guidance found in */
                    /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
                    /*  */
                    /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
                    /* a character vector prior to execution of the codegen command. */
                    /*  */
                    /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
                    /*  */
                    /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
                    /* is not present in the base workspace. */
                    /*  */
                    /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
                    /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each  */
                    /* character vector to maintain the charater vector, */
                    /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
                    /*  */
                    /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
                    /*  */
                    /* Assign to code-generation configuration object */
                    /* cfg.PostCodeGenCommand = setbuildargsAsText; */
                    /*  */
                    /*  */
                    /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
                    /*  */
                    /* codegen Interp.m -report -config cfg -args {xCode, yCode, xiCode, LinearExtrapTFCode, InterpChecksTFCode, DiffMaxActualCode, YArbitraryCode, DiffMaxArbitraryCode, VidObjWidthCode, VidObjHeightCode} */
                    /*   */
                    /* } */
                    /* %%%%% Assign %%%%%% */
                    ROIOut_FR[0] = WidthNew_ith;

                    /* y value that comes before time point to be interpolated */
                    /* Scalar; type int16. */
                    VideoReadConfig_FrameIdx_Length = Start +
                      d_NoPrevCallsBlock_ROIDetection;
                    Height_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length
                      - 1];

                    /* y value that comes after time point to be interpolated */
                    /* Scalar; type int16. */
                    Width_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length];

                    /* %%%%% Skip interpolation %%%%%% */
                    /* If y values same, assign one of them as interpolated value */
                    if (Height_ith == Width_ith) {
                      WidthNew_ith = Height_ith;

                      /* %%%%% Interpolate %%%%%%          */
                    } else {
                      /* Step 1 */
                      /* Interpolated distance of y. */
                      /* Multipy interpolated time-interval proportion by actual change in y. */
                      /* Cast to floating-point type to multiply.   */
                      /* Step 2 */
                      /* Add distance to most immediate previous actual y value. */
                      WidthNew_ith = (int16_T)(Height_ith + (int16_T)
                        muSingleScalarRound((real32_T)(int16_T)(Width_ith -
                        Height_ith) * b_r));

                      /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                      /* Local function. */
                      /* Scalar; type int16. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                      /* Inline function */
                      /* Switch according to column */
                      /* y-coordinate column */
                      /* Local function. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck_XY   Validity check for X- or Y-coordinate. */
                      /*  */
                      /*     Description: */
                      /*  */
                      /*     Check whether difference between before-value and interpolated / extrapolated value is greater   */
                      /*     than specified threshold. If so, set value at maximum of threshold.  */
                      /* Inline function */
                      Width_ith = (int16_T)(WidthNew_ith - Height_ith);
                      if (Width_ith > c_ROIGeneralConfig_ROIMSIR_Diff) {
                        WidthNew_ith = (int16_T)(Height_ith +
                          c_ROIGeneralConfig_ROIMSIR_Diff);
                      } else {
                        if (Width_ith < (int16_T)
                            -c_ROIGeneralConfig_ROIMSIR_Diff) {
                          WidthNew_ith = (int16_T)(Height_ith -
                            c_ROIGeneralConfig_ROIMSIR_Diff);
                        }
                      }
                    }

                    /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                    /* If arbitary check enabled    */
                    /* Check whether the interpolated X- or Y-coordinate is within a specified distance  */
                    /* (DiffMaxArbitrary) from a specified X- or Y-coordinate. */
                    /* Local function. */
                    /* Scalar; type int16. */
                    /* end local function */
                    /* ============================================================================================= */
                    /* ArbitraryCheck_XY   Check whether the interpolated / extrapolated X- or Y-coordinate is within a  */
                    /*                     specified distance (DiffMaxArbitrary) from a specified X- or Y-coordinate */
                    /*                     ( YArbitrary(j) ). */
                    /*  */
                    /*     Description: */
                    /*  */
                    /*     Check whether the interpolated / extrapolated X- or Y-coordinate is within a specified  */
                    /*     distance (DiffMaxArbitrary) from a specified for X- or Y-coordinate ( YArbitrary(j) ). If so,  */
                    /*     set value at maximum of threshold.  */
                    /*  */
                    /*     Inputs (subset): */
                    /*  */
                    /*     YArbitrary(1) = Specified arbitrary X-coordinate. */
                    /*     YArbitrary(2) = Specified arbitrary Y-coordinate. */
                    /* Inline function */
                    /* Index either X- or Y-coordinate from arbitrary ROI */
                    Width_ith = (int16_T)(WidthNew_ith -
                                          ROINoResizeBlock_FR[RowToReturnBlockLinIdx_FR
                                          + 229]);
                    if (Width_ith > d_ROIGeneralConfig_ROIMSIR_Diff) {
                      WidthNew_ith = (int16_T)
                        (ROINoResizeBlock_FR[RowToReturnBlockLinIdx_FR + 229] +
                         d_ROIGeneralConfig_ROIMSIR_Diff);
                    } else {
                      if (Width_ith < (int16_T)-d_ROIGeneralConfig_ROIMSIR_Diff)
                      {
                        WidthNew_ith = (int16_T)
                          (ROINoResizeBlock_FR[RowToReturnBlockLinIdx_FR + 229]
                           - d_ROIGeneralConfig_ROIMSIR_Diff);
                      }
                    }

                    /* end local function */
                    /* ============================================================================================= */
                    /* Code-generation and build script */
                    /* ============================================================================================= */
                    /* Code-generation and build script used to generate C-language code and create the compiled version  */
                    /* (Interp_mex) of the function. */
                    /* { */
                    /*  */
                    /* %%%%% Specify variable-size input arguments %%%%%% */
                    /*  */
                    /* See Matlab documentation for coder.typeof. */
                    /*                                     Example Code                 Upp. Bounds    Var. Size (T/F)  Type */
                    /* xCode                = coder.typeof( zeros(50, 1, 'single'),      [50, 1],       [1, 0] );        %single */
                    /* yCode                = coder.typeof( zeros(50, 4, 'int16'),       [50, 4],       [1, 1] );        %int16 */
                    /* xiCode               = coder.typeof( zeros(50, 1, 'single'),      [50, 1],       [1, 0] );        %single                                                         */
                    /* YArbitraryCode       = coder.typeof( zeros(1, 2, 'int16'),        [1, 2],        [1, 0] );        %int16 */
                    /*  */
                    /*  */
                    /* %%%%% Specify fixed-size input arguments %%%%%% */
                    /*  */
                    /* LinearExtrapTFCode   = false; */
                    /* InterpChecksTFCode   = false; */
                    /* DiffMaxActualCode    = int16(0);  */
                    /* VidObjWidthCode      = int16(0); */
                    /* VidObjHeightCode     = int16(0);            */
                    /* DiffMaxArbitraryCode = int16(0);     */
                    /*  */
                    /*                  */
                    /* %%%%% Set configurations to increase performance %%%%%% */
                    /*  */
                    /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
                    /* "Optimization Strategies" */
                    /* cfg = coder.config('mex'); */
                    /* cfg.GlobalDataSyncMethod = 'NoSync'; */
                    /* cfg.ConstantInputs = 'IgnoreValues'; */
                    /* cfg.ExtrinsicCalls = false; */
                    /* cfg.SaturateOnIntegerOverflow = false; */
                    /* cfg.IntegrityChecks = false; */
                    /* cfg.ResponsivenessChecks = false; */
                    /* cfg.DynamicMemoryAllocation = 'off'; %disabled to improve efficiency as all variables have bounded size */
                    /*  */
                    /*  */
                    /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
                    /*  */
                    /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
                    /*  */
                    /* The flags are specified as part of the code-generation configuration object. A custom function, */
                    /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
                    /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
                    /* Matlab guidance found in */
                    /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
                    /*  */
                    /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
                    /* a character vector prior to execution of the codegen command. */
                    /*  */
                    /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
                    /*  */
                    /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
                    /* is not present in the base workspace. */
                    /*  */
                    /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
                    /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each  */
                    /* character vector to maintain the charater vector, */
                    /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
                    /*  */
                    /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
                    /*  */
                    /* Assign to code-generation configuration object */
                    /* cfg.PostCodeGenCommand = setbuildargsAsText; */
                    /*  */
                    /*  */
                    /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
                    /*  */
                    /* codegen Interp.m -report -config cfg -args {xCode, yCode, xiCode, LinearExtrapTFCode, InterpChecksTFCode, DiffMaxActualCode, YArbitraryCode, DiffMaxArbitraryCode, VidObjWidthCode, VidObjHeightCode} */
                    /*   */
                    /* } */
                    /* %%%%% Assign %%%%%% */
                    ROIOut_FR[1] = WidthNew_ith;

                    /* y value that comes before time point to be interpolated */
                    /* Scalar; type int16. */
                    VideoReadConfig_FrameIdx_Length = Start +
                      d_NoPrevCallsBlock_ROIDetection * 2;
                    Height_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length
                      - 1];

                    /* y value that comes after time point to be interpolated */
                    /* Scalar; type int16. */
                    Width_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length];

                    /* %%%%% Skip interpolation %%%%%% */
                    /* If y values same, assign one of them as interpolated value */
                    if (Height_ith == Width_ith) {
                      WidthNew_ith = Height_ith;

                      /* %%%%% Interpolate %%%%%%          */
                    } else {
                      /* Step 1 */
                      /* Interpolated distance of y. */
                      /* Multipy interpolated time-interval proportion by actual change in y. */
                      /* Cast to floating-point type to multiply.   */
                      /* Step 2 */
                      /* Add distance to most immediate previous actual y value. */
                      WidthNew_ith = (int16_T)(Height_ith + (int16_T)
                        muSingleScalarRound((real32_T)(int16_T)(Width_ith -
                        Height_ith) * b_r));

                      /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                      /* Local function. */
                      /* Scalar; type int16. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                      /* Inline function */
                      /* Switch according to column */
                      /* width column */
                      /* Local function. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck_WH   Validity check for width or height. */
                      /*  */
                      /*     Description: */
                      /*  */
                      /*     Check whether width or height value is less than 20. If so, then substitute the  */
                      /*     nearest-neighbor method in place of the linear method. */
                      /* Inline function */
                      if (WidthNew_ith < 20) {
                        /* Determine whether x_after or x_before nearest and assign. */
                        /* x_after nearest */
                        if (muSingleScalarAbs(x_after - HeightRatio_Single) <=
                            muSingleScalarAbs(WidthRatio_Single -
                                              HeightRatio_Single)) {
                          WidthNew_ith = Width_ith;

                          /* x_before nearest */
                        } else {
                          WidthNew_ith = Height_ith;
                        }
                      }
                    }

                    /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                    /* If arbitary check enabled    */
                    /* %%%%% Assign %%%%%% */
                    ROIOut_FR[2] = WidthNew_ith;

                    /* y value that comes before time point to be interpolated */
                    /* Scalar; type int16. */
                    VideoReadConfig_FrameIdx_Length = Start +
                      d_NoPrevCallsBlock_ROIDetection * 3;
                    Height_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length
                      - 1];

                    /* y value that comes after time point to be interpolated */
                    /* Scalar; type int16. */
                    Width_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length];

                    /* %%%%% Skip interpolation %%%%%% */
                    /* If y values same, assign one of them as interpolated value */
                    if (Height_ith == Width_ith) {
                      WidthNew_ith = Height_ith;

                      /* %%%%% Interpolate %%%%%%          */
                    } else {
                      /* Step 1 */
                      /* Interpolated distance of y. */
                      /* Multipy interpolated time-interval proportion by actual change in y. */
                      /* Cast to floating-point type to multiply.   */
                      /* Step 2 */
                      /* Add distance to most immediate previous actual y value. */
                      WidthNew_ith = (int16_T)(Height_ith + (int16_T)
                        muSingleScalarRound((real32_T)(int16_T)(Width_ith -
                        Height_ith) * b_r));

                      /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                      /* Local function. */
                      /* Scalar; type int16. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                      /* Inline function */
                      /* Switch according to column */
                      /* height column */
                      /* Local function. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck_WH   Validity check for width or height. */
                      /*  */
                      /*     Description: */
                      /*  */
                      /*     Check whether width or height value is less than 20. If so, then substitute the  */
                      /*     nearest-neighbor method in place of the linear method. */
                      /* Inline function */
                      if (WidthNew_ith < 20) {
                        /* Determine whether x_after or x_before nearest and assign. */
                        /* x_after nearest */
                        if (muSingleScalarAbs(x_after - HeightRatio_Single) <=
                            muSingleScalarAbs(WidthRatio_Single -
                                              HeightRatio_Single)) {
                          WidthNew_ith = Width_ith;

                          /* x_before nearest */
                        } else {
                          WidthNew_ith = Height_ith;
                        }
                      }
                    }

                    /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                    /* If arbitary check enabled    */
                    /* %%%%% Assign %%%%%% */
                    ROIOut_FR[3] = WidthNew_ith;

                    /* Set back x_idx by one for use for i+1th xi element. */
                    /* xi is assumed to be sorted, but the values are not assumed to be unique, so x_idx */
                    /* should start back by one in case the next value of xi is the same as the current. */
                    /* Even is all values are unique, floating-point imprecision could effectively cause */
                    /* some to be non-unique. */
                    exitg2 = 1;
                  }
                }
              } while (exitg2 == 0);
            }

            /* Check whether interpolated values are within frame dimensions */
            /* If not, adjust to be within frame dimensions.         */
            /* Note: ROIAdjustIfExceedsFrameDims is a custom function located within folder */
            /* 'FacePulseRate'. */
            /* 1 x nColsY row vector; type int16. */
            /* ROIAdjustIfExceedsFrameDims   Verify whether proposed widths and heights of ROIs exceed frame  */
            /*                               dimensions and, if so, modify them to conform to frame dimensions. */
            /*                                */
            /*     Helper function to function FacePulseRate. */
            /*     Within function FacePulseRate, called by functions ROIResize, ROIMeans_FirstRead_Extrapolate, */
            /*     SkinDetect_EnlargeROI, ROIMSIR, ROIMSIR_MatchSize, ROIMSIR_DetectionSmooth,   */
            /*     ROIMSIR_Interpolate, and ROIMSIR_FrameByFrameSmooth.    */
            /*  */
            /*  */
            /*     Code Generation */
            /*     --------------- */
            /*  */
            /*     Can be called as a Matlab function or used for C-language code generation. */
            /*  */
            /*  */
            /*     Description */
            /*     ----------- */
            /*  */
            /*     This function verifies that ROIs that have had modifications to their sizes are still within */
            /*     the dimensions of the frame. If not, this function adjusts the dimensions (and, consequently,   */
            /*     the spatial coordinates) to conform to the frame dimensions. */
            /*  */
            /*     Note:  */
            /*  */
            /*     Intended only for use with integer types as rounding is not conducted. For modification for  */
            /*     use with floating-point types, rounding would be necessary as ROI values should be integers. */
            /*  */
            /*  */
            /*     Copyright */
            /*     --------- */
            /*  */
            /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
            /*     the Responsible AI License (RAIL). */
            /* %%%%% Validate inputs %%%%%% */
            /* Exit if empty */
            /* Validate whether input ROIsProposed is type int16. */
            /* Must be an integer type because no rounding is conducted. */
            /* Should be type int16 because the function is implemented to assign values of this type. */
            /* A non-matching type would be due to an implementation error. */
            /* %%%%% Running in code generation %%%%%% */
            /* When running in code generation, use for-loops. When running in Matlab code, use vectorization. */
            /* code generation running */
            /* Inline function */
            /* %%%%% --- Verify, and adjust if necessary, X-coordinates and widths %%%%%% */
            /* Adjust left-side X-coordinate if exceeds frame dimensions: */
            WidthNew_ith = (int16_T)(ROIOut_FR[0] - 1);
            if (ROIOut_FR[0] < 1) {
              WidthNew_ith = 0;

              /* recent code mod */
              ROIOut_FR[0] = 1;
            } else {
              if (ROIOut_FR[0] > VidObjWidth) {
                WidthNew_ith = (int16_T)(VidObjWidth - 1);

                /* recent code mod */
                ROIOut_FR[0] = VidObjWidth;
              }
            }

            /* Adjust right-side X-coordinate if exceeds frame dimensions: */
            Width_ith = (int16_T)(WidthNew_ith + ROIOut_FR[2]);
            if (Width_ith > VidObjWidth) {
              Width_ith = VidObjWidth;
              ROIOut_FR[2] = (int16_T)(VidObjWidth - WidthNew_ith);
            } else {
              if (Width_ith < 1) {
                Width_ith = 1;
                WidthNew_ith = 0;
                ROIOut_FR[0] = 1;
                ROIOut_FR[2] = 1;
              }
            }

            /* Adjust width if exceeds frame dimensions: */
            Width_ith -= WidthNew_ith;
            if (Width_ith > VidObjWidth) {
              ROIOut_FR[2] = VidObjWidth;
            } else {
              if (Width_ith < 1) {
                ROIOut_FR[2] = 1;
              }
            }

            /* %%%%% --- Verify, and adjust if necessary, Y-coordinates and heights %%%%%% */
            /* Adjust top-side Y-coordinate if exceeds frame dimensions: */
            Height_ith = (int16_T)(ROIOut_FR[1] - 1);
            if (ROIOut_FR[1] < 1) {
              Height_ith = 0;

              /* recent code mod */
              ROIOut_FR[1] = 1;
            } else {
              if (ROIOut_FR[1] > VidObjHeight) {
                Height_ith = (int16_T)(VidObjHeight - 1);

                /* recent code mod */
                ROIOut_FR[1] = VidObjHeight;
              }
            }

            /* Adjust bottom-side Y-coordinate if exceeds frame dimensions: */
            Width_ith = (int16_T)(Height_ith + ROIOut_FR[3]);
            if (Width_ith > VidObjHeight) {
              Width_ith = VidObjHeight;
              ROIOut_FR[3] = (int16_T)(VidObjHeight - Height_ith);
            } else {
              if (Width_ith < 1) {
                Width_ith = 1;
                Height_ith = 0;
                ROIOut_FR[1] = 1;
                ROIOut_FR[3] = 1;
              }
            }

            /* Adjust height value if exceeds frame dimensions: */
            HeightNew_ith = (int16_T)(Width_ith - Height_ith);
            if (HeightNew_ith > VidObjHeight) {
              ROIOut_FR[3] = VidObjHeight;
            } else {
              if (HeightNew_ith < 1) {
                ROIOut_FR[3] = 1;
              }
            }

            /* %%%%% Code generation not running %%%%%% */
            /* end function */
            /* ============================================================================================= */
            /* Code-generation and build script */
            /* ============================================================================================= */
            /* Code-generation and build script used to generate C-language code and create the compiled version  */
            /* (ROIAdjustIfExceedsFrameDims_mex) of the function. */
            /* { */
            /*  */
            /* %%%%% Specify variable-size input arguments %%%%%% */
            /*  */
            /* See Matlab documentation for coder.typeof. */
            /*  */
            /*                                   Example Code               Upp. Bounds   Var. Size (T/F)  Type */
            /* ROIsProposedCode   = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],     [1, 0] );        %int16 */
            /*            */
            /*        */
            /* %%%%% Specify fixed-size input arguments %%%%%% */
            /*  */
            /* VidObjWidthCode  = int16(0);          */
            /* VidObjHeightCode = int16(0); */
            /*                    */
            /*  */
            /* %%%%% Set configurations to increase performance %%%%%% */
            /*  */
            /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
            /* "Optimization Strategies" */
            /*  */
            /* cfg = coder.config('mex'); */
            /* cfg.GlobalDataSyncMethod = 'NoSync'; */
            /* cfg.ConstantInputs = 'IgnoreValues'; */
            /* cfg.ExtrinsicCalls = true; %permit to show assert error */
            /* cfg.SaturateOnIntegerOverflow = false; */
            /* cfg.IntegrityChecks = false; */
            /* cfg.ResponsivenessChecks = false; */
            /*  */
            /*  */
            /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
            /*  */
            /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
            /*  */
            /* The flags are specified as part of the code-generation configuration object. A custom function, */
            /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
            /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
            /* Matlab guidance found in */
            /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
            /*  */
            /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
            /* a character vector prior to execution of the codegen command. */
            /*  */
            /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
            /*  */
            /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
            /* is not present in the base workspace. */
            /*  */
            /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
            /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
            /* character vector to maintain the charater vector, */
            /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
            /*  */
            /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
            /*  */
            /* Assign to code-generation configuration object */
            /* cfg.PostCodeGenCommand = setbuildargsAsText; */
            /*  */
            /*  */
            /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
            /*  */
            /* codegen ROIAdjustIfExceedsFrameDims.m -report -config cfg -args {ROIsProposedCode, VidObjWidthCode, VidObjHeightCode} */
            /*                  */
            /* } */
            /* Assign interpolated / extrapolated values of yi at xi */
          } else {
            /* 1 x 4 row vector; type int16. */
            /* Note: for a description of the arguments to function Interp, see the description  */
            /* at top. */
            /* Note: Interp is a custom function located within folder 'FacePulseRate'.                     */
            /*  Interpolated ROI */
            /*  Time points used for */
            /*  interpolation. */
            /*  Values used for */
            /*  interpolation. */
            /*  Time point at which */
            /*  interpolation to be */
            /*  assigned. */
            /*  Empty = do not conduct */
            /*  adjacent ROI check. */
            /*  Unused argument for adjacent */
            /*  ROI check/ */
            /* Interp   Conduct linear interpolation/extrapolation or nearest-neighbor extrapolation. */
            /*  */
            /*     Helper function to function FacePulseRate.  */
            /*     Within function FacePulseRate, called by functions ROIMeans_FirstRead_ExtrapolateROI,  */
            /*     ROIMSIR_Interpolate and ROIMSIR_FrameByFrameSmooth_InterpFR. */
            /*      */
            /*  */
            /*     Code Generation */
            /*     --------------- */
            /*  */
            /*     Can be called as a Matlab function or used for C-language code generation. */
            /*  */
            /*  */
            /*     Description */
            /*     ----------- */
            /*  */
            /*     When LinearExtrapTF == true, conduct linear interpolation or extrapolation.  */
            /*     When LinearExtrapTF == false, conduct linear interpolation only when xi falls within domain of  */
            /*     x. Otherwise, conduct nearest-neighbor extrapolation. */
            /*  */
            /*     When ValidityChecksTF == true, conduct checks and adjustments on values returned by linear */
            /*     interpolation / extrapolation. These checks and adjustments include ...   */
            /*  */
            /*     - Checking whether the difference between an interpolated value and a nearby actual value is */
            /*       within a specified threshold (DiffMaxActual). If not, this may be an indication of an   */
            /*       overshoot; in this case, the interpolated value is changed to the maximum value specified by  */
            /*       the threshold. This check and adjustment are only applied to an interpolated value  */
            /*       corresponding to the X- or Y-coordinate (rather than height or width) of the ROI. The check  */
            /*       is not applied to height or width as testing has indicated that an overshoot  is not as   */
            /*       common for height or width. */
            /*  */
            /*     - Checking whether an interpolated value corresponding to ROI height or width is above 20. If */
            /*       not, the interpolated value is recalculated by conducting nearest-neighbor extrapolation. A */
            /*       height or width below 20 is considered to be too small for the size of faces expected in a */
            /*       video. */
            /*  */
            /*     - Checking whether an interpolated value is within the frame dimensions (minimum of 1 and */
            /*       maximums of VidObjWidth and VidObjHeight). If not, the interpolated value is changed to be */
            /*       bounded by the frame dimensions. */
            /*  */
            /*     When YArbitrary is non-empty, conduct checks and adjustments on interpolated / extrapolated */
            /*     values. These checks and adjustments include ...   */
            /*  */
            /*     - Checking whether the difference between an interpolated value and a nearby arbitrary value  */
            /*       is within a specified threshold (DiffMaxArbitrary). If not, this may be an indication of an   */
            /*       overshoot; in this case, the interpolated value is changed to the maximum value specified by  */
            /*       the threshold. This check and adjustment are only applied to an interpolated value  */
            /*       corresponding to the X- or Y-coordinate (rather than height or width) of the ROI. The check  */
            /*       is not applied to height or width as testing has indicated that an overshoot is not as   */
            /*       common for height or width. */
            /*  */
            /*     Restrictions: */
            /*  */
            /*     - x is are assumed to increase monotonically and contain unique values. x must contain at */
            /*       least two elements. The number of elements must equal the number of elements of y.                         */
            /*     - xi is assumed to increase monotonically.  */
            /*     - y is assumed to have 4 columns. y must contain at least two elements. The number of elements  */
            /*       must equal the number of elements of x.  */
            /*  */
            /*     This function uses bounded variable sizes to improve efficiency. Ensure that inputs do not */
            /*     exceed the bounds. */
            /*  */
            /*     Inputs: */
            /*  */
            /*     x                = Time values that correspond to values of y. M x 1 column vector; type  */
            /*                        single. */
            /*     y                = Values from which to interpolate. M x :4 matrix; type int16.                    */
            /*     xi               = Time values at which interpolation will occur. The elements do not need to   */
            /*                        be unique. The number of values is not restricted. Column vector; type  */
            /*                        single.                                         */
            /*     LinearExtrapTF   = If true, use the linear method for extrapolation. If false, use the  */
            /*                        nearest-neighbor method. Scalar; type logical. */
            /*     ValidityChecksTF = If true, check whether the interpolated values appears valid. Scalar;  */
            /*                        type logical. */
            /*     DiffMaxActual    = The threshold specifying the maximum absolute-value difference between an  */
            /*                        interpolated / extrapolated value and a previous actual value. Scalar; type  */
            /*                        int16. Threshold only applied when InterpChecksTF == true;      */
            /*     DiffMaxArbitrary = The threshold specifying the maximum absolute-value difference between an  */
            /*                        interpolated / extrapolated value and an arbitrary X- or Y-coordinate   */
            /*                        value, which is specified by YArbitrary. Scalar; type int16.                      */
            /*     YArbitrary       = Arbitary X- and Y-coordinate values used with the threshold specified by  */
            /*                        DiffMaxArbitrary. To disable DiffMaxArbitrary checks, use 0 x 2 input.                         */
            /*                        0 x 2 or 1 x 2 row vector; type int16.                                                                                     */
            /*     VidObjWidth      = The frame width. Scalar; type int16. */
            /*     VidObjHeight     = The frame height. Scalar; type int16. */
            /*  */
            /*  */
            /*     Copyright */
            /*     --------- */
            /*  */
            /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
            /*     the Responsible AI License (RAIL). */
            /* Inline function */
            /* Whether to conduct arbitrary value check */
            /* Length of input time points */
            /* Length of input interpolation timepoints */
            /* This length will equal the length of yi. */
            /* Assert length to prevent dynamic memory allocation by colon operator */
            /* Preallocate output */
            /* Initialize x_idx at 1  */
            /* x_idx is used to search for the value of x that is greater than xi. */
            /* In while loop, the first operation is to increment j by 1; hence, the effective use of x_idx */
            /* starts at 2. */
            /* By initializing x_idx here, rather than after each iteration of i, it is assumed that both x and   */
            /* xi are sorted in order from least to greatest. This assumption improves performance because values  */
            /* of x already matched are not researched (a qualification is that the implementation does research   */
            /* the immediately previous value of x -- see note within loop). If x or xi is not sorted, the    */
            /* initialization of x_idx (setting x_idx to 1) should occur after each iteration of i. */
            Start = 0;

            /* Loop across interpolation times points */
            /* The ith xi value (the ith interpolation point) */
            /* Find the indices of x: x_before_idx and x_after_idx:       */
            /* If ith xi value is to left of domain of x */
            /* Case of extrapolation. */
            if (HeightRatio_Single < c_TimestampBlockDetections_FR_d[0]) {
              /* If linear extrapolation permitted */
              /* Flag indicating ith xi value is to left of domain of x */
              /* Nearest-neighbor extrapolation */
              /* Local function. */
              /* 1 x nColsY row vector; type int16.    */
              /* end local function */
              /* ============================================================================================= */
              /* ExtrapNearest   Nearest-neighbor extrapolation of y at single time point (xi). */
              /* Inline function */
              /* Preallocate output for ith yi values */
              /* If ith xi value is to left of domain of x */
              /* Loop across columns of y */
              /* Assign from first row of y */
              ROIOut_FR[0] = e_NoPrevCallsBlock_ROIDetection[0];

              /* If arbitary check enabled */
              /* Assign from first row of y */
              ROIOut_FR[1] =
                e_NoPrevCallsBlock_ROIDetection[d_NoPrevCallsBlock_ROIDetection];

              /* If arbitary check enabled */
              /* Assign from first row of y */
              ROIOut_FR[2] =
                e_NoPrevCallsBlock_ROIDetection[d_NoPrevCallsBlock_ROIDetection *
                2];

              /* If arbitary check enabled */
              /* Assign from first row of y */
              ROIOut_FR[3] =
                e_NoPrevCallsBlock_ROIDetection[d_NoPrevCallsBlock_ROIDetection *
                3];

              /* If arbitary check enabled */
              /* If ith xi value is to right of domain of x     */
              /* If ith xi value is either within domain of x or to right of domain of x       */
            } else {
              /* If xi is within the domain of x, ... */
              /*  - x_before_idx is the index of x where x is less than xi. */
              /*  - x_after_idx is the index of x where x is greater than or equal to xi. */
              /* If xi is to right of the domain of x, ... */
              /*  - both x_before_idx and x_after_idx index x where x is less than xi.  */
              /*  - x at x_before_idx is less than x at x_after_idx. */
              do {
                exitg2 = 0;
                Start++;

                /* If ith xi value is to right of domain of x */
                /* Case of extrapolation. */
                if (Start + 1 >= c_TimestampBlockDetections_FR_s) {
                  /* If linear extrapolation permitted */
                  /* Flag indicating ith xi value is to right of domain of x */
                  /* Nearest-neighbor extrapolation */
                  /* Local function. */
                  /* 1 x nColsY row vector; type int16.    */
                  /* end local function */
                  /* ============================================================================================= */
                  /* ExtrapNearest   Nearest-neighbor extrapolation of y at single time point (xi). */
                  /* Inline function */
                  /* Preallocate output for ith yi values */
                  /* If ith xi value is to left of domain of x */
                  /* Loop across columns of y */
                  /* Assign from last row of y */
                  ROIOut_FR[0] =
                    e_NoPrevCallsBlock_ROIDetection[c_TimestampBlockDetections_FR_s
                    - 1];

                  /* If arbitary check enabled */
                  /* Assign from last row of y */
                  ROIOut_FR[1] = e_NoPrevCallsBlock_ROIDetection
                    [(c_TimestampBlockDetections_FR_s +
                      d_NoPrevCallsBlock_ROIDetection) - 1];

                  /* If arbitary check enabled */
                  /* Assign from last row of y */
                  ROIOut_FR[2] = e_NoPrevCallsBlock_ROIDetection
                    [(c_TimestampBlockDetections_FR_s +
                      d_NoPrevCallsBlock_ROIDetection * 2) - 1];

                  /* If arbitary check enabled */
                  /* Assign from last row of y */
                  ROIOut_FR[3] = e_NoPrevCallsBlock_ROIDetection
                    [(c_TimestampBlockDetections_FR_s +
                      d_NoPrevCallsBlock_ROIDetection * 3) - 1];

                  /* If arbitary check enabled */
                  /* Set back x_idx by one for use for i+1th xi element. */
                  /* xi is assumed to be sorted, but the values are not assumed to be unique, so x_idx */
                  /* should start back by one in case the next value of xi is the same as the current. */
                  /* Even is all values are unique, floating-point imprecision could effectively cause */
                  /* some to be non-unique. */
                  exitg2 = 1;
                } else {
                  if (c_TimestampBlockDetections_FR_d[Start] >=
                      HeightRatio_Single) {
                    /* Assign x indices */
                    /* Linear interpolation */
                    /* Local function. */
                    /* 1 x nColsY row vector; type int16.                 */
                    /* end main function */
                    /* ============================================================================================= */
                    /* Local functions */
                    /* ============================================================================================= */
                    /* ============================================================================================= */
                    /* InterpLinear   Linear interpolation of y at a single time point (xi). */
                    /* Inline function */
                    /* Preallocate output for ith yi values */
                    /* Assign x values   */
                    /* Scalars; type single. */
                    WidthRatio_Single = c_TimestampBlockDetections_FR_d[Start -
                      1];
                    x_after = c_TimestampBlockDetections_FR_d[Start];

                    /* Proportion of interpolated time interval to actual time interval */
                    /* Scalar; type single. */
                    b_r = (HeightRatio_Single - WidthRatio_Single) /
                      (c_TimestampBlockDetections_FR_d[Start] -
                       WidthRatio_Single);

                    /* Loop across columns of y */
                    /* y value that comes before time point to be interpolated */
                    /* Scalar; type int16. */
                    Height_ith = e_NoPrevCallsBlock_ROIDetection[Start - 1];

                    /* y value that comes after time point to be interpolated */
                    /* Scalar; type int16. */
                    Width_ith = e_NoPrevCallsBlock_ROIDetection[Start];

                    /* %%%%% Skip interpolation %%%%%% */
                    /* If y values same, assign one of them as interpolated value */
                    if (Height_ith == Width_ith) {
                      WidthNew_ith = Height_ith;

                      /* %%%%% Interpolate %%%%%%          */
                    } else {
                      /* Step 1 */
                      /* Interpolated distance of y. */
                      /* Multipy interpolated time-interval proportion by actual change in y. */
                      /* Cast to floating-point type to multiply.   */
                      /* Step 2 */
                      /* Add distance to most immediate previous actual y value. */
                      WidthNew_ith = (int16_T)(Height_ith + (int16_T)
                        muSingleScalarRound((real32_T)(int16_T)(Width_ith -
                        Height_ith) * b_r));

                      /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                      /* Local function. */
                      /* Scalar; type int16. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                      /* Inline function */
                      /* Switch according to column */
                      /* x-coordinate column */
                      /* Local function. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck_XY   Validity check for X- or Y-coordinate. */
                      /*  */
                      /*     Description: */
                      /*  */
                      /*     Check whether difference between before-value and interpolated / extrapolated value is greater   */
                      /*     than specified threshold. If so, set value at maximum of threshold.  */
                      /* Inline function */
                      Width_ith = (int16_T)(WidthNew_ith - Height_ith);
                      if (Width_ith > c_ROIGeneralConfig_ROIMSIR_Diff) {
                        WidthNew_ith = (int16_T)(Height_ith +
                          c_ROIGeneralConfig_ROIMSIR_Diff);
                      } else {
                        if (Width_ith < (int16_T)
                            -c_ROIGeneralConfig_ROIMSIR_Diff) {
                          WidthNew_ith = (int16_T)(Height_ith -
                            c_ROIGeneralConfig_ROIMSIR_Diff);
                        }
                      }
                    }

                    /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                    /* If arbitary check enabled    */
                    /* %%%%% Assign %%%%%% */
                    ROIOut_FR[0] = WidthNew_ith;

                    /* y value that comes before time point to be interpolated */
                    /* Scalar; type int16. */
                    VideoReadConfig_FrameIdx_Length = Start +
                      d_NoPrevCallsBlock_ROIDetection;
                    Height_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length
                      - 1];

                    /* y value that comes after time point to be interpolated */
                    /* Scalar; type int16. */
                    Width_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length];

                    /* %%%%% Skip interpolation %%%%%% */
                    /* If y values same, assign one of them as interpolated value */
                    if (Height_ith == Width_ith) {
                      WidthNew_ith = Height_ith;

                      /* %%%%% Interpolate %%%%%%          */
                    } else {
                      /* Step 1 */
                      /* Interpolated distance of y. */
                      /* Multipy interpolated time-interval proportion by actual change in y. */
                      /* Cast to floating-point type to multiply.   */
                      /* Step 2 */
                      /* Add distance to most immediate previous actual y value. */
                      WidthNew_ith = (int16_T)(Height_ith + (int16_T)
                        muSingleScalarRound((real32_T)(int16_T)(Width_ith -
                        Height_ith) * b_r));

                      /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                      /* Local function. */
                      /* Scalar; type int16. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                      /* Inline function */
                      /* Switch according to column */
                      /* y-coordinate column */
                      /* Local function. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck_XY   Validity check for X- or Y-coordinate. */
                      /*  */
                      /*     Description: */
                      /*  */
                      /*     Check whether difference between before-value and interpolated / extrapolated value is greater   */
                      /*     than specified threshold. If so, set value at maximum of threshold.  */
                      /* Inline function */
                      Width_ith = (int16_T)(WidthNew_ith - Height_ith);
                      if (Width_ith > c_ROIGeneralConfig_ROIMSIR_Diff) {
                        WidthNew_ith = (int16_T)(Height_ith +
                          c_ROIGeneralConfig_ROIMSIR_Diff);
                      } else {
                        if (Width_ith < (int16_T)
                            -c_ROIGeneralConfig_ROIMSIR_Diff) {
                          WidthNew_ith = (int16_T)(Height_ith -
                            c_ROIGeneralConfig_ROIMSIR_Diff);
                        }
                      }
                    }

                    /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                    /* If arbitary check enabled    */
                    /* %%%%% Assign %%%%%% */
                    ROIOut_FR[1] = WidthNew_ith;

                    /* y value that comes before time point to be interpolated */
                    /* Scalar; type int16. */
                    VideoReadConfig_FrameIdx_Length = Start +
                      d_NoPrevCallsBlock_ROIDetection * 2;
                    Height_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length
                      - 1];

                    /* y value that comes after time point to be interpolated */
                    /* Scalar; type int16. */
                    Width_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length];

                    /* %%%%% Skip interpolation %%%%%% */
                    /* If y values same, assign one of them as interpolated value */
                    if (Height_ith == Width_ith) {
                      WidthNew_ith = Height_ith;

                      /* %%%%% Interpolate %%%%%%          */
                    } else {
                      /* Step 1 */
                      /* Interpolated distance of y. */
                      /* Multipy interpolated time-interval proportion by actual change in y. */
                      /* Cast to floating-point type to multiply.   */
                      /* Step 2 */
                      /* Add distance to most immediate previous actual y value. */
                      WidthNew_ith = (int16_T)(Height_ith + (int16_T)
                        muSingleScalarRound((real32_T)(int16_T)(Width_ith -
                        Height_ith) * b_r));

                      /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                      /* Local function. */
                      /* Scalar; type int16. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                      /* Inline function */
                      /* Switch according to column */
                      /* width column */
                      /* Local function. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck_WH   Validity check for width or height. */
                      /*  */
                      /*     Description: */
                      /*  */
                      /*     Check whether width or height value is less than 20. If so, then substitute the  */
                      /*     nearest-neighbor method in place of the linear method. */
                      /* Inline function */
                      if (WidthNew_ith < 20) {
                        /* Determine whether x_after or x_before nearest and assign. */
                        /* x_after nearest */
                        if (muSingleScalarAbs(x_after - HeightRatio_Single) <=
                            muSingleScalarAbs(WidthRatio_Single -
                                              HeightRatio_Single)) {
                          WidthNew_ith = Width_ith;

                          /* x_before nearest */
                        } else {
                          WidthNew_ith = Height_ith;
                        }
                      }
                    }

                    /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                    /* If arbitary check enabled    */
                    /* %%%%% Assign %%%%%% */
                    ROIOut_FR[2] = WidthNew_ith;

                    /* y value that comes before time point to be interpolated */
                    /* Scalar; type int16. */
                    VideoReadConfig_FrameIdx_Length = Start +
                      d_NoPrevCallsBlock_ROIDetection * 3;
                    Height_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length
                      - 1];

                    /* y value that comes after time point to be interpolated */
                    /* Scalar; type int16. */
                    Width_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length];

                    /* %%%%% Skip interpolation %%%%%% */
                    /* If y values same, assign one of them as interpolated value */
                    if (Height_ith == Width_ith) {
                      WidthNew_ith = Height_ith;

                      /* %%%%% Interpolate %%%%%%          */
                    } else {
                      /* Step 1 */
                      /* Interpolated distance of y. */
                      /* Multipy interpolated time-interval proportion by actual change in y. */
                      /* Cast to floating-point type to multiply.   */
                      /* Step 2 */
                      /* Add distance to most immediate previous actual y value. */
                      WidthNew_ith = (int16_T)(Height_ith + (int16_T)
                        muSingleScalarRound((real32_T)(int16_T)(Width_ith -
                        Height_ith) * b_r));

                      /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                      /* Local function. */
                      /* Scalar; type int16. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                      /* Inline function */
                      /* Switch according to column */
                      /* height column */
                      /* Local function. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck_WH   Validity check for width or height. */
                      /*  */
                      /*     Description: */
                      /*  */
                      /*     Check whether width or height value is less than 20. If so, then substitute the  */
                      /*     nearest-neighbor method in place of the linear method. */
                      /* Inline function */
                      if (WidthNew_ith < 20) {
                        /* Determine whether x_after or x_before nearest and assign. */
                        /* x_after nearest */
                        if (muSingleScalarAbs(x_after - HeightRatio_Single) <=
                            muSingleScalarAbs(WidthRatio_Single -
                                              HeightRatio_Single)) {
                          WidthNew_ith = Width_ith;

                          /* x_before nearest */
                        } else {
                          WidthNew_ith = Height_ith;
                        }
                      }
                    }

                    /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                    /* If arbitary check enabled    */
                    /* %%%%% Assign %%%%%% */
                    ROIOut_FR[3] = WidthNew_ith;

                    /* Set back x_idx by one for use for i+1th xi element. */
                    /* xi is assumed to be sorted, but the values are not assumed to be unique, so x_idx */
                    /* should start back by one in case the next value of xi is the same as the current. */
                    /* Even is all values are unique, floating-point imprecision could effectively cause */
                    /* some to be non-unique. */
                    exitg2 = 1;
                  }
                }
              } while (exitg2 == 0);
            }

            /* Check whether interpolated values are within frame dimensions */
            /* If not, adjust to be within frame dimensions.         */
            /* Note: ROIAdjustIfExceedsFrameDims is a custom function located within folder */
            /* 'FacePulseRate'. */
            /* 1 x nColsY row vector; type int16. */
            /* ROIAdjustIfExceedsFrameDims   Verify whether proposed widths and heights of ROIs exceed frame  */
            /*                               dimensions and, if so, modify them to conform to frame dimensions. */
            /*                                */
            /*     Helper function to function FacePulseRate. */
            /*     Within function FacePulseRate, called by functions ROIResize, ROIMeans_FirstRead_Extrapolate, */
            /*     SkinDetect_EnlargeROI, ROIMSIR, ROIMSIR_MatchSize, ROIMSIR_DetectionSmooth,   */
            /*     ROIMSIR_Interpolate, and ROIMSIR_FrameByFrameSmooth.    */
            /*  */
            /*  */
            /*     Code Generation */
            /*     --------------- */
            /*  */
            /*     Can be called as a Matlab function or used for C-language code generation. */
            /*  */
            /*  */
            /*     Description */
            /*     ----------- */
            /*  */
            /*     This function verifies that ROIs that have had modifications to their sizes are still within */
            /*     the dimensions of the frame. If not, this function adjusts the dimensions (and, consequently,   */
            /*     the spatial coordinates) to conform to the frame dimensions. */
            /*  */
            /*     Note:  */
            /*  */
            /*     Intended only for use with integer types as rounding is not conducted. For modification for  */
            /*     use with floating-point types, rounding would be necessary as ROI values should be integers. */
            /*  */
            /*  */
            /*     Copyright */
            /*     --------- */
            /*  */
            /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
            /*     the Responsible AI License (RAIL). */
            /* %%%%% Validate inputs %%%%%% */
            /* Exit if empty */
            /* Validate whether input ROIsProposed is type int16. */
            /* Must be an integer type because no rounding is conducted. */
            /* Should be type int16 because the function is implemented to assign values of this type. */
            /* A non-matching type would be due to an implementation error. */
            /* %%%%% Running in code generation %%%%%% */
            /* When running in code generation, use for-loops. When running in Matlab code, use vectorization. */
            /* code generation running */
            /* Inline function */
            /* %%%%% --- Verify, and adjust if necessary, X-coordinates and widths %%%%%% */
            /* Adjust left-side X-coordinate if exceeds frame dimensions: */
            WidthNew_ith = (int16_T)(ROIOut_FR[0] - 1);
            if (ROIOut_FR[0] < 1) {
              WidthNew_ith = 0;

              /* recent code mod */
              ROIOut_FR[0] = 1;
            } else {
              if (ROIOut_FR[0] > VidObjWidth) {
                WidthNew_ith = (int16_T)(VidObjWidth - 1);

                /* recent code mod */
                ROIOut_FR[0] = VidObjWidth;
              }
            }

            /* Adjust right-side X-coordinate if exceeds frame dimensions: */
            Width_ith = (int16_T)(WidthNew_ith + ROIOut_FR[2]);
            if (Width_ith > VidObjWidth) {
              Width_ith = VidObjWidth;
              ROIOut_FR[2] = (int16_T)(VidObjWidth - WidthNew_ith);
            } else {
              if (Width_ith < 1) {
                Width_ith = 1;
                WidthNew_ith = 0;
                ROIOut_FR[0] = 1;
                ROIOut_FR[2] = 1;
              }
            }

            /* Adjust width if exceeds frame dimensions: */
            Width_ith -= WidthNew_ith;
            if (Width_ith > VidObjWidth) {
              ROIOut_FR[2] = VidObjWidth;
            } else {
              if (Width_ith < 1) {
                ROIOut_FR[2] = 1;
              }
            }

            /* %%%%% --- Verify, and adjust if necessary, Y-coordinates and heights %%%%%% */
            /* Adjust top-side Y-coordinate if exceeds frame dimensions: */
            Height_ith = (int16_T)(ROIOut_FR[1] - 1);
            if (ROIOut_FR[1] < 1) {
              Height_ith = 0;

              /* recent code mod */
              ROIOut_FR[1] = 1;
            } else {
              if (ROIOut_FR[1] > VidObjHeight) {
                Height_ith = (int16_T)(VidObjHeight - 1);

                /* recent code mod */
                ROIOut_FR[1] = VidObjHeight;
              }
            }

            /* Adjust bottom-side Y-coordinate if exceeds frame dimensions: */
            Width_ith = (int16_T)(Height_ith + ROIOut_FR[3]);
            if (Width_ith > VidObjHeight) {
              Width_ith = VidObjHeight;
              ROIOut_FR[3] = (int16_T)(VidObjHeight - Height_ith);
            } else {
              if (Width_ith < 1) {
                Width_ith = 1;
                Height_ith = 0;
                ROIOut_FR[1] = 1;
                ROIOut_FR[3] = 1;
              }
            }

            /* Adjust height value if exceeds frame dimensions: */
            HeightNew_ith = (int16_T)(Width_ith - Height_ith);
            if (HeightNew_ith > VidObjHeight) {
              ROIOut_FR[3] = VidObjHeight;
            } else {
              if (HeightNew_ith < 1) {
                ROIOut_FR[3] = 1;
              }
            }

            /* %%%%% Code generation not running %%%%%% */
            /* end function */
            /* ============================================================================================= */
            /* Code-generation and build script */
            /* ============================================================================================= */
            /* Code-generation and build script used to generate C-language code and create the compiled version  */
            /* (ROIAdjustIfExceedsFrameDims_mex) of the function. */
            /* { */
            /*  */
            /* %%%%% Specify variable-size input arguments %%%%%% */
            /*  */
            /* See Matlab documentation for coder.typeof. */
            /*  */
            /*                                   Example Code               Upp. Bounds   Var. Size (T/F)  Type */
            /* ROIsProposedCode   = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],     [1, 0] );        %int16 */
            /*            */
            /*        */
            /* %%%%% Specify fixed-size input arguments %%%%%% */
            /*  */
            /* VidObjWidthCode  = int16(0);          */
            /* VidObjHeightCode = int16(0); */
            /*                    */
            /*  */
            /* %%%%% Set configurations to increase performance %%%%%% */
            /*  */
            /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
            /* "Optimization Strategies" */
            /*  */
            /* cfg = coder.config('mex'); */
            /* cfg.GlobalDataSyncMethod = 'NoSync'; */
            /* cfg.ConstantInputs = 'IgnoreValues'; */
            /* cfg.ExtrinsicCalls = true; %permit to show assert error */
            /* cfg.SaturateOnIntegerOverflow = false; */
            /* cfg.IntegrityChecks = false; */
            /* cfg.ResponsivenessChecks = false; */
            /*  */
            /*  */
            /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
            /*  */
            /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
            /*  */
            /* The flags are specified as part of the code-generation configuration object. A custom function, */
            /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
            /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
            /* Matlab guidance found in */
            /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
            /*  */
            /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
            /* a character vector prior to execution of the codegen command. */
            /*  */
            /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
            /*  */
            /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
            /* is not present in the base workspace. */
            /*  */
            /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
            /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
            /* character vector to maintain the charater vector, */
            /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
            /*  */
            /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
            /*  */
            /* Assign to code-generation configuration object */
            /* cfg.PostCodeGenCommand = setbuildargsAsText; */
            /*  */
            /*  */
            /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
            /*  */
            /* codegen ROIAdjustIfExceedsFrameDims.m -report -config cfg -args {ROIsProposedCode, VidObjWidthCode, VidObjHeightCode} */
            /*                  */
            /* } */
            /* Assign interpolated / extrapolated values of yi at xi */
          }

          /* %%%%% >>>>>> Assign ROI without using interpolation / extrapoltion %%%%%%  */
          /* Fewer than two face-detection algorithm or skin-detection algorithm ROIs are present in  */
          /* ROIBlock. Note that this case should be relatively infrequent. Consequently,  */
          /* interpolation / extrapolation cannot be conducted. First, if there is at least one ROI   */
          /* that corresponds to a detection, use this ROI in place of interpolation / extrapolation.  */
          /* If an ROI corresponding to a detection cannot be found within the block, assign the full  */
          /* frame dimensions as the ROI.              */
          /* Fewer than two face-detection algorithm or skin-detection algorithm ROIs are present in  */
          /* ROIBlock.              */
        } else {
          /* Find the temporally-nearest non-zero ROI */
          /* If a non-zero ROI does not exist, assign an ROI whose dimensions take the dimensions  */
          /* of the full frame.      */
          /* Local function. */
          /* end main function */
          /* ============================================================================================= */
          /* Local functions */
          /* ============================================================================================= */
          /* ============================================================================================= */
          /* AssignROI   Assign an ROI in place of interpolation / extrapolation.     */
          /*  */
          /*     Description: */
          /*  */
          /*     Assign the single ROI that corresponds to a detection. If no frames within the block  */
          /*     correspond to a detection, assign the dimesions of the frame. */
          /*  */
          /*     Notes: */
          /*  */
          /*     - No interpolation conducted. */
          /*     - Calling this function is expected to occur infrequently. */
          /* Inline function */
          /* If a single ROI corresponding to an ROI exists */
          if (NDetectionsFaceSkin_FR == 1) {
            /* Note: NoPrevCallsBlock_ROIDetections will have exactly one row if this condition is entered; */
            /* clarify this fact to code generation by explicitly indexing the first row. */
            ROIOut_FR[0] = e_NoPrevCallsBlock_ROIDetection[0];
            ROIOut_FR[1] =
              e_NoPrevCallsBlock_ROIDetection[d_NoPrevCallsBlock_ROIDetection];
            ROIOut_FR[2] =
              e_NoPrevCallsBlock_ROIDetection[d_NoPrevCallsBlock_ROIDetection *
              2];
            ROIOut_FR[3] =
              e_NoPrevCallsBlock_ROIDetection[d_NoPrevCallsBlock_ROIDetection *
              3];

            /* No ROIs within the block correspond to detections     */
          } else {
            /* NDetectionsFaceSkin == 0 */
            /* Assign an ROI with dimensions of the full frame */
            /* 1 x 4 row vector; type int16. */
            ROIOut_FR[0] = 1;
            ROIOut_FR[1] = 1;
            ROIOut_FR[2] = VidObjWidth;
            ROIOut_FR[3] = VidObjHeight;
          }

          /* end local function */
        }
      }

      /* %%%%% Operations when called from second read %%%%%%       */
      /* Note: used during both the pre- and post-processing steps of second-read operations (function  */
      /* ROIMSIR called by function ROIMeans_SecondRead_TakeMeans). During the pre-processing step,   */
      /* interpolate / extrapolate ROIs near the beginning of the video that were not interpolated /  */
      /* extrapolated during the first-read operations. During the post-processing step, interpolate / */
      /* extrapolate ROIs near the beginning of the video based on recent skin-detection algorithm ROI  */
      /* detections. */
      /* %%%%% Output validation %%%%%% */
      /* For first-read operations */
      /* Assert row size as zero because this variable not used in first-read operations */
      /* This may help remove dynamic memory allocation for this variable. */
      /* Check whether any ROI value is zero */
      /* The operations of this function were intended to prevent values of zero, so such a value is */
      /* likely due to an implementation error in this function.  */
      if ((ROIOut_FR[0] == 0) || (ROIOut_FR[1] == 0) || (ROIOut_FR[2] == 0) ||
          (ROIOut_FR[3] == 0)) {
        /* Throw error */
        /* Called as extrinsic so that stack trace can be displayed. */
        b_sprintf(VideoReadConfig_FrameIdx_FR->data[RowToReturnFullLinIdx_FR - 1],
                  r1);
        i = varargin_2->size[0] * varargin_2->size[1];
        varargin_2->size[0] = 1;
        varargin_2->size[1] = r1->size[1] + 240;
        emxEnsureCapacity_char_T(varargin_2, i);
        for (i = 0; i < 79; i++) {
          varargin_2->data[i] = cv30[i];
        }

        for (i = 0; i < 69; i++) {
          varargin_2->data[i + 79] = cv31[i];
        }

        for (i = 0; i < 25; i++) {
          varargin_2->data[i + 148] = cv32[i];
        }

        Sum = r1->size[1];
        for (i = 0; i < Sum; i++) {
          varargin_2->data[i + 173] = r1->data[i];
        }

        for (i = 0; i < 67; i++) {
          varargin_2->data[(i + r1->size[1]) + 173] = cv33[i];
        }

        error(emlrt_marshallOut(cv3), b_emlrt_marshallOut(varargin_2),
              &n_emlrtMCI);
      }

      /* Check whether the ROI size is unreasonably small */
      /* Such a small size is likely due to an implementation error in this function. */
      /* This check is intended to be run when testing new implementations, as small ROI sizes are an */
      /* indication of a implementation error. As occassional values below 20 may be considered */
      /* acceptable, this check is not intended for use outside of testing. "Occassional" in this case    */
      /* might be defined as a few occurances out of 10,000. Flag ExpectedBehaviorTestTF enables the */
      /* check.     */
      if (ExpectedBehaviorTestTF && ((ROIOut_FR[2] < 20) || (ROIOut_FR[3] < 20)))
      {
        /* Note: function warning() not available for code generation; so it must have previously */
        /* been declared as extrinsic. */
        /* Function fprintf can not be used as a substitute for warning() in this case because  */
        /* fprintf can not accept variable-length arguments.      */
        b_sprintf(VideoReadConfig_FrameIdx_FR->data[RowToReturnFullLinIdx_FR - 1],
                  r1);
        i = varargin_2->size[0] * varargin_2->size[1];
        varargin_2->size[0] = 1;
        varargin_2->size[1] = r1->size[1] + 299;
        emxEnsureCapacity_char_T(varargin_2, i);
        for (i = 0; i < 72; i++) {
          varargin_2->data[i] = cv34[i];
        }

        for (i = 0; i < 74; i++) {
          varargin_2->data[i + 72] = cv27[i];
        }

        for (i = 0; i < 75; i++) {
          varargin_2->data[i + 146] = cv35[i];
        }

        for (i = 0; i < 11; i++) {
          varargin_2->data[i + 221] = cv29[i];
        }

        Sum = r1->size[1];
        for (i = 0; i < Sum; i++) {
          varargin_2->data[i + 232] = r1->data[i];
        }

        for (i = 0; i < 67; i++) {
          varargin_2->data[(i + r1->size[1]) + 232] = cv33[i];
        }

        warning(emlrt_marshallOut(cv3), b_emlrt_marshallOut(varargin_2),
                &o_emlrtMCI);
      }

      /* Check whether ROI type not int16 because other functions are implemented to accept values of   */
      /* this type.  */
      /* A non-matching type would be due to an implementation error. */
      /* For second-read operations     */
      /* end main function */
      /* ============================================================================================= */
      /* Code-generation and build script */
      /* ============================================================================================= */
      /* Note: this function is not currently used as a compiled function as it is nested within a */
      /* compiled function, ROIMSIR_mex. */
      /* Code-generation and build script used to generate C-language code and create the compiled version  */
      /* (ROIMSIR_Interpolate_mex) of the function. */
      /* { */
      /*                  */
      /*  */
      /* %%%%% Specify variable-size input arguments %%%%%% */
      /*  */
      /* See Matlab documentation for coder.typeof. */
      /*                                                      Example Code                 Upp. Bounds  Var. Size (T/F)  Type */
      /* ROINoPrevCallsBlockCode               = coder.typeof( zeros(500, 4, 'int16'),      [inf, 4],    [1, 0] );        %int16 */
      /* BlockFullLinIdxCode                   = coder.typeof( zeros(1, 500, 'int32'),      [1, inf],    [0, 1] );        %int32 */
      /* ROIBlockDetectionFaceSkinLogIdxCode   = coder.typeof( false(500, 1),               [inf, 1],    [1, 0] );        %logical */
      /* TimestampBlockCode                    = coder.typeof( zeros(500, 1, 'single'),     [inf, 1],    [1, 0] );        %single   */
      /* TimestampBlockDetectionsCode          = coder.typeof( zeros(500, 1, 'single'),     [inf, 1],    [1, 0] );        %single  */
      /* ROICode                               = coder.typeof( zeros(500, 4, 'int16'),      [inf, 4],    [1, 0] );        %int16  */
      /* VideoReadConfig_FrameIdxCode          = coder.typeof( zeros(1, 500, 'uint32'),     [1, inf],    [0, 1] );        %uint32  */
      /*                   */
      /*  */
      /* %%%%% Specify fixed-size input arguments %%%%%% */
      /*  */
      /* ROIGeneralConfig_MatchSmoothInterpolateResize_DiffMaxCode = int16(0); */
      /* ROIGeneralConfig_ROIWidthResizeFactorCode                 = double(0); */
      /* ROIGeneralConfig_ROIHeightResizeFactorCode                = double(0); */
      /* VidObjWidthCode                                           = int16(0);          */
      /* VidObjHeightCode                                          = int16(0); */
      /* FirstReadTFCode                                           = false; */
      /* RowToReturnFullLinIdxCode                                 = uint32(0); */
      /* RowToReturnBlockLinIdxCode                                = uint32(0); */
      /* FirstFrameMSIRLinIdxCode                                  = uint32(0); */
      /*  */
      /*  */
      /* %%%%% Set configurations to increase performance %%%%%% */
      /*  */
      /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
      /* "Optimization Strategies" */
      /* cfg = coder.config('mex'); */
      /* cfg.GlobalDataSyncMethod = 'NoSync'; */
      /* cfg.ConstantInputs = 'IgnoreValues'; */
      /* cfg.ExtrinsicCalls = false; */
      /* cfg.SaturateOnIntegerOverflow = false; */
      /* cfg.IntegrityChecks = false; */
      /* cfg.ResponsivenessChecks = false; */
      /*  */
      /*  */
      /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
      /*  */
      /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
      /*  */
      /* The flags are specified as part of the code-generation configuration object. A custom function, */
      /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
      /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
      /* Matlab guidance found in */
      /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
      /*  */
      /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
      /* a character vector prior to execution of the codegen command. */
      /*  */
      /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
      /*  */
      /* Argument buildInfo: this variable is assign by the caller (the codegen command executed  */
      /* below) and is not present in the base workspace. */
      /*  */
      /* Second argument: specify a cell array of compiler-specific flags, where each flag is a  */
      /* character vector. As function setbuildargs will be evaluated from text, use double ' quotes for  */
      /* each character vector to maintain the charater vector, */
      /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
      /*  */
      /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
      /*  */
      /* Assign to code-generation configuration object */
      /* cfg.PostCodeGenCommand = setbuildargsAsText; */
      /*  */
      /*  */
      /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
      /*  */
      /* codegen ROIMSIR_Interpolate.m -config cfg -args {ROINoPrevCallsBlockCode, BlockFullLinIdxCode, ROIBlockDetectionFaceSkinLogIdxCode, TimestampBlockCode, TimestampBlockDetectionsCode, ROICode, ROIGeneralConfig_MatchSmoothInterpolateResize_DiffMaxCode, ROIGeneralConfig_ROIWidthResizeFactorCode, ROIGeneralConfig_ROIHeightResizeFactorCode, VidObjWidthCode, VidObjHeightCode, FirstReadTFCode, VideoReadConfig_FrameIdxCode, RowToReturnFullLinIdxCode, RowToReturnBlockLinIdxCode, FirstFrameMSIRLinIdxCode} */
      /*               */
      /* } */
      /* Second-read operations        */
    } else {
      /* Note: during the second-read operations, the following arguments are entered but not used: */
      /* VideoReadConfig_FrameIdx_FR, ROINoResizeBlock_FR, RowToReturnFullLinIdx_FR,   */
      /* RowToReturnBlockLinIdx_FR, and ROIMSIR_FirstFrameLinIdx_FR. */
      /* Note: zero(s) were previously assigned for variables ROINoPrevCallsBlock_FR_Single,   */
      /* RowToReturnFullLinIdx_FR, RowToReturnBlockLinIdx_FR, and ROIMSIR_FirstFrameLinIdx_FR. */
      /*  M x 4 matrix; type int16 */
      /*  M x 1 column vector; type int32 */
      /* ROIMSIR_Interpolate    Interpolate or extrapolate ROIs for frames without a detection. */
      /*  */
      /*     Helper function to function FacePulseRate.  */
      /*     Within function FacePulseRate, called by function ROIMSIR. */
      /*  */
      /*  */
      /*     Code Generation */
      /*     --------------- */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /*  */
      /*  */
      /*     Description */
      /*     ----------- */
      /*  */
      /*     Interpolate or extrapolate X-, Y-coordinate, width, and height of ROI(s) that do not have a  */
      /*     corresponding face-detection or skin-detection algorithm detection. A detection will not be  */
      /*     present if no detection algorithm was able to make a detection or if the frame was skipped.   */
      /*  */
      /*     Linear interpolation is used rather than less conservative methods, such as PCHIP, to reduce   */
      /*     sudden fluctuations that do not reflect head movement. For extrapolation, use the  */
      /*     nearest-neighbor method rather than the linear method. */
      /*  */
      /*     Custom function Interp conducts most of the interpolation / extrapolation operations. Interp */
      /*     conducts linear interpolation or nearest-neighbor extrapolation. It also conducts various  */
      /*     checks to determine whether ROI appears valid.  */
      /*  */
      /*     If there are not at least two ROIs that correspond to detections within the block of frames */
      /*     used, linear interpolation / extrapolation is not possible. In this case, there may be at  */
      /*     least one ROI that corresponds to a detection within the block. If this is the case, assign */
      /*     this ROI in place of interpolation / extrapolation. Otherwise, assign the dimensions of the */
      /*     full frame as the ROI; for example, if the frame dimensions are 720 x 1280, assign the ROI as */
      /*     [1, 1, 1280, 720]. During the second read, if there are not two ROIs that correspond to  */
      /*     detections, the frame dimensions are assigned rather than using a single ROI that corresponds */
      /*     to a detection. This is done because the block size for the second read is quite large, and  */
      /*     the single ROI that corresponds to a detection may not be representative of all frames within */
      /*     the block. */
      /*  */
      /*     Arguments to function Interp: */
      /*  */
      /*     Note: see function Interp for a description of input validation. */
      /*  */
      /*    - TimestampBlockDetections                  = Time points used for interpolation. N-Detections    */
      /*                                                  x 1 column vector; type single.                                                  */
      /*    - NoPrevCallsBlock_ROIDetections            = Values used for interpolation. N-Detections x 4 */
      /*                                                  matrix; type int16. */
      /*    - TimestampTarget                           = Time point(s) at which interpolation to be    */
      /*                                                  assigned. For first-read operations, only one  */
      /*                                                  time point used; for second-read operations, many */
      /*                                                  may be used. Scalar or column vector; type  */
      /*                                                  single. */
      /*    - LinearExtrapTF                            = False: use nearest-neighbor rather than linear   */
      /*                                                  method when TimestampTarget is outside of the */
      /*                                                  domain of TimestampBlockDetections (i.e., when */
      /*                                                  extrapolation occurs). See the section below for */
      /*                                                  a description of these checks. Scalar; type  */
      /*                                                  logical. */
      /*    - ValidityChecksTF                          = Flag whether to check whether the interpolated / */
      /*                                                  extrapolated ROI seems reasonable. See function                                                  */
      /*    - ROIGeneralConfig_ROIMSIR_DiffMaxDetection = The threshold specifying the maximum  */
      /*                                                  absolute-value difference between the X- and    */
      /*                                                  Y-coordinates of the interpolated / extrapolated                                                                                         */
      /*                                                  ROI and the ROI corresponding to the     */
      /*                                                  temporally-nearest previous detection. The value */
      /*                                                  for this argument is currently assigned by */
      /*                                                  function ROIGeneralConfig_Setup. Scalar; type */
      /*                                                  int16. */
      /*    - ROINoResizeBlock_Previous                 = ROI X- and Y-coordinates of the previous frames;    */
      /*                                                  checked against threshold                                                    */
      /*                                                  ROIGeneralConfig_ROIMSIR_DiffMaxAdjacent. If size */
      /*                                                  of input is 0 x 2, this check is not conducted. */
      /*                                                  This check is conducted for first-read but not  */
      /*                                                  second-read operations. For second-read  */
      /*                                                  operations, this check is instead conducted after  */
      /*                                                  the call to this function. This is implemented */
      /*                                                  because, during the second-read operations,  */
      /*                                                  there may not be previous frames available at the */
      /*                                                  time the function is called. More specifically, */
      /*                                                  because the second-read ROIs are interpolated */
      /*                                                  at one time within the function, these  */
      /*                                                  interpolated ROIs would not be available for */
      /*                                                  input into function. N x 2 row vector; type  */
      /*                                                  int16.  */
      /*    - ROIGeneralConfig_ROIMSIR_DiffMaxAdjacent  = The threshold specifying the maximum   */
      /*                                                  absolute-value difference between the X- and    */
      /*                                                  Y-coordinates of the interpolated / extrapolated                                                                                       */
      /*                                                  ROI and the ROI of the previous frame. The value */
      /*                                                  for this argument is currently assigned by */
      /*                                                  function ROIGeneralConfig_Setup. Scalar; type  */
      /*                                                  int16.  */
      /*                                                                                                    */
      /*    - VidObjWidth */
      /*    - VidObjHeight  */
      /*  */
      /*    Checks enabled by the ValidityChecksTF argument to function Interp: */
      /*  */
      /*    - Checking whether the difference between an interpolated value and a nearby actual value is */
      /*      within a specified threshold (ROIGeneralConfig_ROIMSIR_DiffMax). If not, this may be an */
      /*      indication of an overshoot; in this case, the interpolated value is changed to the maximum  */
      /*      value specified by the threshold. This check and adjustment are only applied to an  */
      /*      interpolated value corresponding to the X- or Y-coordinate (rather than height or width) of  */
      /*      the ROI. The check is not applied to height or width as testing has indicated that an  */
      /*      overshoot is not as common for height or width.  */
      /*    - Checking whether an interpolated value corresponding to ROI height or width is above 20. If  */
      /*      not, the interpolated value is recalculated by conducting nearest-neighbor extrapolation. A */
      /*      height or width below 20 is considered to be too small for the size of faces expected in a  */
      /*      video.     */
      /*    - Checking whether an interpolated value is within the frame dimensions (minimum of 1 and */
      /*      maximums of VidObjWidth and VidObjHeight). If not, the interpolated value is changed to be */
      /*      bounded by the frame dimensions. */
      /*  */
      /*  */
      /*     Copyright */
      /*     --------- */
      /*  */
      /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), September, 2020. Licensed under the MIT License    */
      /*     and the Responsible AI License (RAIL).  */
      /* %%%%% Code generation settings %%%%%% */
      /* Inline function */
      /* Call function as extrinsic */
      /* See notes where warning() used. */
      /* Call function as extrinsic so that stack trace can be displayed */
      /* Declare variables: */
      /*                                          Upp. Bounds  Var. Size (T/F) */
      /* %%%%% Preallocate variables %%%%%% */
      /* Preallocate linear index of interpolated frame */
      /* Note: If not reassigned, 0 will act as a flag to other functions to indicate no ROIs were  */
      /* interpolated. */
      /* %%%%% Arguments to function Interp common to first- and second-read operations %%%%%% */
      /* False = use the nearest-neighbor method rather than the linear method for extrapolation. */
      /* Conduct checks on the validity of the interpolation / extrapolated ROI(s). */
      /* %%%%% Operations when called from first-read operations %%%%%%       */
      /* Note: ROIMSIR_InterpolateSR is a custom function located within folder 'FacePulseRate'. */
      /*  M x 4 row vector; type int16 */
      /*  M x 1 column vector; type int32 */
      /* ROIMSIR_InterpolateSR   Interpolate or extrapolate ROIs for frames without a detection during the */
      /*                         second-read operations. */
      /*  */
      /*     Helper function to function FacePulseRate.  */
      /*     Within function FacePulseRate, called by function ROIMSIR_Interpolate. */
      /*  */
      /*     Code Generation */
      /*     --------------- */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /*  */
      /*  */
      /*     Description */
      /*     ----------- */
      /*  */
      /*     Interpolate or extrapolate ROIs for frames without a detection during the second-read  */
      /*     operations. If there are not at least two ROIs that correspond to detections within the block  */
      /*     of frames used, linear interpolation / extrapolation is not possible. In this case, there may  */
      /*     be at least one ROI that corresponds to a detection within the block. If this is the case,  */
      /*     assign this ROI in place of interpolation / extrapolation. Otherwise, assign the dimensions of  */
      /*     the full frame as the ROI; for example, if the frame dimensions are 720 x 1280, assign the ROI  */
      /*     as [1, 1, 1280, 720].  */
      /*  */
      /*     A different function, ROIMSIR_InterpolateFR, conducts interpolation / extrapolation during the */
      /*     first-read operations.   */
      /*  */
      /*     Note: if there are exactly zero detections within the block, then function  */
      /*     ROIMSIR_OutputIfNoDetections_SecondRead, called by function ROIMSIR, would have returned ROIs */
      /*     of the full frame dimensions and returned InterpolatedLinIdx_SR filled with the indices of all */
      /*     frames within the block. ROIMSIR would then have terminated immediately after that assignment, */
      /*     preventing the current function from being called. */
      /*  */
      /*     For a more detailed description, see function ROIMSIR_Interpolate. */
      /*  */
      /*  */
      /*     Copyright */
      /*     --------- */
      /*  */
      /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), September, 2020. Licensed under the MIT License    */
      /*     and the Responsible AI License (RAIL). */
      /* %%%%% Code generation settings %%%%%% */
      /* Inline function */
      /* %%%%% Initialize variables %%%%%% */
      /* Note: If not reassigned, 0 will act as a flag to other functions to indicate no ROIs were  */
      /* interpolated. */
      VideoReadConfig_FrameIdx_Length = 1;
      c_ROIBlockDetectionSkinLinIdx_F[0] = 0;

      /* %%%%% Assign ROIs for frames without detections %%%%%% */
      /* At least one frame without a detection (for interp / extrap) */
      if (NNoDetectionsFaceSkin_SR > 0) {
        /* Linear index of frames where ROIs assigned */
        /* Convert linear index aligning with block to align with length of video.   */
        /* Note: these indices may not necessarily be the result of interpolation / extrapolation if */
        /* too few detections were available on which to base interpolation / extrapolation. In that */
        /* case, ROIs will have been assigned using an alternative method. */
        VideoReadConfig_FrameIdx_Length = d_ROIBlockNoDetectionFaceSkinLi;
        for (i = 0; i < d_ROIBlockNoDetectionFaceSkinLi; i++) {
          c_ROIBlockDetectionSkinLinIdx_F[i] =
            (g_ROIBlockNoDetectionFaceSkinLi[i] + BlockFullLinIdx_SR->data[0]) -
            1;
        }

        /* %%%%% --- Interpolate / extrapolate %%%%%%         */
        /* If at least two detections are present within the block */
        /* The detections counted come from both the face- and skin-detection algorithms. */
        /* At least two ROIs corresponding to detections are needed so that they can be used as the */
        /* basis of interpolation or extrapolation.     */
        if (NDetectionsFaceSkin_SR > 1) {
          /* %%%%% >>>>>> Interpolate / extrapolate %%%%%% */
          /* Arguments to function Interp for second-read operations: */
          /* Timestamps in block corresponding to frames without a detection */
          /* Column vector; type single. */
          /* NoPrevCallsBlock_ROIDetections = ROIs corresponding to detections that do not have  */
          /*                                  modifications from previous calls to ROIMSIR but do */
          /*                                  have modifications from the current call to ROIMSIR */
          /*                                  (by functions ROIMSIR_MatchSize and  */
          /*                                  ROIMSIR_DetectionSmooth). */
          /*                                  M x 4 matrix; type int16. */
          /* M x 4 matrix; type int16.  */
          /* Note: for a description of the arguments to function Interp, see the description at  */
          /* top.   */
          /* Note: Interp is a custom function located within folder 'FacePulseRate'.                     */
          /*  interpolated ROIs */
          /*  Time points used for */
          /*  interpolation. */
          /*  ROIs used for interpolation. */
          /*  Time points at which */
          /*  interpolation to be assigned. */
          /*  False: use nearest-neighbor */
          /*  method for extrapolation. */
          /*  Empty = do not conduct adjacent */
          /*  ROI check. */
          /* Interp   Conduct linear interpolation/extrapolation or nearest-neighbor extrapolation. */
          /*  */
          /*     Helper function to function FacePulseRate.  */
          /*     Within function FacePulseRate, called by functions ROIMeans_FirstRead_ExtrapolateROI,  */
          /*     ROIMSIR_Interpolate and ROIMSIR_FrameByFrameSmooth_InterpFR. */
          /*      */
          /*  */
          /*     Code Generation */
          /*     --------------- */
          /*  */
          /*     Can be called as a Matlab function or used for C-language code generation. */
          /*  */
          /*  */
          /*     Description */
          /*     ----------- */
          /*  */
          /*     When LinearExtrapTF == true, conduct linear interpolation or extrapolation.  */
          /*     When LinearExtrapTF == false, conduct linear interpolation only when xi falls within domain of  */
          /*     x. Otherwise, conduct nearest-neighbor extrapolation. */
          /*  */
          /*     When ValidityChecksTF == true, conduct checks and adjustments on values returned by linear */
          /*     interpolation / extrapolation. These checks and adjustments include ...   */
          /*  */
          /*     - Checking whether the difference between an interpolated value and a nearby actual value is */
          /*       within a specified threshold (DiffMaxActual). If not, this may be an indication of an   */
          /*       overshoot; in this case, the interpolated value is changed to the maximum value specified by  */
          /*       the threshold. This check and adjustment are only applied to an interpolated value  */
          /*       corresponding to the X- or Y-coordinate (rather than height or width) of the ROI. The check  */
          /*       is not applied to height or width as testing has indicated that an overshoot  is not as   */
          /*       common for height or width. */
          /*  */
          /*     - Checking whether an interpolated value corresponding to ROI height or width is above 20. If */
          /*       not, the interpolated value is recalculated by conducting nearest-neighbor extrapolation. A */
          /*       height or width below 20 is considered to be too small for the size of faces expected in a */
          /*       video. */
          /*  */
          /*     - Checking whether an interpolated value is within the frame dimensions (minimum of 1 and */
          /*       maximums of VidObjWidth and VidObjHeight). If not, the interpolated value is changed to be */
          /*       bounded by the frame dimensions. */
          /*  */
          /*     When YArbitrary is non-empty, conduct checks and adjustments on interpolated / extrapolated */
          /*     values. These checks and adjustments include ...   */
          /*  */
          /*     - Checking whether the difference between an interpolated value and a nearby arbitrary value  */
          /*       is within a specified threshold (DiffMaxArbitrary). If not, this may be an indication of an   */
          /*       overshoot; in this case, the interpolated value is changed to the maximum value specified by  */
          /*       the threshold. This check and adjustment are only applied to an interpolated value  */
          /*       corresponding to the X- or Y-coordinate (rather than height or width) of the ROI. The check  */
          /*       is not applied to height or width as testing has indicated that an overshoot is not as   */
          /*       common for height or width. */
          /*  */
          /*     Restrictions: */
          /*  */
          /*     - x is are assumed to increase monotonically and contain unique values. x must contain at */
          /*       least two elements. The number of elements must equal the number of elements of y.                         */
          /*     - xi is assumed to increase monotonically.  */
          /*     - y is assumed to have 4 columns. y must contain at least two elements. The number of elements  */
          /*       must equal the number of elements of x.  */
          /*  */
          /*     This function uses bounded variable sizes to improve efficiency. Ensure that inputs do not */
          /*     exceed the bounds. */
          /*  */
          /*     Inputs: */
          /*  */
          /*     x                = Time values that correspond to values of y. M x 1 column vector; type  */
          /*                        single. */
          /*     y                = Values from which to interpolate. M x :4 matrix; type int16.                    */
          /*     xi               = Time values at which interpolation will occur. The elements do not need to   */
          /*                        be unique. The number of values is not restricted. Column vector; type  */
          /*                        single.                                         */
          /*     LinearExtrapTF   = If true, use the linear method for extrapolation. If false, use the  */
          /*                        nearest-neighbor method. Scalar; type logical. */
          /*     ValidityChecksTF = If true, check whether the interpolated values appears valid. Scalar;  */
          /*                        type logical. */
          /*     DiffMaxActual    = The threshold specifying the maximum absolute-value difference between an  */
          /*                        interpolated / extrapolated value and a previous actual value. Scalar; type  */
          /*                        int16. Threshold only applied when InterpChecksTF == true;      */
          /*     DiffMaxArbitrary = The threshold specifying the maximum absolute-value difference between an  */
          /*                        interpolated / extrapolated value and an arbitrary X- or Y-coordinate   */
          /*                        value, which is specified by YArbitrary. Scalar; type int16.                      */
          /*     YArbitrary       = Arbitary X- and Y-coordinate values used with the threshold specified by  */
          /*                        DiffMaxArbitrary. To disable DiffMaxArbitrary checks, use 0 x 2 input.                         */
          /*                        0 x 2 or 1 x 2 row vector; type int16.                                                                                     */
          /*     VidObjWidth      = The frame width. Scalar; type int16. */
          /*     VidObjHeight     = The frame height. Scalar; type int16. */
          /*  */
          /*  */
          /*     Copyright */
          /*     --------- */
          /*  */
          /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
          /*     the Responsible AI License (RAIL). */
          /* Inline function */
          /* Whether to conduct arbitrary value check */
          /* Length of input time points */
          Idx = TimestampBlockDetections_SR->size[0];

          /* Length of input interpolation timepoints */
          /* This length will equal the length of yi. */
          /* Assert length to prevent dynamic memory allocation by colon operator */
          /* Preallocate output */
          /* Initialize x_idx at 1  */
          /* x_idx is used to search for the value of x that is greater than xi. */
          /* In while loop, the first operation is to increment j by 1; hence, the effective use of x_idx */
          /* starts at 2. */
          /* By initializing x_idx here, rather than after each iteration of i, it is assumed that both x and   */
          /* xi are sorted in order from least to greatest. This assumption improves performance because values  */
          /* of x already matched are not researched (a qualification is that the implementation does research   */
          /* the immediately previous value of x -- see note within loop). If x or xi is not sorted, the    */
          /* initialization of x_idx (setting x_idx to 1) should occur after each iteration of i. */
          Start = 0;

          /* Loop across interpolation times points */
          for (Sum = 0; Sum < d_ROIBlockNoDetectionFaceSkinLi; Sum++) {
            /* The ith xi value (the ith interpolation point) */
            xi_ith_tmp = TimestampBlock_SR->
              data[g_ROIBlockNoDetectionFaceSkinLi[Sum] - 1];

            /* Find the indices of x: x_before_idx and x_after_idx:       */
            /* If ith xi value is to left of domain of x */
            /* Case of extrapolation. */
            if (xi_ith_tmp < TimestampBlockDetections_SR->data[0]) {
              /* If linear extrapolation permitted */
              /* Flag indicating ith xi value is to left of domain of x */
              /* Nearest-neighbor extrapolation */
              /* Local function. */
              /* 1 x nColsY row vector; type int16.    */
              /* end local function */
              /* ============================================================================================= */
              /* ExtrapNearest   Nearest-neighbor extrapolation of y at single time point (xi). */
              /* Inline function */
              /* Preallocate output for ith yi values */
              /* If ith xi value is to left of domain of x */
              /* Loop across columns of y */
              /* Assign from first row of y */
              yi_ith[0] = c_NoPrevCallsBlock_ROIDetection->data[0];

              /* If arbitary check enabled */
              /* Assign from first row of y */
              yi_ith[1] = c_NoPrevCallsBlock_ROIDetection->
                data[c_NoPrevCallsBlock_ROIDetection->size[0]];

              /* If arbitary check enabled */
              /* Assign from first row of y */
              yi_ith[2] = c_NoPrevCallsBlock_ROIDetection->
                data[c_NoPrevCallsBlock_ROIDetection->size[0] * 2];

              /* If arbitary check enabled */
              /* Assign from first row of y */
              yi_ith[3] = c_NoPrevCallsBlock_ROIDetection->
                data[c_NoPrevCallsBlock_ROIDetection->size[0] * 3];

              /* If arbitary check enabled */
              /* If ith xi value is to right of domain of x     */
              /* If ith xi value is either within domain of x or to right of domain of x       */
            } else {
              /* If xi is within the domain of x, ... */
              /*  - x_before_idx is the index of x where x is less than xi. */
              /*  - x_after_idx is the index of x where x is greater than or equal to xi. */
              /* If xi is to right of the domain of x, ... */
              /*  - both x_before_idx and x_after_idx index x where x is less than xi.  */
              /*  - x at x_before_idx is less than x at x_after_idx. */
              do {
                exitg2 = 0;
                Start++;

                /* If ith xi value is to right of domain of x */
                /* Case of extrapolation. */
                if (Start + 1 >= Idx) {
                  /* If linear extrapolation permitted */
                  /* Flag indicating ith xi value is to right of domain of x */
                  /* Nearest-neighbor extrapolation */
                  /* Local function. */
                  /* 1 x nColsY row vector; type int16.    */
                  /* end local function */
                  /* ============================================================================================= */
                  /* ExtrapNearest   Nearest-neighbor extrapolation of y at single time point (xi). */
                  /* Inline function */
                  /* Preallocate output for ith yi values */
                  /* If ith xi value is to left of domain of x */
                  /* Loop across columns of y */
                  /* Assign from last row of y */
                  yi_ith[0] = c_NoPrevCallsBlock_ROIDetection->data[Idx - 1];

                  /* If arbitary check enabled */
                  /* Assign from last row of y */
                  yi_ith[1] = c_NoPrevCallsBlock_ROIDetection->data[(Idx +
                    c_NoPrevCallsBlock_ROIDetection->size[0]) - 1];

                  /* If arbitary check enabled */
                  /* Assign from last row of y */
                  yi_ith[2] = c_NoPrevCallsBlock_ROIDetection->data[(Idx +
                    c_NoPrevCallsBlock_ROIDetection->size[0] * 2) - 1];

                  /* If arbitary check enabled */
                  /* Assign from last row of y */
                  yi_ith[3] = c_NoPrevCallsBlock_ROIDetection->data[(Idx +
                    c_NoPrevCallsBlock_ROIDetection->size[0] * 3) - 1];

                  /* If arbitary check enabled */
                  /* Set back x_idx by one for use for i+1th xi element. */
                  /* xi is assumed to be sorted, but the values are not assumed to be unique, so x_idx */
                  /* should start back by one in case the next value of xi is the same as the current. */
                  /* Even is all values are unique, floating-point imprecision could effectively cause */
                  /* some to be non-unique. */
                  Start--;
                  exitg2 = 1;
                } else {
                  if (TimestampBlockDetections_SR->data[Start] >= xi_ith_tmp) {
                    /* Assign x indices */
                    /* Linear interpolation */
                    /* Local function. */
                    /* 1 x nColsY row vector; type int16.                 */
                    /* end main function */
                    /* ============================================================================================= */
                    /* Local functions */
                    /* ============================================================================================= */
                    /* ============================================================================================= */
                    /* InterpLinear   Linear interpolation of y at a single time point (xi). */
                    /* Inline function */
                    /* Preallocate output for ith yi values */
                    /* Assign x values   */
                    /* Scalars; type single. */
                    WidthRatio_Single = TimestampBlockDetections_SR->data[Start
                      - 1];
                    x_after = TimestampBlockDetections_SR->data[Start];

                    /* Proportion of interpolated time interval to actual time interval */
                    /* Scalar; type single. */
                    b_r = (xi_ith_tmp - WidthRatio_Single) /
                      (TimestampBlockDetections_SR->data[Start] -
                       WidthRatio_Single);

                    /* Loop across columns of y */
                    /* y value that comes before time point to be interpolated */
                    /* Scalar; type int16. */
                    Height_ith = c_NoPrevCallsBlock_ROIDetection->data[Start - 1];

                    /* y value that comes after time point to be interpolated */
                    /* Scalar; type int16. */
                    Width_ith = c_NoPrevCallsBlock_ROIDetection->data[Start];

                    /* %%%%% Skip interpolation %%%%%% */
                    /* If y values same, assign one of them as interpolated value */
                    if (Height_ith == Width_ith) {
                      WidthNew_ith = Height_ith;

                      /* %%%%% Interpolate %%%%%%          */
                    } else {
                      /* Step 1 */
                      /* Interpolated distance of y. */
                      /* Multipy interpolated time-interval proportion by actual change in y. */
                      /* Cast to floating-point type to multiply.   */
                      /* Step 2 */
                      /* Add distance to most immediate previous actual y value. */
                      WidthNew_ith = (int16_T)(Height_ith + (int16_T)
                        muSingleScalarRound((real32_T)(int16_T)(Width_ith -
                        Height_ith) * b_r));

                      /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                      /* Local function. */
                      /* Scalar; type int16. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                      /* Inline function */
                      /* Switch according to column */
                      /* x-coordinate column */
                      /* Local function. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck_XY   Validity check for X- or Y-coordinate. */
                      /*  */
                      /*     Description: */
                      /*  */
                      /*     Check whether difference between before-value and interpolated / extrapolated value is greater   */
                      /*     than specified threshold. If so, set value at maximum of threshold.  */
                      /* Inline function */
                      Width_ith = (int16_T)(WidthNew_ith - Height_ith);
                      if (Width_ith > c_ROIGeneralConfig_ROIMSIR_Diff) {
                        WidthNew_ith = (int16_T)(Height_ith +
                          c_ROIGeneralConfig_ROIMSIR_Diff);
                      } else {
                        if (Width_ith < (int16_T)
                            -c_ROIGeneralConfig_ROIMSIR_Diff) {
                          WidthNew_ith = (int16_T)(Height_ith -
                            c_ROIGeneralConfig_ROIMSIR_Diff);
                        }
                      }
                    }

                    /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                    /* If arbitary check enabled    */
                    /* %%%%% Assign %%%%%% */
                    yi_ith[0] = WidthNew_ith;

                    /* y value that comes before time point to be interpolated */
                    /* Scalar; type int16. */
                    Height_ith = c_NoPrevCallsBlock_ROIDetection->data[(Start +
                      c_NoPrevCallsBlock_ROIDetection->size[0]) - 1];

                    /* y value that comes after time point to be interpolated */
                    /* Scalar; type int16. */
                    Width_ith = c_NoPrevCallsBlock_ROIDetection->data[Start +
                      c_NoPrevCallsBlock_ROIDetection->size[0]];

                    /* %%%%% Skip interpolation %%%%%% */
                    /* If y values same, assign one of them as interpolated value */
                    if (Height_ith == Width_ith) {
                      WidthNew_ith = Height_ith;

                      /* %%%%% Interpolate %%%%%%          */
                    } else {
                      /* Step 1 */
                      /* Interpolated distance of y. */
                      /* Multipy interpolated time-interval proportion by actual change in y. */
                      /* Cast to floating-point type to multiply.   */
                      /* Step 2 */
                      /* Add distance to most immediate previous actual y value. */
                      WidthNew_ith = (int16_T)(Height_ith + (int16_T)
                        muSingleScalarRound((real32_T)(int16_T)(Width_ith -
                        Height_ith) * b_r));

                      /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                      /* Local function. */
                      /* Scalar; type int16. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                      /* Inline function */
                      /* Switch according to column */
                      /* y-coordinate column */
                      /* Local function. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck_XY   Validity check for X- or Y-coordinate. */
                      /*  */
                      /*     Description: */
                      /*  */
                      /*     Check whether difference between before-value and interpolated / extrapolated value is greater   */
                      /*     than specified threshold. If so, set value at maximum of threshold.  */
                      /* Inline function */
                      Width_ith = (int16_T)(WidthNew_ith - Height_ith);
                      if (Width_ith > c_ROIGeneralConfig_ROIMSIR_Diff) {
                        WidthNew_ith = (int16_T)(Height_ith +
                          c_ROIGeneralConfig_ROIMSIR_Diff);
                      } else {
                        if (Width_ith < (int16_T)
                            -c_ROIGeneralConfig_ROIMSIR_Diff) {
                          WidthNew_ith = (int16_T)(Height_ith -
                            c_ROIGeneralConfig_ROIMSIR_Diff);
                        }
                      }
                    }

                    /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                    /* If arbitary check enabled    */
                    /* %%%%% Assign %%%%%% */
                    yi_ith[1] = WidthNew_ith;

                    /* y value that comes before time point to be interpolated */
                    /* Scalar; type int16. */
                    Height_ith = c_NoPrevCallsBlock_ROIDetection->data[(Start +
                      c_NoPrevCallsBlock_ROIDetection->size[0] * 2) - 1];

                    /* y value that comes after time point to be interpolated */
                    /* Scalar; type int16. */
                    Width_ith = c_NoPrevCallsBlock_ROIDetection->data[Start +
                      c_NoPrevCallsBlock_ROIDetection->size[0] * 2];

                    /* %%%%% Skip interpolation %%%%%% */
                    /* If y values same, assign one of them as interpolated value */
                    if (Height_ith == Width_ith) {
                      WidthNew_ith = Height_ith;

                      /* %%%%% Interpolate %%%%%%          */
                    } else {
                      /* Step 1 */
                      /* Interpolated distance of y. */
                      /* Multipy interpolated time-interval proportion by actual change in y. */
                      /* Cast to floating-point type to multiply.   */
                      /* Step 2 */
                      /* Add distance to most immediate previous actual y value. */
                      WidthNew_ith = (int16_T)(Height_ith + (int16_T)
                        muSingleScalarRound((real32_T)(int16_T)(Width_ith -
                        Height_ith) * b_r));

                      /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                      /* Local function. */
                      /* Scalar; type int16. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                      /* Inline function */
                      /* Switch according to column */
                      /* width column */
                      /* Local function. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck_WH   Validity check for width or height. */
                      /*  */
                      /*     Description: */
                      /*  */
                      /*     Check whether width or height value is less than 20. If so, then substitute the  */
                      /*     nearest-neighbor method in place of the linear method. */
                      /* Inline function */
                      if (WidthNew_ith < 20) {
                        /* Determine whether x_after or x_before nearest and assign. */
                        /* x_after nearest */
                        if (muSingleScalarAbs(x_after - xi_ith_tmp) <=
                            muSingleScalarAbs(WidthRatio_Single - xi_ith_tmp)) {
                          WidthNew_ith = Width_ith;

                          /* x_before nearest */
                        } else {
                          WidthNew_ith = Height_ith;
                        }
                      }
                    }

                    /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                    /* If arbitary check enabled    */
                    /* %%%%% Assign %%%%%% */
                    yi_ith[2] = WidthNew_ith;

                    /* y value that comes before time point to be interpolated */
                    /* Scalar; type int16. */
                    Height_ith = c_NoPrevCallsBlock_ROIDetection->data[(Start +
                      c_NoPrevCallsBlock_ROIDetection->size[0] * 3) - 1];

                    /* y value that comes after time point to be interpolated */
                    /* Scalar; type int16. */
                    Width_ith = c_NoPrevCallsBlock_ROIDetection->data[Start +
                      c_NoPrevCallsBlock_ROIDetection->size[0] * 3];

                    /* %%%%% Skip interpolation %%%%%% */
                    /* If y values same, assign one of them as interpolated value */
                    if (Height_ith == Width_ith) {
                      WidthNew_ith = Height_ith;

                      /* %%%%% Interpolate %%%%%%          */
                    } else {
                      /* Step 1 */
                      /* Interpolated distance of y. */
                      /* Multipy interpolated time-interval proportion by actual change in y. */
                      /* Cast to floating-point type to multiply.   */
                      /* Step 2 */
                      /* Add distance to most immediate previous actual y value. */
                      WidthNew_ith = (int16_T)(Height_ith + (int16_T)
                        muSingleScalarRound((real32_T)(int16_T)(Width_ith -
                        Height_ith) * b_r));

                      /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                      /* Local function. */
                      /* Scalar; type int16. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                      /* Inline function */
                      /* Switch according to column */
                      /* height column */
                      /* Local function. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck_WH   Validity check for width or height. */
                      /*  */
                      /*     Description: */
                      /*  */
                      /*     Check whether width or height value is less than 20. If so, then substitute the  */
                      /*     nearest-neighbor method in place of the linear method. */
                      /* Inline function */
                      if (WidthNew_ith < 20) {
                        /* Determine whether x_after or x_before nearest and assign. */
                        /* x_after nearest */
                        if (muSingleScalarAbs(x_after - xi_ith_tmp) <=
                            muSingleScalarAbs(WidthRatio_Single - xi_ith_tmp)) {
                          WidthNew_ith = Width_ith;

                          /* x_before nearest */
                        } else {
                          WidthNew_ith = Height_ith;
                        }
                      }
                    }

                    /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                    /* If arbitary check enabled    */
                    /* %%%%% Assign %%%%%% */
                    yi_ith[3] = WidthNew_ith;

                    /* Set back x_idx by one for use for i+1th xi element. */
                    /* xi is assumed to be sorted, but the values are not assumed to be unique, so x_idx */
                    /* should start back by one in case the next value of xi is the same as the current. */
                    /* Even is all values are unique, floating-point imprecision could effectively cause */
                    /* some to be non-unique. */
                    Start--;
                    exitg2 = 1;
                  }
                }
              } while (exitg2 == 0);
            }

            /* Check whether interpolated values are within frame dimensions */
            /* If not, adjust to be within frame dimensions.         */
            /* Note: ROIAdjustIfExceedsFrameDims is a custom function located within folder */
            /* 'FacePulseRate'. */
            /* 1 x nColsY row vector; type int16. */
            /* ROIAdjustIfExceedsFrameDims   Verify whether proposed widths and heights of ROIs exceed frame  */
            /*                               dimensions and, if so, modify them to conform to frame dimensions. */
            /*                                */
            /*     Helper function to function FacePulseRate. */
            /*     Within function FacePulseRate, called by functions ROIResize, ROIMeans_FirstRead_Extrapolate, */
            /*     SkinDetect_EnlargeROI, ROIMSIR, ROIMSIR_MatchSize, ROIMSIR_DetectionSmooth,   */
            /*     ROIMSIR_Interpolate, and ROIMSIR_FrameByFrameSmooth.    */
            /*  */
            /*  */
            /*     Code Generation */
            /*     --------------- */
            /*  */
            /*     Can be called as a Matlab function or used for C-language code generation. */
            /*  */
            /*  */
            /*     Description */
            /*     ----------- */
            /*  */
            /*     This function verifies that ROIs that have had modifications to their sizes are still within */
            /*     the dimensions of the frame. If not, this function adjusts the dimensions (and, consequently,   */
            /*     the spatial coordinates) to conform to the frame dimensions. */
            /*  */
            /*     Note:  */
            /*  */
            /*     Intended only for use with integer types as rounding is not conducted. For modification for  */
            /*     use with floating-point types, rounding would be necessary as ROI values should be integers. */
            /*  */
            /*  */
            /*     Copyright */
            /*     --------- */
            /*  */
            /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
            /*     the Responsible AI License (RAIL). */
            /* %%%%% Validate inputs %%%%%% */
            /* Exit if empty */
            /* Validate whether input ROIsProposed is type int16. */
            /* Must be an integer type because no rounding is conducted. */
            /* Should be type int16 because the function is implemented to assign values of this type. */
            /* A non-matching type would be due to an implementation error. */
            /* %%%%% Running in code generation %%%%%% */
            /* When running in code generation, use for-loops. When running in Matlab code, use vectorization. */
            /* code generation running */
            /* Inline function */
            /* %%%%% --- Verify, and adjust if necessary, X-coordinates and widths %%%%%% */
            /* Adjust left-side X-coordinate if exceeds frame dimensions: */
            WidthNew_ith = (int16_T)(yi_ith[0] - 1);
            if (yi_ith[0] < 1) {
              WidthNew_ith = 0;

              /* recent code mod */
              yi_ith[0] = 1;
            } else {
              if (yi_ith[0] > VidObjWidth) {
                WidthNew_ith = (int16_T)(VidObjWidth - 1);

                /* recent code mod */
                yi_ith[0] = VidObjWidth;
              }
            }

            /* Adjust right-side X-coordinate if exceeds frame dimensions: */
            Width_ith = (int16_T)(WidthNew_ith + yi_ith[2]);
            if (Width_ith > VidObjWidth) {
              Width_ith = VidObjWidth;
              yi_ith[2] = (int16_T)(VidObjWidth - WidthNew_ith);
            } else {
              if (Width_ith < 1) {
                Width_ith = 1;
                WidthNew_ith = 0;
                yi_ith[0] = 1;
                yi_ith[2] = 1;
              }
            }

            /* Adjust width if exceeds frame dimensions: */
            Width_ith -= WidthNew_ith;
            if (Width_ith > VidObjWidth) {
              yi_ith[2] = VidObjWidth;
            } else {
              if (Width_ith < 1) {
                yi_ith[2] = 1;
              }
            }

            /* %%%%% --- Verify, and adjust if necessary, Y-coordinates and heights %%%%%% */
            /* Adjust top-side Y-coordinate if exceeds frame dimensions: */
            Height_ith = (int16_T)(yi_ith[1] - 1);
            if (yi_ith[1] < 1) {
              Height_ith = 0;

              /* recent code mod */
              yi_ith[1] = 1;
            } else {
              if (yi_ith[1] > VidObjHeight) {
                Height_ith = (int16_T)(VidObjHeight - 1);

                /* recent code mod */
                yi_ith[1] = VidObjHeight;
              }
            }

            /* Adjust bottom-side Y-coordinate if exceeds frame dimensions: */
            Width_ith = (int16_T)(Height_ith + yi_ith[3]);
            if (Width_ith > VidObjHeight) {
              Width_ith = VidObjHeight;
              yi_ith[3] = (int16_T)(VidObjHeight - Height_ith);
            } else {
              if (Width_ith < 1) {
                Width_ith = 1;
                Height_ith = 0;
                yi_ith[1] = 1;
                yi_ith[3] = 1;
              }
            }

            /* Adjust height value if exceeds frame dimensions: */
            HeightNew_ith = (int16_T)(Width_ith - Height_ith);
            if (HeightNew_ith > VidObjHeight) {
              yi_ith[3] = VidObjHeight;
            } else {
              if (HeightNew_ith < 1) {
                yi_ith[3] = 1;
              }
            }

            /* %%%%% Code generation not running %%%%%% */
            /* end function */
            /* ============================================================================================= */
            /* Code-generation and build script */
            /* ============================================================================================= */
            /* Code-generation and build script used to generate C-language code and create the compiled version  */
            /* (ROIAdjustIfExceedsFrameDims_mex) of the function. */
            /* { */
            /*  */
            /* %%%%% Specify variable-size input arguments %%%%%% */
            /*  */
            /* See Matlab documentation for coder.typeof. */
            /*  */
            /*                                   Example Code               Upp. Bounds   Var. Size (T/F)  Type */
            /* ROIsProposedCode   = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],     [1, 0] );        %int16 */
            /*            */
            /*        */
            /* %%%%% Specify fixed-size input arguments %%%%%% */
            /*  */
            /* VidObjWidthCode  = int16(0);          */
            /* VidObjHeightCode = int16(0); */
            /*                    */
            /*  */
            /* %%%%% Set configurations to increase performance %%%%%% */
            /*  */
            /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
            /* "Optimization Strategies" */
            /*  */
            /* cfg = coder.config('mex'); */
            /* cfg.GlobalDataSyncMethod = 'NoSync'; */
            /* cfg.ConstantInputs = 'IgnoreValues'; */
            /* cfg.ExtrinsicCalls = true; %permit to show assert error */
            /* cfg.SaturateOnIntegerOverflow = false; */
            /* cfg.IntegrityChecks = false; */
            /* cfg.ResponsivenessChecks = false; */
            /*  */
            /*  */
            /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
            /*  */
            /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
            /*  */
            /* The flags are specified as part of the code-generation configuration object. A custom function, */
            /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
            /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
            /* Matlab guidance found in */
            /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
            /*  */
            /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
            /* a character vector prior to execution of the codegen command. */
            /*  */
            /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
            /*  */
            /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
            /* is not present in the base workspace. */
            /*  */
            /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
            /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
            /* character vector to maintain the charater vector, */
            /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
            /*  */
            /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
            /*  */
            /* Assign to code-generation configuration object */
            /* cfg.PostCodeGenCommand = setbuildargsAsText; */
            /*  */
            /*  */
            /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
            /*  */
            /* codegen ROIAdjustIfExceedsFrameDims.m -report -config cfg -args {ROIsProposedCode, VidObjWidthCode, VidObjHeightCode} */
            /*                  */
            /* } */
            /* Assign interpolated / extrapolated values of yi at xi */
            ROIBlockFaceSkin_Temp_data[Sum] = yi_ith[0];
            ROIBlockFaceSkin_Temp_data[Sum + d_ROIBlockNoDetectionFaceSkinLi] =
              yi_ith[1];
            ROIBlockFaceSkin_Temp_data[Sum + d_ROIBlockNoDetectionFaceSkinLi * 2]
              = yi_ith[2];
            ROIBlockFaceSkin_Temp_data[Sum + d_ROIBlockNoDetectionFaceSkinLi * 3]
              = yi_ith[3];
          }

          for (i = 0; i < d_ROIBlockNoDetectionFaceSkinLi; i++) {
            ROINoPrevCallsBlock_SR->data[g_ROIBlockNoDetectionFaceSkinLi[i] - 1]
              = ROIBlockFaceSkin_Temp_data[i];
          }

          for (i = 0; i < d_ROIBlockNoDetectionFaceSkinLi; i++) {
            ROINoPrevCallsBlock_SR->data[(g_ROIBlockNoDetectionFaceSkinLi[i] +
              ROINoPrevCallsBlock_SR->size[0]) - 1] =
              ROIBlockFaceSkin_Temp_data[i + d_ROIBlockNoDetectionFaceSkinLi];
          }

          for (i = 0; i < d_ROIBlockNoDetectionFaceSkinLi; i++) {
            ROINoPrevCallsBlock_SR->data[(g_ROIBlockNoDetectionFaceSkinLi[i] +
              ROINoPrevCallsBlock_SR->size[0] * 2) - 1] =
              ROIBlockFaceSkin_Temp_data[i + d_ROIBlockNoDetectionFaceSkinLi * 2];
          }

          for (i = 0; i < d_ROIBlockNoDetectionFaceSkinLi; i++) {
            ROINoPrevCallsBlock_SR->data[(g_ROIBlockNoDetectionFaceSkinLi[i] +
              ROINoPrevCallsBlock_SR->size[0] * 3) - 1] =
              ROIBlockFaceSkin_Temp_data[i + d_ROIBlockNoDetectionFaceSkinLi * 3];
          }

          /* %%%%% >>>>>> Limit overshoots by capping movement of X- and Y-coordinates of adjacent ROIs %%%%%%          */
          /* Note: for first-read operations, this operation is conducted within function Interp.  */
          /* This operation is conducted outside of function Interp for second-read operations due   */
          /* to limitations of function Interp (see note at top). */
          /* Linear index of ROI values interpolated above */
          /* Convert to row vector for loop. */
          /* Row vector; type int32. */
          if (0 <= d_ROIBlockNoDetectionFaceSkinLi - 1) {
            memcpy(&f_ROIBlockNoDetectionFaceSkinLi[0],
                   &g_ROIBlockNoDetectionFaceSkinLi[0],
                   d_ROIBlockNoDetectionFaceSkinLi * sizeof(int32_T));
          }

          /* If an index equals 1, remove it as it cannot be compared to a previous ROI */
          /* Note: if an index equals 1, there will only be one such index and it will be located  */
          /* at position 1 of the vector. */
          if (g_ROIBlockNoDetectionFaceSkinLi[0] == 1) {
            if (2 > NNoDetectionsFaceSkin_SR) {
              i = 0;
              i1 = 0;
            } else {
              i = 1;
              i1 = NNoDetectionsFaceSkin_SR;
            }

            Sum = i1 - i;
            for (i1 = 0; i1 < Sum; i1++) {
              f_ROIBlockNoDetectionFaceSkinLi[i1] =
                g_ROIBlockNoDetectionFaceSkinLi[i + i1];
            }

            NNoDetectionsFaceSkin_SR--;
          }

          /* Maximum difference between an interpolated ROI and previous ROI X- and Y-coordinates */
          /* Specified in function ValidateAndConfigure. */
          /* Type int16. */
          /* Loop across X-coordinate and Y-coordinate columns */
          /* Loop across ROI rows corresponding to frames without detections */
          for (j = 0; j < NNoDetectionsFaceSkin_SR; j++) {
            /* Find difference between jth and j-1th rows */
            /* Type int16. */
            i = f_ROIBlockNoDetectionFaceSkinLi[j];
            Width_ith = (int16_T)(ROINoPrevCallsBlock_SR->data[i - 1] -
                                  ROINoPrevCallsBlock_SR->data[i - 2]);

            /* If difference greater than threshold */
            if (Width_ith > d_ROIGeneralConfig_ROIMSIR_Diff) {
              /* Replace with j-1th plus threshold */
              ROINoPrevCallsBlock_SR->data[i - 1] = (int16_T)
                (ROINoPrevCallsBlock_SR->data[i - 2] +
                 d_ROIGeneralConfig_ROIMSIR_Diff);

              /* If difference less than negative of threshold */
            } else {
              if (Width_ith < (int16_T)-d_ROIGeneralConfig_ROIMSIR_Diff) {
                /* Replace with j-1th minus threshold */
                ROINoPrevCallsBlock_SR->data[i - 1] = (int16_T)
                  (ROINoPrevCallsBlock_SR->data[i - 2] -
                   d_ROIGeneralConfig_ROIMSIR_Diff);
              }
            }
          }

          /* Loop across ROI rows corresponding to frames without detections */
          for (j = 0; j < NNoDetectionsFaceSkin_SR; j++) {
            /* Find difference between jth and j-1th rows */
            /* Type int16. */
            i = f_ROIBlockNoDetectionFaceSkinLi[j];
            winNew = ROINoPrevCallsBlock_SR->data[(i +
              ROINoPrevCallsBlock_SR->size[0]) - 2];
            Width_ith = (int16_T)(ROINoPrevCallsBlock_SR->data[(i +
              ROINoPrevCallsBlock_SR->size[0]) - 1] - winNew);

            /* If difference greater than threshold */
            if (Width_ith > d_ROIGeneralConfig_ROIMSIR_Diff) {
              /* Replace with j-1th plus threshold */
              ROINoPrevCallsBlock_SR->data[(i + ROINoPrevCallsBlock_SR->size[0])
                - 1] = (int16_T)(winNew + d_ROIGeneralConfig_ROIMSIR_Diff);

              /* If difference less than negative of threshold */
            } else {
              if (Width_ith < (int16_T)-d_ROIGeneralConfig_ROIMSIR_Diff) {
                /* Replace with j-1th minus threshold */
                ROINoPrevCallsBlock_SR->data[(i + ROINoPrevCallsBlock_SR->size[0])
                  - 1] = (int16_T)(winNew - d_ROIGeneralConfig_ROIMSIR_Diff);
              }
            }
          }

          /* Assign output: */
          /* M x 4 matrix; type int16. */
          /* %%%%% --- Assign ROIs without using interpolation / extrapoltion %%%%%%  */
          /* Fewer than two face-detection algorithm or skin-detection algorithm ROIs are present in  */
          /* ROIBlock. Note that this case should be relatively infrequent. Consequently,  */
          /* interpolation / extrapolation cannot be conducted. In place of interpolation /  */
          /* extrapolation, assign the full frame dimensions as the ROI. Unlike in the first-read */
          /* operations, the frame dimensions are assigned rather than using a single ROI that  */
          /* corresponds to a detection. This is done because the block size for the second read is  */
          /* quite large, and a single ROI may not be representative of all frames within the block. */
        } else {
          /* M x 4 row vector; type int16. */
          /*  Full frame values */
          /*  Number of frames without a */
          /*  detection. */
          yi_ith[0] = 1;
          yi_ith[1] = 1;
          yi_ith[2] = VidObjWidth;
          yi_ith[3] = VidObjHeight;
          b_repmat(yi_ith, NNoDetectionsFaceSkin_SR, ROIBlockFaceSkin_Temp_data,
                   ROIBlockFaceSkin_Temp_size);
          for (i = 0; i < d_ROIBlockNoDetectionFaceSkinLi; i++) {
            ROINoPrevCallsBlock_SR->data[g_ROIBlockNoDetectionFaceSkinLi[i] - 1]
              = ROIBlockFaceSkin_Temp_data[i];
          }
        }

        /* %%%%% No frames correspond to ROIs without detections %%%%%%     */
        /* If no ROIs need to be interpolated / extrapolated. No interpolation / extrapolation is conducted. */
        /* This condition should be accessed relatively infrequently. */
      } else {
        /* M x 4 matrix; type int16. */
      }

      /* %%%%% Adjust ROI(s) that exceed frame dimensions %%%%%%    */
      /* Function ROIAdjustIfExceedsFrameDims, called below, is also called within function Interp.  */
      /* As the X- and Y-coordinate check of ROIs was conduced outside of function Interp for second-read */
      /* operations, the ROIs need to be checked again here in second-read operations. */
      /* Note: Although ROI(s) are also checked later in function ROIMSIR, check here as well so that any */
      /* overshoots from interpolation / extrapolation don't affect the frame-by-frame smoothing operations  */
      /* in function ROIMSIR_FrameByFrameSmooth, which occurs before the check by ROIMSIR. Also, before the  */
      /* check by ROIMSIR, ROIs returned here will influence variable ROIOutBeforeFrameByFrameSmoothing_FR  */
      /* or ROIOutBeforeFrameByFrameSmoothing_SR (assigned in function ROIMSIR), and this variable needs to */
      /* be within frame dimensions for later use in function WriteFaceVideo.   */
      /* Note: used both the pre-processing and post-processing steps of second-read operations.  */
      /* Adjust any coordinates that exceed frame dimensions */
      /* M x 4 matrix; type int16. */
      /* Note: ROIAdjustIfExceedsFrameDims is a custom function located within folder 'FacePulseRate'. */
      /* ROIAdjustIfExceedsFrameDims   Verify whether proposed widths and heights of ROIs exceed frame  */
      /*                               dimensions and, if so, modify them to conform to frame dimensions. */
      /*                                */
      /*     Helper function to function FacePulseRate. */
      /*     Within function FacePulseRate, called by functions ROIResize, ROIMeans_FirstRead_Extrapolate, */
      /*     SkinDetect_EnlargeROI, ROIMSIR, ROIMSIR_MatchSize, ROIMSIR_DetectionSmooth,   */
      /*     ROIMSIR_Interpolate, and ROIMSIR_FrameByFrameSmooth.    */
      /*  */
      /*  */
      /*     Code Generation */
      /*     --------------- */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /*  */
      /*  */
      /*     Description */
      /*     ----------- */
      /*  */
      /*     This function verifies that ROIs that have had modifications to their sizes are still within */
      /*     the dimensions of the frame. If not, this function adjusts the dimensions (and, consequently,   */
      /*     the spatial coordinates) to conform to the frame dimensions. */
      /*  */
      /*     Note:  */
      /*  */
      /*     Intended only for use with integer types as rounding is not conducted. For modification for  */
      /*     use with floating-point types, rounding would be necessary as ROI values should be integers. */
      /*  */
      /*  */
      /*     Copyright */
      /*     --------- */
      /*  */
      /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
      /*     the Responsible AI License (RAIL). */
      /* %%%%% Validate inputs %%%%%% */
      /* Exit if empty */
      if (ROINoPrevCallsBlock_SR->size[0] != 0) {
        /* Validate whether input ROIsProposed is type int16. */
        /* Must be an integer type because no rounding is conducted. */
        /* Should be type int16 because the function is implemented to assign values of this type. */
        /* A non-matching type would be due to an implementation error. */
        /* %%%%% Running in code generation %%%%%% */
        /* When running in code generation, use for-loops. When running in Matlab code, use vectorization. */
        /* code generation running */
        /* Inline function */
        i = ROINoPrevCallsBlock_SR->size[0];
        for (b_i = 0; b_i < i; b_i++) {
          /* %%%%% --- Verify, and adjust if necessary, X-coordinates and widths %%%%%% */
          /* Adjust left-side X-coordinate if exceeds frame dimensions: */
          WidthNew_ith = ROINoPrevCallsBlock_SR->data[b_i];
          if (WidthNew_ith < 1) {
            WidthNew_ith = 1;

            /* recent code mod */
            ROINoPrevCallsBlock_SR->data[b_i] = 1;
          } else {
            if (WidthNew_ith > VidObjWidth) {
              WidthNew_ith = VidObjWidth;

              /* recent code mod */
              ROINoPrevCallsBlock_SR->data[b_i] = VidObjWidth;
            }
          }

          /* Adjust right-side X-coordinate if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(WidthNew_ith +
            ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size[0] *
            2]) - 1);
          if (Width_ith > VidObjWidth) {
            Width_ith = VidObjWidth;
            ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size[0] *
              2] = (int16_T)((int16_T)(VidObjWidth - WidthNew_ith) + 1);
          } else {
            if (Width_ith < 1) {
              Width_ith = 1;
              WidthNew_ith = 1;
              ROINoPrevCallsBlock_SR->data[b_i] = 1;
              ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size[0]
                * 2] = 1;
            }
          }

          /* Adjust width if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(Width_ith - WidthNew_ith) + 1);
          if (Width_ith > VidObjWidth) {
            ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size[0] *
              2] = VidObjWidth;
          } else {
            if (Width_ith < 1) {
              ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size[0]
                * 2] = 1;
            }
          }

          /* %%%%% --- Verify, and adjust if necessary, Y-coordinates and heights %%%%%% */
          /* Adjust top-side Y-coordinate if exceeds frame dimensions: */
          Height_ith = ROINoPrevCallsBlock_SR->data[b_i +
            ROINoPrevCallsBlock_SR->size[0]];
          if (Height_ith < 1) {
            Height_ith = 1;

            /* recent code mod */
            ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size[0]] =
              1;
          } else {
            if (Height_ith > VidObjHeight) {
              Height_ith = VidObjHeight;

              /* recent code mod */
              ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size[0]]
                = VidObjHeight;
            }
          }

          /* Adjust bottom-side Y-coordinate if exceeds frame dimensions: */
          Width_ith = (int16_T)((int16_T)(Height_ith +
            ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size[0] *
            3]) - 1);
          if (Width_ith > VidObjHeight) {
            Width_ith = VidObjHeight;
            ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size[0] *
              3] = (int16_T)((int16_T)(VidObjHeight - Height_ith) + 1);
          } else {
            if (Width_ith < 1) {
              Width_ith = 1;
              Height_ith = 1;
              ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size[0]]
                = 1;
              ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size[0]
                * 3] = 1;
            }
          }

          /* Adjust height value if exceeds frame dimensions: */
          HeightNew_ith = (int16_T)((int16_T)(Width_ith - Height_ith) + 1);
          if (HeightNew_ith > VidObjHeight) {
            ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size[0] *
              3] = VidObjHeight;
          } else {
            if (HeightNew_ith < 1) {
              ROINoPrevCallsBlock_SR->data[b_i + ROINoPrevCallsBlock_SR->size[0]
                * 3] = 1;
            }
          }
        }

        /* %%%%% Code generation not running %%%%%% */
      } else {
        /* Exit function */
      }

      /* end function */
      /* ============================================================================================= */
      /* Code-generation and build script */
      /* ============================================================================================= */
      /* Code-generation and build script used to generate C-language code and create the compiled version  */
      /* (ROIAdjustIfExceedsFrameDims_mex) of the function. */
      /* { */
      /*  */
      /* %%%%% Specify variable-size input arguments %%%%%% */
      /*  */
      /* See Matlab documentation for coder.typeof. */
      /*  */
      /*                                   Example Code               Upp. Bounds   Var. Size (T/F)  Type */
      /* ROIsProposedCode   = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],     [1, 0] );        %int16 */
      /*            */
      /*        */
      /* %%%%% Specify fixed-size input arguments %%%%%% */
      /*  */
      /* VidObjWidthCode  = int16(0);          */
      /* VidObjHeightCode = int16(0); */
      /*                    */
      /*  */
      /* %%%%% Set configurations to increase performance %%%%%% */
      /*  */
      /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
      /* "Optimization Strategies" */
      /*  */
      /* cfg = coder.config('mex'); */
      /* cfg.GlobalDataSyncMethod = 'NoSync'; */
      /* cfg.ConstantInputs = 'IgnoreValues'; */
      /* cfg.ExtrinsicCalls = true; %permit to show assert error */
      /* cfg.SaturateOnIntegerOverflow = false; */
      /* cfg.IntegrityChecks = false; */
      /* cfg.ResponsivenessChecks = false; */
      /*  */
      /*  */
      /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
      /*  */
      /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
      /*  */
      /* The flags are specified as part of the code-generation configuration object. A custom function, */
      /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
      /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
      /* Matlab guidance found in */
      /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
      /*  */
      /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
      /* a character vector prior to execution of the codegen command. */
      /*  */
      /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
      /*  */
      /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
      /* is not present in the base workspace. */
      /*  */
      /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
      /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
      /* character vector to maintain the charater vector, */
      /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
      /*  */
      /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
      /*  */
      /* Assign to code-generation configuration object */
      /* cfg.PostCodeGenCommand = setbuildargsAsText; */
      /*  */
      /*  */
      /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
      /*  */
      /* codegen ROIAdjustIfExceedsFrameDims.m -report -config cfg -args {ROIsProposedCode, VidObjWidthCode, VidObjHeightCode} */
      /*                  */
      /* } */
      /* end function */
      /* %%%%% Output validation %%%%%% */
      /* For first-read operations */
      /* Check whether any ROI value is zero */
      /* The operations of this function were intended to prevent values of zero, so such a value is */
      /* likely due to an implementation error in this function.  */
      i = b_x->size[0] * b_x->size[1];
      b_x->size[0] = ROINoPrevCallsBlock_SR->size[0];
      b_x->size[1] = 4;
      emxEnsureCapacity_boolean_T(b_x, i);
      Sum = ROINoPrevCallsBlock_SR->size[0] * ROINoPrevCallsBlock_SR->size[1];
      for (i = 0; i < Sum; i++) {
        b_x->data[i] = (ROINoPrevCallsBlock_SR->data[i] == 0);
      }

      winNew = b_x->size[0] << 2;
      c_x = *b_x;
      f_VideoReadConfig_FrameIdx_FR[0] = winNew;
      c_x.size = &f_VideoReadConfig_FrameIdx_FR[0];
      c_x.numDimensions = 1;
      if (any(&c_x)) {
        /* Throw exception */
        /* Called as extrinsic so that stack trace can be displayed. */
        /* Note: '%.0f' = floating point with no decimals. */
        error(emlrt_marshallOut(cv3), i_emlrt_marshallOut(cv36), &p_emlrtMCI);
      }

      /* Check whether the size of any ROI is unreasonably small */
      /* Such a small size is likely due to an implementation error in this function. */
      /* This check is intended to be run when testing new implementations, as small ROI sizes are an */
      /* indication of a implementation error. As occassional values below 20 may be considered */
      /* acceptable, this check is not intended for use outside of testing. "Occassional" in this case    */
      /* might be defined as a few occurances out of 10,000. Flag ExpectedBehaviorTestTF enables the */
      /* check. */
      guard3 = false;
      if (ExpectedBehaviorTestTF) {
        Sum = ROINoPrevCallsBlock_SR->size[0];
        i = b_HasROI_TF->size[0];
        b_HasROI_TF->size[0] = ROINoPrevCallsBlock_SR->size[0];
        emxEnsureCapacity_boolean_T(b_HasROI_TF, i);
        for (i = 0; i < Sum; i++) {
          b_HasROI_TF->data[i] = (ROINoPrevCallsBlock_SR->data[i +
            ROINoPrevCallsBlock_SR->size[0] * 2] < 20);
        }

        if (any(b_HasROI_TF)) {
          /* Display warning */
          /* Note: function warning() not available for code generation, so it must have previously */
          /* been declared as extrinsic. */
          warning(emlrt_marshallOut(cv3), j_emlrt_marshallOut(cv37), &q_emlrtMCI);
        } else {
          guard3 = true;
        }
      } else {
        guard3 = true;
      }

      if (guard3) {
        Sum = ROINoPrevCallsBlock_SR->size[0];
        i = b_HasROI_TF->size[0];
        b_HasROI_TF->size[0] = ROINoPrevCallsBlock_SR->size[0];
        emxEnsureCapacity_boolean_T(b_HasROI_TF, i);
        for (i = 0; i < Sum; i++) {
          b_HasROI_TF->data[i] = (ROINoPrevCallsBlock_SR->data[i +
            ROINoPrevCallsBlock_SR->size[0] * 3] < 20);
        }

        if (any(b_HasROI_TF)) {
          /* Display warning */
          /* Note: function warning() not available for code generation, so it must have previously */
          /* been declared as extrinsic. */
          warning(emlrt_marshallOut(cv3), j_emlrt_marshallOut(cv37), &q_emlrtMCI);
        }
      }

      /* Check if ROI type not int16 because other functions are implemented to accept values of this  */
      /* type.  */
      /* A non-matching type would be due to an implementation error. */
      /* end main function */
      /* ============================================================================================= */
      /* Code-generation and build script */
      /* ============================================================================================= */
      /* Note: this function is not currently used as a compiled function as it is nested within a */
      /* compiled function, ROIMSIR_mex. */
      /* Code-generation and build script used to generate C-language code and create the compiled version  */
      /* (ROIMSIR_Interpolate_mex) of the function. */
      /* { */
      /*                  */
      /*  */
      /* %%%%% Specify variable-size input arguments %%%%%% */
      /*  */
      /* See Matlab documentation for coder.typeof. */
      /*                                                      Example Code                 Upp. Bounds  Var. Size (T/F)  Type */
      /* ROINoPrevCallsBlockCode               = coder.typeof( zeros(500, 4, 'int16'),      [inf, 4],    [1, 0] );        %int16 */
      /* BlockFullLinIdxCode                   = coder.typeof( zeros(1, 500, 'int32'),      [1, inf],    [0, 1] );        %int32 */
      /* ROIBlockDetectionFaceSkinLogIdxCode   = coder.typeof( false(500, 1),               [inf, 1],    [1, 0] );        %logical */
      /* TimestampBlockCode                    = coder.typeof( zeros(500, 1, 'single'),     [inf, 1],    [1, 0] );        %single   */
      /* TimestampBlockDetectionsCode          = coder.typeof( zeros(500, 1, 'single'),     [inf, 1],    [1, 0] );        %single  */
      /* ROICode                               = coder.typeof( zeros(500, 4, 'int16'),      [inf, 4],    [1, 0] );        %int16  */
      /* VideoReadConfig_FrameIdxCode          = coder.typeof( zeros(1, 500, 'uint32'),     [1, inf],    [0, 1] );        %uint32  */
      /*                   */
      /*  */
      /* %%%%% Specify fixed-size input arguments %%%%%% */
      /*  */
      /* ROIGeneralConfig_MatchSmoothInterpolateResize_DiffMaxCode = int16(0); */
      /* ROIGeneralConfig_ROIWidthResizeFactorCode                 = double(0); */
      /* ROIGeneralConfig_ROIHeightResizeFactorCode                = double(0); */
      /* VidObjWidthCode                                           = int16(0);          */
      /* VidObjHeightCode                                          = int16(0); */
      /* FirstReadTFCode                                           = false; */
      /* RowToReturnFullLinIdxCode                                 = uint32(0); */
      /* RowToReturnBlockLinIdxCode                                = uint32(0); */
      /* FirstFrameMSIRLinIdxCode                                  = uint32(0); */
      /*  */
      /*  */
      /* %%%%% Set configurations to increase performance %%%%%% */
      /*  */
      /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
      /* "Optimization Strategies" */
      /* cfg = coder.config('mex'); */
      /* cfg.GlobalDataSyncMethod = 'NoSync'; */
      /* cfg.ConstantInputs = 'IgnoreValues'; */
      /* cfg.ExtrinsicCalls = false; */
      /* cfg.SaturateOnIntegerOverflow = false; */
      /* cfg.IntegrityChecks = false; */
      /* cfg.ResponsivenessChecks = false; */
      /*  */
      /*  */
      /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
      /*  */
      /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
      /*  */
      /* The flags are specified as part of the code-generation configuration object. A custom function, */
      /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
      /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
      /* Matlab guidance found in */
      /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
      /*  */
      /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
      /* a character vector prior to execution of the codegen command. */
      /*  */
      /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
      /*  */
      /* Argument buildInfo: this variable is assign by the caller (the codegen command executed  */
      /* below) and is not present in the base workspace. */
      /*  */
      /* Second argument: specify a cell array of compiler-specific flags, where each flag is a  */
      /* character vector. As function setbuildargs will be evaluated from text, use double ' quotes for  */
      /* each character vector to maintain the charater vector, */
      /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
      /*  */
      /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
      /*  */
      /* Assign to code-generation configuration object */
      /* cfg.PostCodeGenCommand = setbuildargsAsText; */
      /*  */
      /*  */
      /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
      /*  */
      /* codegen ROIMSIR_Interpolate.m -config cfg -args {ROINoPrevCallsBlockCode, BlockFullLinIdxCode, ROIBlockDetectionFaceSkinLogIdxCode, TimestampBlockCode, TimestampBlockDetectionsCode, ROICode, ROIGeneralConfig_MatchSmoothInterpolateResize_DiffMaxCode, ROIGeneralConfig_ROIWidthResizeFactorCode, ROIGeneralConfig_ROIHeightResizeFactorCode, VidObjWidthCode, VidObjHeightCode, FirstReadTFCode, VideoReadConfig_FrameIdxCode, RowToReturnFullLinIdxCode, RowToReturnBlockLinIdxCode, FirstFrameMSIRLinIdxCode} */
      /*               */
      /* } */
      i = ROIOut_SR->size[0] * ROIOut_SR->size[1];
      ROIOut_SR->size[0] = ROINoPrevCallsBlock_SR->size[0];
      ROIOut_SR->size[1] = 4;
      emxEnsureCapacity_int16_T(ROIOut_SR, i);
      Sum = ROINoPrevCallsBlock_SR->size[0] * ROINoPrevCallsBlock_SR->size[1];
      for (i = 0; i < Sum; i++) {
        ROIOut_SR->data[i] = ROINoPrevCallsBlock_SR->data[i];
      }

      i = InterpolatedLinIdx_SR->size[0];
      InterpolatedLinIdx_SR->size[0] = VideoReadConfig_FrameIdx_Length;
      emxEnsureCapacity_int32_T(InterpolatedLinIdx_SR, i);
      for (i = 0; i < VideoReadConfig_FrameIdx_Length; i++) {
        InterpolatedLinIdx_SR->data[i] = c_ROIBlockDetectionSkinLinIdx_F[i];
      }
    }

    /*  %%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
    /* %% Frame-by-frame smoothing %%% */
    /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
    /* Smooth with nearby frames regardless of whether a face-detection or skin-detection algorithm */
    /* detection is present in a given nearby frame. That is, include nearby frames even if they have */
    /* been interpolated or extrapolated rather than contain an ROI from a detection. This criteria  */
    /* differs from the detection-smoothing conducted previously. */
    /* The objective is to increase stability in position (X- and Y-coordinates) and size (width and  */
    /* height) across frames. The stability should better reflect actual head movements rather than */
    /* sudden movements caused by extraneous factors, such as differences in ROIs due to the use of */
    /* different algorithms or artifacts introduced by the previous smoothing and interpolation  */
    /* operations. At the same time, over-smoothing should be avoided to allow the ROI to be responsive  */
    /* to actual head movements across frames. */
    /* Also return ROIs ROIOutBeforeFrameByFrameSmoothing(_FR/_SR) not modified by frame-by-frame  */
    /* smoothing or resizing. The two operations that occured prior to these, size matching and detection  */
    /* smoothing, are present. This permits diagnosis of false positives or false negatives resulting  */
    /* from size matching and detection smoothing. The ROIs of these coordinates will be superimposed on  */
    /* the output video for assessment. Note: the final ROIs differ from these only as a result of  */
    /* receiving frame-by-frame smoothing and resizing. Hence, the final ROIs can be inspected to  */
    /* diagnose false positives or false negatives resulting from frame-by-frame smoothing and resizing. */
    /* Note: in the first-read condition, tildes (~) indicate output arguments only used in second-read  */
    /* operations; in the second-read condition, tildes indicate output arguments only used in first-read  */
    /* operations. */
    /* Note: ROIMSIR_FrameByFrameSmooth is a custom function located within folder 'FacePulseRate'. */
    /* For first-read operations  */
    if (FirstReadTF) {
      /*  1 x 4 row vector; type int16 */
      /*  1 x 4 row vector; type int16 */
      /* ROIMSIR_FrameByFrameSmooth    Conduct frame-by-frame smoothing of ROIs. */
      /*  */
      /*     Helper function to function FacePulseRate.  */
      /*     Within function FacePulseRate, called by function ROIMSIR. */
      /*  */
      /*  */
      /*     Code Generation */
      /*     --------------- */
      /*  */
      /*     Can be called as a Matlab function or used for C-language code generation. */
      /*  */
      /*  */
      /*     Description */
      /*     ----------- */
      /*   */
      /*     Smooth with nearby frames regardless of whether a face-detection or skin-detection algorithm */
      /*     detection is present in a given nearby frame. That is, include nearby frames even if they have */
      /*     been interpolated or extrapolated rather than contain an ROI from a detection. The objective  */
      /*     is to increase stability in position (X- and Y-coordinates) and size (width and height) */
      /*     across frames. The stability should better reflect actual head movements rather than sudden */
      /*     movements caused by extraneous factors, such as differences in ROIs due to the use of */
      /*     different algorithms or artifacts introduced by the previous smoothing and interpolation  */
      /*     operations. At the same time, over-smoothing should be avoided to allow the ROI to be  */
      /*     responsive to actual head movements across frames. */
      /*  */
      /*     At the point of the current frame, the final ROI values are known only for previous frames  */
      /*     (ROI values before the current frame in ROIBlock). To conduct frame-by-frame smoothing as if   */
      /*     both previous and later ROI values were known, later ROI values are interpolated /  */
      /*     extrapolated for the purpose of frame-by-frame smoothing. Any ROIs values interpolated /   */
      /*     extrapolated for this purpose are not recorded. */
      /*  */
      /*  */
      /*     Copyright */
      /*     --------- */
      /*  */
      /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), September, 2020. Licensed under the MIT License    */
      /*     and the Responsible AI License (RAIL).  */
      /* %%%%% Code-generation settings %%%%%% */
      /* Inline function */
      /* Call function as extrinsic */
      /* See notes where warning() used. */
      /* Call function as extrinsic so that stack trace can be displayed */
      /* Declare variable-size variables: */
      /* Note: constant 229 assumes that the length of BlockFullLinIdx == 229. If the length of this  */
      /* variable were to change, the constant would need to be modified. */
      /*                                                          Upp. Bounds  Var. Size (T/F) */
      /* %%%%% Input validation %%%%%% */
      /* Note: constant 229 assumes that the length of BlockFullLinIdx == 229. If the length of this  */
      /* variable were to change, the constant would need to be modified. If changed to be longer, the   */
      /* bounds on variables FrameByFrameSmoothingWin_XYLinIdx and FrameByFrameSmoothingWin_WHLinIdx should  */
      /* be increased. A low value is currently used to avoid dynamic memory allocation in several  */
      /* variables. The value was determined based upon the maximum length of the frame cache (see function  */
      /* ROIMeans_FirstRead_TakeMeans). An error from these assert statements would likely be due to an */
      /* implementation error because input checking is conducted at the beginning of function */
      /* FacePulseRate. */
      /* %%%%% Specify smoothing windows %%%%%% */
      /* Specify X- and Y-coordinate smoothing window */
      /* Type int32. */
      /* Specify width and height smoothing window */
      /* Type int32. */
      /* Smoothing windows for use in first-read operation: */
      /* Assign half value of smoothing widths for use in some operations */
      /* This is only for convenience; the actual smoothing widths remain the same. */
      /* Type int32. */
      n = (int32_T)muDoubleScalarRound((real_T)(c_ROIGeneralConfig_ROIFinalSmoo
        [0] - 1) / 2.0);
      FrameByFrameSmoothingWin_WHHalf = (int32_T)muDoubleScalarRound((real_T)
        (c_ROIGeneralConfig_ROIFinalSmoo[1] - 1) / 2.0);

      /* %%%%% Assign variables %%%%%% */
      /* First-read operations */
      /* Record ROIs not smoothed by the frame-by-frame smoothing to diagnose false positives or false   */
      /* negatives that may have been caused by this smoothing operation. The ROI coordinates will be  */
      /* superimposed on the output video for assessment. */
      /* Type int16. */
      /* 1 x 4 row vector; type int16. */
      c_ROIOutBeforeFrameByFrameSmoot[0] = ROIOut_FR[0];
      c_ROIOutBeforeFrameByFrameSmoot[1] = ROIOut_FR[1];
      c_ROIOutBeforeFrameByFrameSmoot[2] = ROIOut_FR[2];
      c_ROIOutBeforeFrameByFrameSmoot[3] = ROIOut_FR[3];

      /* Variables unused in first-read operations assigned for code generation purposes: */
      /* Assert row size as zero because this variable not used in first-read operations */
      /* This may help remove dynamic memory allocation for this variable. */
      /* If no ROIs within the block correspond to a detection: */
      /* Otherwise, the ROI will have been assigned as the full frame dimensions (see function */
      /* ROIMSIR_InterpolateFR), and these should not be smoothed.    */
      if (NDetectionsFaceSkin_FR != 0) {
        /* Assign previous-to-current-frame block index: */
        /* Type int32. */
        /* Note: constant 115 assumes that RowToReturnBlockLinIdx_FR == 115. If the value of this */
        /* variable were to change, the constant would need to be modified. */
        /* The length of NPrevToCurrentBlockLinIdx. */
        /* Note: constant 115 assumes that RowToReturnBlockLinIdx_FR == 115. If the value of this */
        /* variable were to change, the constant would need to be modified. */
        /* Type int32. */
        /* Second-read operations */
        /* %%%%% First-read operations %%%%%%    */
        /* Note: the following variables are only used in the first-read operations */
        /* RowToReturnFullLinIdx  = Linear index of row to return aligned with length of all frames.     */
        /* RowToReturnBlockLinIdx = Linear index of row to return aligned with length of block.    */
        /* FirstFrameMSIRLinIdx   = Linear index of ROI processed on first call of functon; aligned with */
        /*                          length of all frames.           */
        /* To avoid ROIs with zeros entering smoothing operations, interpolation / extrapolation may */
        /* be required. Linear interpolation / extrapolation requires at least two detections. */
        if (NDetectionsFaceSkin_FR > 1) {
          /* Note: if a constant-size block is not used (see function ROIMSIR_Optimize), the following */
          /* checks also need to be conducted: */
          /* RowToReturnBlockLinIdx_FR > FrameByFrameSmoothingWin_XYHalf    && ... sufficient frames left side */
          /* RowToReturnBlockLinIdx_FR > FrameByFrameSmoothingWin_WHHalf    && ... */
          /* RowToReturnBlockLinIdx_FR + FrameByFrameSmoothingWin_XYHalf <= length(BlockFullLinIdx) && ... sufficient frames right side */
          /* RowToReturnBlockLinIdx_FR + FrameByFrameSmoothingWin_WHHalf <= length(BlockFullLinIdx)         */
          /* %%%%% --- Determine frames before first call to function that do no have a detection %%%%%% */
          /* Check whether block contains ROIs of frames for which the current function was not */
          /* previously called. To do so, determine whether any frames in the current block come before */
          /* the index specified by FirstFrameMSIRLinIdx; this index specifies the first frame that was */
          /* called by the function. */
          /* Of these ROIs, if an ROI does not have a detection, it will be zero as the current  */
          /* function did not previously apply interpolation / extrapolation to it. These ROIs will be */
          /* interpolated / extrapolated in function ROIMSIR_FrameByFrameSmooth_Interp. */
          /* Determine whether any frames in block were not processed by previous calls to the function */
          FaceOrSkinTF = (BlockFullLinIdx_FR[0] < ROIMSIR_FirstFrameLinIdx_FR);

          /* Convert linear index of first frame called to align with length of block rather than full  */
          /* frame index. */
          /* Type int32. */
          NDetectionsSkin_SR = (ROIMSIR_FirstFrameLinIdx_FR -
                                BlockFullLinIdx_FR[0]) + 1;

          /* %%%%% --- Preallocate ROI matrix for frame-by-frame smooth %%%%%% */
          /* Preallocate */
          /* 229 x 4 matrix; type int16. */
          /* Note: constant 229 assumes that the length of BlockFullLinIdx == 229. If the length of  */
          /* this variable were to change, the constant would need to be modified. */
          /* %%%%% --- Interpolate / extrapolate frames with zeros %%%%%% */
          /* Frame-by-frame smoothing attempts to smooth across all ROIs. An ROI from any previous   */
          /* frame can be included because all previous frames will have a non-zero ROI. Specifically,  */
          /* previous frames without a detection would have received an interpolated/exterpolated ROI        */
          /* from a previous call to function ROIMSIR_FrameByFrameSmooth. Frames that occur after the   */
          /* current frame that do not have a detection will contain zeros as interpolation /   */
          /* extrapolation has not yet been performed on them. To remedy this, perform interpolation /   */
          /* extrapolation for the frames after the current frame that will be included in the  */
          /* smoothing. Any ROIs interpolated / extrapolated here will only be used for the purpose of  */
          /* frame-by-frame smoothing in function ROIMSIR_FrameByFrameSmooth_SmoothFR and will not be  */
          /* assigned to a persistent ROI matrix. */
          /* 229 x 4 matrix; type int16.         */
          /* Note: ROIMSIR_FrameByFrameSmooth_Interp is a custom function located within folder  */
          /* 'FacePulseRate'. */
          /* ROIMSIR_FrameByFrameSmooth_InterpFR    Interpolate frames with unassigned ROIs for frame-by-frame */
          /*                                        smoothing operations during the first-read operations.  */
          /*  */
          /*     Helper function to function FacePulseRate.  */
          /*     Within function FacePulseRate, called by function ROIMSIR_FrameByFrameSmooth. */
          /*  */
          /*  */
          /*     Code Generation */
          /*     --------------- */
          /*  */
          /*     Can be called as a Matlab function or used for C-language code generation.                                                                          */
          /*  */
          /*  */
          /*     Description */
          /*     ----------- */
          /*   */
          /*     Frame-by-frame smoothing attempts to smooth across all ROIs. An ROI from any previous frame  */
          /*     can be included because all previous frames will have a non-zero ROI. Specifically, previous  */
          /*     frames without a detection would have received an interpolated/exterpolated ROI from a       */
          /*     previous call to function ROIMSIR_FrameByFrameSmooth. Frames that occur after the current  */
          /*     frame that do not have a detection will contain zeros as interpolation / extrapolation has not  */
          /*     yet been performed on them. To remedy this, perform interpolation / extrapolation for the  */
          /*     frames after the current frame that will be included in the smoothing. Any ROIs interpolated / */
          /*     extrapolated here will only be used for the purpose of frame-by-frame smoothing in function */
          /*     ROIMSIR_FrameByFrameSmooth_SmoothFR and will not be assigned to a persistent ROI matrix. */
          /*  */
          /*     Interpolate / extrapolate X-coordinate, Y-coordinate, width, and height of the ROIs. */
          /*     Some frames may not contain enough nearby frames for accurate interpolation or extrapolation, */
          /*     so use a method more conservative than PCHIP: the linear method.  */
          /*  */
          /*  */
          /*     Copyright */
          /*     --------- */
          /*  */
          /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
          /*     the Responsible AI License (RAIL).  */
          /* %%%%% Code-generation settings %%%%%% */
          /* Inline function */
          /* Declare variables and extrinsic functions: */
          /* Note: constant 229 assumes that the length of BlockFullLinIdx == 229. If the length of this  */
          /* variable were to change, the constant would need to be modified. */
          /*                                                          Upp. Bounds  Var. Size (T/F) */
          /* Declare function as extrinsic */
          /* See notes where warning() used. */
          /* Call function as extrinsic so that stack trace can be displayed */
          /* %%%%% Setup for interpolation / extrapolation %%%%%% */
          /* Preallocate variables: */
          /* Note: regarding "coder.nullcopy", see Matlab documentation topic "Eliminate Redundant Copies of  */
          /* Variables in Generated Code". */
          Start = 0;

          /* %%%%% --- Determine frames before first call to function that do no have a detection %%%%%% */
          /* Check whether block contains ROIs of frames for which the current function was not previously */
          /* called. To do so, determine whether any frames in the current block come before the index */
          /* specified by FirstFrameMSIRLinIdx_FR; this index specifies the first frame that was called by the */
          /* function. */
          /* Of these ROIs, if an ROI does not have a detection, it will be zero as the current function did  */
          /* not previously apply interpolation / extrapolation to it. For these ROIs, determine which do not */
          /* have a detection so that interpolation / extrapolation can be applied to them.  */
          /* Determine which of these frames do not have a detection */
          if (FaceOrSkinTF && (NNoDetectionsFaceSkin_FR != 0)) {
            /* Linear index of frames before first call that do not have a detection  */
            /* Column vector; type int32. */
            VideoReadConfig_FrameIdx_Length = c_ROIBlockNoDetectionFaceSkinLi -
              1;
            Start = 0;
            winNew = 0;
            for (b_i = 0; b_i <= VideoReadConfig_FrameIdx_Length; b_i++) {
              u = e_ROIBlockNoDetectionFaceSkinLi[b_i];
              if (u < NDetectionsSkin_SR) {
                Start++;
                ROIBlockDetectionSkinLinIdx[winNew] = u;
                winNew++;
              }
            }
          }

          /* %%%%% --- Determine frames after current frame that do no have a detection %%%%%% */
          /* These ROIs are zeros because the function has not yet been called for these ROIs, so they could  */
          /* not have been interpolated / extrapolated yet.         */
          /* Linear index of ROIs after current frame that do not have a detection */
          /* Note: SetDiff is a custom function located within folder 'FacePulseRate'. */
          /* SetDiff   Return the elements of set A that are different from set B, assuming elements within    */
          /*           each set do not repeat and monotonically increase. */
          /*  */
          /*     Helper function to function FacePulseRate.  */
          /*     Within function FacePulseRate, called by functions ROIMSIR_FrameByFrameSmooth_InterpFR and */
          /*     ROIMSIR_FrameByFrameSmooth_SmoothFR. */
          /*  */
          /*     Code generation:  */
          /*  */
          /*     Can be called as a Matlab function or used for C-language code generation. */
          /*  */
          /*     Description: */
          /*  */
          /*     Optimized algorithm for returning the elements of set A that are different from set B.  */
          /*     Optimized by assuming that, within each set, elements do not repeat and monotonically  */
          /*     increase. */
          /* Inline function */
          /* Preallocate output */
          /* Index of A of elements that are different from B */
          /* The elements of A corresponding to this index will be returned as output Set. */
          winNew = 0;

          /* Index of B where last match made with A */
          Idx = 0;

          /* Loop across elements of A */
          for (b_i = 0; b_i < NNoDetectionsFaceSkin_FR; b_i++) {
            /* Reset match flag */
            MatchTF = false;

            /* On first iteration of each while-loop, start after the element of B where the last match was */
            /* made. This increases efficiency by skipping elements of B where a match was already made. This  */
            /* is only possible when the values within each input are sorted and unique. */
            j = Idx;

            /* Loop across elements of B */
            /* Note: once all elements of B have been iterated across, all remaining elements of A are  */
            /* considered different than B. This is only possible when all values of A are unique. */
            exitg1 = false;
            while ((!exitg1) && (j < 115)) {
              j++;

              /* If B(j) matches A(i) */
              if (e_ROIBlockNoDetectionFaceSkinLi[b_i] == (int8_T)((int8_T)(j -
                    1) + 1)) {
                MatchTF = true;
                Idx = j;

                /* With assumption that only unique values within each set, the remaining elements in B */
                /* can be skipped for this element of A. */
                exitg1 = true;
              }
            }

            /* Assign A(i) if no match with B */
            if (!MatchTF) {
              winNew++;

              /* Assign value of A(i) */
              c_ROIBlockDetectionFaceLinIdx_F[winNew - 1] =
                e_ROIBlockNoDetectionFaceSkinLi[b_i];
            }
          }

          /* Trim preallocated rows that were not assigned */
          if (1 > winNew) {
            Sum = 0;
          } else {
            Sum = winNew;
          }

          /* end function */
          /* %%%%% Interpolation / extrapolation %%%%%% */
          /* If any ROIs need to be interpolated / extrapolated */
          if ((Start != 0) || (Sum != 0)) {
            /* %%%%% --- Interpolation / extrapolation %%%%%% */
            /* Frames to be interpolated / extrapolated */
            /* Note: the concatenated variable should have values in order from least to greatest. */
            Idx = Start + Sum;
            if (0 <= Start - 1) {
              memcpy(&InterpTheseLinIdx_data[0], &ROIBlockDetectionSkinLinIdx[0],
                     Start * sizeof(uint8_T));
            }

            for (i = 0; i < Sum; i++) {
              InterpTheseLinIdx_data[i + Start] =
                c_ROIBlockDetectionFaceLinIdx_F[i];
            }

            for (i = 0; i < Start; i++) {
              c_ROIBlockDetectionSkinLinIdx_F[i] = ROIBlockDetectionSkinLinIdx[i];
            }

            for (i = 0; i < Sum; i++) {
              c_ROIBlockDetectionSkinLinIdx_F[i + Start] =
                c_ROIBlockDetectionFaceLinIdx_F[i];
            }

            /* Timestamps within block corresponding to frames to be interpolated / extrapolated  */
            /* Column vector; type single. */
            /* NoPrevCallsBlock_ROIDetections = ROIs in block corresponding to frames with a detection. ROIs  */
            /*                                  are taken from ROINoPrevCallsBlock rather than ROIBlock. This */
            /*                                  prevents a positive feedback loop from developing across  */
            /*                                  sequential calls to the function (see note in the file for  */
            /*                                  function ROIMSIR).  */
            /*                                  M x 4 matrix; type int16. */
            /* Verify that ROIs to be included in interpolation / extrapolation do not contain zeros (that  */
            /* is, the ROIs for interpolation, not receiving interpolation; ROIs receiving interpolation will */
            /* be zero). Interpolation / extrapolation is intended to be conducted only with non-zeros ROIs.     */
            /* Such a value is likely due to an implementation error in this function. */
            /* Loop across columns */
            for (b_i = 0; b_i < 4; b_i++) {
              /* Loop across rows */
              for (j = 0; j < NDetectionsFaceSkin_FR; j++) {
                if (e_NoPrevCallsBlock_ROIDetection[j +
                    d_NoPrevCallsBlock_ROIDetection * b_i] == 0) {
                  /* Throw exception */
                  /* Called as extrinsic so that stack trace can be displayed. */
                  b_sprintf(VideoReadConfig_FrameIdx_FR->
                            data[RowToReturnFullLinIdx_FR - 1], r1);
                  i = varargin_2->size[0] * varargin_2->size[1];
                  varargin_2->size[0] = 1;
                  varargin_2->size[1] = r1->size[1] + 225;
                  emxEnsureCapacity_char_T(varargin_2, i);
                  for (i = 0; i < 68; i++) {
                    varargin_2->data[i] = cv44[i];
                  }

                  for (i = 0; i < 39; i++) {
                    varargin_2->data[i + 68] = cv46[i];
                  }

                  Sum = r1->size[1];
                  for (i = 0; i < Sum; i++) {
                    varargin_2->data[i + 107] = r1->data[i];
                  }

                  for (i = 0; i < 71; i++) {
                    varargin_2->data[(i + r1->size[1]) + 107] = cv49[i];
                  }

                  for (i = 0; i < 47; i++) {
                    varargin_2->data[(i + r1->size[1]) + 178] = cv51[i];
                  }

                  error(emlrt_marshallOut(cv3), b_emlrt_marshallOut(varargin_2),
                        &t_emlrtMCI);
                }
              }
            }

            /* Check whether the ROI size is unreasonably small */
            /* Such a small size is likely due to an implementation error in this function. */
            /* This check is intended to be run when testing new implementations, as small ROI sizes are an */
            /* indication of a implementation error. As occassional values below 20 may be considered */
            /* acceptable, this check is not intended for use outside of testing. "Occassional" in this case    */
            /* might be defined as a few occurances out of 10,000. Flag ExpectedBehaviorTestTF enables the */
            /* check.     */
            if (ExpectedBehaviorTestTF) {
              i = x->size[0] * x->size[1];
              x->size[0] = d_NoPrevCallsBlock_ROIDetection;
              x->size[1] = 2;
              emxEnsureCapacity_boolean_T(x, i);
              for (i = 0; i < d_NoPrevCallsBlock_ROIDetection; i++) {
                x->data[i] = (e_NoPrevCallsBlock_ROIDetection[i +
                              d_NoPrevCallsBlock_ROIDetection * 2] < 20);
              }

              for (i = 0; i < d_NoPrevCallsBlock_ROIDetection; i++) {
                x->data[i + x->size[0]] = (e_NoPrevCallsBlock_ROIDetection[i +
                  d_NoPrevCallsBlock_ROIDetection * 3] < 20);
              }

              winNew = x->size[0] << 1;
              c_x = *x;
              g_VideoReadConfig_FrameIdx_FR[0] = winNew;
              c_x.size = &g_VideoReadConfig_FrameIdx_FR[0];
              c_x.numDimensions = 1;
              if (any(&c_x)) {
                /* Display warning indicating frame index */
                /* Note: function warning() not available for code generation, so it must have previously */
                /* been declared as extrinsic. */
                /* Function fprintf can not be used as a substitute for warning() in this case because  */
                /* fprintf can not accept variable-length arguments.        */
                b_sprintf(VideoReadConfig_FrameIdx_FR->
                          data[RowToReturnFullLinIdx_FR - 1], r1);
                i = varargin_2->size[0] * varargin_2->size[1];
                varargin_2->size[0] = 1;
                varargin_2->size[1] = r1->size[1] + 306;
                emxEnsureCapacity_char_T(varargin_2, i);
                for (i = 0; i < 79; i++) {
                  varargin_2->data[i] = cv56[i];
                }

                for (i = 0; i < 72; i++) {
                  varargin_2->data[i + 79] = cv57[i];
                }

                for (i = 0; i < 74; i++) {
                  varargin_2->data[i + 151] = cv17[i];
                }

                Sum = r1->size[1];
                for (i = 0; i < Sum; i++) {
                  varargin_2->data[i + 225] = r1->data[i];
                }

                for (i = 0; i < 46; i++) {
                  varargin_2->data[(i + r1->size[1]) + 225] = cv18[i];
                }

                for (i = 0; i < 35; i++) {
                  varargin_2->data[(i + r1->size[1]) + 271] = cv58[i];
                }

                warning(emlrt_marshallOut(cv3), b_emlrt_marshallOut(varargin_2),
                        &u_emlrtMCI);
              }
            }

            /* Enable validity checks of interpolated / extrapolated ROI(s) */
            /* Note: see the description in function ROIMSIR_Interpolate. */
            /* Enable the use of the linear method for extrapolation. */
            /* Note: see the description in function ROIMSIR_Interpolate.     */
            /* 229 x 4 matrix; type int16 */
            /* Note: for a description of the arguments to function Interp, see the description in  */
            /* function ROIMSIR_Interpolate. */
            /* Note: Interp is a custom function located within folder 'FacePulseRate'. */
            /*  Interp/extrap ROIs */
            /*  Time points used for interp/extrap; M x */
            /*  1 column vctor, type single. */
            /*  ROIs used for interp/extrap; M x 4 */
            /*  matrix, type int16. */
            /*  Time points at which interp/extrap to be */
            /*  assigned; M x 1 column vector, type */
            /*  single. */
            /*  Flag whether to use linear method for */
            /*  extrapolation. */
            /*  Flag whether to check if interpolated / */
            /*  extrapolated values seem reasonable. */
            /*  The threshold specifying the maximum */
            /*  absolute-value difference between an */
            /*  interpolated / extrapolated value and */
            /*  the ROI corresponding to the */
            /*  temporally-nearest previous detection. */
            /*  Empty = do not conduct adjacent ROI */
            /*  check. */
            /*  Unused argument for adjacent-ROI check. */
            /* Interp   Conduct linear interpolation/extrapolation or nearest-neighbor extrapolation. */
            /*  */
            /*     Helper function to function FacePulseRate.  */
            /*     Within function FacePulseRate, called by functions ROIMeans_FirstRead_ExtrapolateROI,  */
            /*     ROIMSIR_Interpolate and ROIMSIR_FrameByFrameSmooth_InterpFR. */
            /*      */
            /*  */
            /*     Code Generation */
            /*     --------------- */
            /*  */
            /*     Can be called as a Matlab function or used for C-language code generation. */
            /*  */
            /*  */
            /*     Description */
            /*     ----------- */
            /*  */
            /*     When LinearExtrapTF == true, conduct linear interpolation or extrapolation.  */
            /*     When LinearExtrapTF == false, conduct linear interpolation only when xi falls within domain of  */
            /*     x. Otherwise, conduct nearest-neighbor extrapolation. */
            /*  */
            /*     When ValidityChecksTF == true, conduct checks and adjustments on values returned by linear */
            /*     interpolation / extrapolation. These checks and adjustments include ...   */
            /*  */
            /*     - Checking whether the difference between an interpolated value and a nearby actual value is */
            /*       within a specified threshold (DiffMaxActual). If not, this may be an indication of an   */
            /*       overshoot; in this case, the interpolated value is changed to the maximum value specified by  */
            /*       the threshold. This check and adjustment are only applied to an interpolated value  */
            /*       corresponding to the X- or Y-coordinate (rather than height or width) of the ROI. The check  */
            /*       is not applied to height or width as testing has indicated that an overshoot  is not as   */
            /*       common for height or width. */
            /*  */
            /*     - Checking whether an interpolated value corresponding to ROI height or width is above 20. If */
            /*       not, the interpolated value is recalculated by conducting nearest-neighbor extrapolation. A */
            /*       height or width below 20 is considered to be too small for the size of faces expected in a */
            /*       video. */
            /*  */
            /*     - Checking whether an interpolated value is within the frame dimensions (minimum of 1 and */
            /*       maximums of VidObjWidth and VidObjHeight). If not, the interpolated value is changed to be */
            /*       bounded by the frame dimensions. */
            /*  */
            /*     When YArbitrary is non-empty, conduct checks and adjustments on interpolated / extrapolated */
            /*     values. These checks and adjustments include ...   */
            /*  */
            /*     - Checking whether the difference between an interpolated value and a nearby arbitrary value  */
            /*       is within a specified threshold (DiffMaxArbitrary). If not, this may be an indication of an   */
            /*       overshoot; in this case, the interpolated value is changed to the maximum value specified by  */
            /*       the threshold. This check and adjustment are only applied to an interpolated value  */
            /*       corresponding to the X- or Y-coordinate (rather than height or width) of the ROI. The check  */
            /*       is not applied to height or width as testing has indicated that an overshoot is not as   */
            /*       common for height or width. */
            /*  */
            /*     Restrictions: */
            /*  */
            /*     - x is are assumed to increase monotonically and contain unique values. x must contain at */
            /*       least two elements. The number of elements must equal the number of elements of y.                         */
            /*     - xi is assumed to increase monotonically.  */
            /*     - y is assumed to have 4 columns. y must contain at least two elements. The number of elements  */
            /*       must equal the number of elements of x.  */
            /*  */
            /*     This function uses bounded variable sizes to improve efficiency. Ensure that inputs do not */
            /*     exceed the bounds. */
            /*  */
            /*     Inputs: */
            /*  */
            /*     x                = Time values that correspond to values of y. M x 1 column vector; type  */
            /*                        single. */
            /*     y                = Values from which to interpolate. M x :4 matrix; type int16.                    */
            /*     xi               = Time values at which interpolation will occur. The elements do not need to   */
            /*                        be unique. The number of values is not restricted. Column vector; type  */
            /*                        single.                                         */
            /*     LinearExtrapTF   = If true, use the linear method for extrapolation. If false, use the  */
            /*                        nearest-neighbor method. Scalar; type logical. */
            /*     ValidityChecksTF = If true, check whether the interpolated values appears valid. Scalar;  */
            /*                        type logical. */
            /*     DiffMaxActual    = The threshold specifying the maximum absolute-value difference between an  */
            /*                        interpolated / extrapolated value and a previous actual value. Scalar; type  */
            /*                        int16. Threshold only applied when InterpChecksTF == true;      */
            /*     DiffMaxArbitrary = The threshold specifying the maximum absolute-value difference between an  */
            /*                        interpolated / extrapolated value and an arbitrary X- or Y-coordinate   */
            /*                        value, which is specified by YArbitrary. Scalar; type int16.                      */
            /*     YArbitrary       = Arbitary X- and Y-coordinate values used with the threshold specified by  */
            /*                        DiffMaxArbitrary. To disable DiffMaxArbitrary checks, use 0 x 2 input.                         */
            /*                        0 x 2 or 1 x 2 row vector; type int16.                                                                                     */
            /*     VidObjWidth      = The frame width. Scalar; type int16. */
            /*     VidObjHeight     = The frame height. Scalar; type int16. */
            /*  */
            /*  */
            /*     Copyright */
            /*     --------- */
            /*  */
            /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
            /*     the Responsible AI License (RAIL). */
            /* Inline function */
            /* Whether to conduct arbitrary value check */
            /* Length of input time points */
            /* Length of input interpolation timepoints */
            /* This length will equal the length of yi. */
            /* Assert length to prevent dynamic memory allocation by colon operator */
            /* Preallocate output */
            /* Initialize x_idx at 1  */
            /* x_idx is used to search for the value of x that is greater than xi. */
            /* In while loop, the first operation is to increment j by 1; hence, the effective use of x_idx */
            /* starts at 2. */
            /* By initializing x_idx here, rather than after each iteration of i, it is assumed that both x and   */
            /* xi are sorted in order from least to greatest. This assumption improves performance because values  */
            /* of x already matched are not researched (a qualification is that the implementation does research   */
            /* the immediately previous value of x -- see note within loop). If x or xi is not sorted, the    */
            /* initialization of x_idx (setting x_idx to 1) should occur after each iteration of i. */
            Start = 0;

            /* Loop across interpolation times points */
            for (Sum = 0; Sum < Idx; Sum++) {
              /* The ith xi value (the ith interpolation point) */
              xi_ith_tmp = TimestampBlock_FR[c_ROIBlockDetectionSkinLinIdx_F[Sum]
                - 1];

              /* Find the indices of x: x_before_idx and x_after_idx:       */
              /* If ith xi value is to left of domain of x */
              /* Case of extrapolation. */
              if (TimestampBlock_FR[InterpTheseLinIdx_data[Sum] - 1] <
                  c_TimestampBlockDetections_FR_d[0]) {
                /* If linear extrapolation permitted */
                /* Assign first and second indices of x */
                /* Linear extrapolation */
                /* Local function. */
                /* 1 x nColsY row vector; type int16. */
                /* end local function */
                /* ============================================================================================= */
                /* ExtrapLinear   Linear extrapolation of y at a single time point (xi). */
                /*  */
                /*     Note: */
                /*  */
                /*     Same as function InterpLinear except that an integer overflow check is also conducted. */
                /* Inline function */
                /* Preallocate output for ith yi values */
                /* Assign x values    */
                /* Scalars; type single. */
                /* Proportion of interpolated time interval to actual time interval */
                /* Scalar; type single. */
                b_r = (xi_ith_tmp - c_TimestampBlockDetections_FR_d[0]) /
                  (c_TimestampBlockDetections_FR_d[1] -
                   c_TimestampBlockDetections_FR_d[0]);

                /* Loop across columns of y */
                /* y value that comes before time point to be interpolated */
                /* Scalar; type int16. */
                /* y value that comes after time point to be interpolated */
                /* Scalar; type int16. */
                /* %%%%% Skip extrapolation %%%%%% */
                /* If y values same, assign one of them as extrapolated value */
                if (e_NoPrevCallsBlock_ROIDetection[0] ==
                    e_NoPrevCallsBlock_ROIDetection[1]) {
                  yi_ith[0] = e_NoPrevCallsBlock_ROIDetection[0];

                  /* %%%%% Extrapolate %%%%%%          */
                } else {
                  /* Step 1 */
                  /* Extrapolated distance of y. */
                  /* Multipy interpolated time-interval proportion by actual change in y. */
                  /* Cast to floating-point type to multiply.  */
                  /* Scalar; type single. */
                  /* Step 2 */
                  /* Add distance to most immediate previous actual y value. */
                  /* As extrapolation could result in extreme value for y, conduct operation so that it can be */
                  /* determined whether type int16 could overflow; specifically, cast to type int32 to prepare */
                  /* for later check. */
                  /* Scalar; type int32. */
                  winNew = e_NoPrevCallsBlock_ROIDetection[0] + (int32_T)
                    muSingleScalarRound((real32_T)(int16_T)
                                        (e_NoPrevCallsBlock_ROIDetection[1] -
                    e_NoPrevCallsBlock_ROIDetection[0]) * b_r);

                  /* Check if extrapolated value will cause int16 type to overflow */
                  /* If so, assign maximum or minimum value. */
                  /* If positive value  */
                  if (winNew > 0) {
                    /* If exceeds maximum value of type             */
                    if (winNew >= 32767) {
                      winNew = 32767;
                    }

                    /* If negative value */
                  } else {
                    /* If exceeds minimum value of type */
                    if (winNew <= -32767) {
                      winNew = -32767;
                    }
                  }

                  /* Cast back to type int16 */
                  yi_ith[0] = (int16_T)winNew;

                  /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                  /* Local function. */
                  /* Scalar; type int16. */
                  /* end local function */
                  /* ============================================================================================= */
                  /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                  /* Inline function */
                  /* Switch according to column */
                  /* x-coordinate column */
                  /* Local function. */
                  /* end local function */
                  /* ============================================================================================= */
                  /* ValidityCheck_XY   Validity check for X- or Y-coordinate. */
                  /*  */
                  /*     Description: */
                  /*  */
                  /*     Check whether difference between before-value and interpolated / extrapolated value is greater   */
                  /*     than specified threshold. If so, set value at maximum of threshold.  */
                  /* Inline function */
                  Width_ith = (int16_T)(winNew -
                                        e_NoPrevCallsBlock_ROIDetection[0]);
                  if (Width_ith > c_ROIGeneralConfig_ROIMSIR_Diff) {
                    yi_ith[0] = (int16_T)(e_NoPrevCallsBlock_ROIDetection[0] +
                                          c_ROIGeneralConfig_ROIMSIR_Diff);
                  } else {
                    if (Width_ith < (int16_T)-c_ROIGeneralConfig_ROIMSIR_Diff) {
                      yi_ith[0] = (int16_T)(e_NoPrevCallsBlock_ROIDetection[0] -
                                            c_ROIGeneralConfig_ROIMSIR_Diff);
                    }
                  }
                }

                /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                /* If arbitary check enabled */
                /* %%%%% Assign %%%%%% */
                /* Scalar; type int16. */
                /* y value that comes before time point to be interpolated */
                /* Scalar; type int16. */
                Height_ith =
                  e_NoPrevCallsBlock_ROIDetection[d_NoPrevCallsBlock_ROIDetection];

                /* y value that comes after time point to be interpolated */
                /* Scalar; type int16. */
                Width_ith =
                  e_NoPrevCallsBlock_ROIDetection[d_NoPrevCallsBlock_ROIDetection
                  + 1];

                /* %%%%% Skip extrapolation %%%%%% */
                /* If y values same, assign one of them as extrapolated value */
                if (Height_ith == Width_ith) {
                  yi_ith[1] = Height_ith;

                  /* %%%%% Extrapolate %%%%%%          */
                } else {
                  /* Step 1 */
                  /* Extrapolated distance of y. */
                  /* Multipy interpolated time-interval proportion by actual change in y. */
                  /* Cast to floating-point type to multiply.  */
                  /* Scalar; type single. */
                  /* Step 2 */
                  /* Add distance to most immediate previous actual y value. */
                  /* As extrapolation could result in extreme value for y, conduct operation so that it can be */
                  /* determined whether type int16 could overflow; specifically, cast to type int32 to prepare */
                  /* for later check. */
                  /* Scalar; type int32. */
                  winNew = Height_ith + (int32_T)muSingleScalarRound((real32_T)
                    (int16_T)(Width_ith - Height_ith) * b_r);

                  /* Check if extrapolated value will cause int16 type to overflow */
                  /* If so, assign maximum or minimum value. */
                  /* If positive value  */
                  if (winNew > 0) {
                    /* If exceeds maximum value of type             */
                    if (winNew >= 32767) {
                      winNew = 32767;
                    }

                    /* If negative value */
                  } else {
                    /* If exceeds minimum value of type */
                    if (winNew <= -32767) {
                      winNew = -32767;
                    }
                  }

                  /* Cast back to type int16 */
                  yi_ith[1] = (int16_T)winNew;

                  /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                  /* Local function. */
                  /* Scalar; type int16. */
                  /* end local function */
                  /* ============================================================================================= */
                  /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                  /* Inline function */
                  /* Switch according to column */
                  /* y-coordinate column */
                  /* Local function. */
                  /* end local function */
                  /* ============================================================================================= */
                  /* ValidityCheck_XY   Validity check for X- or Y-coordinate. */
                  /*  */
                  /*     Description: */
                  /*  */
                  /*     Check whether difference between before-value and interpolated / extrapolated value is greater   */
                  /*     than specified threshold. If so, set value at maximum of threshold.  */
                  /* Inline function */
                  Width_ith = (int16_T)(winNew - Height_ith);
                  if (Width_ith > c_ROIGeneralConfig_ROIMSIR_Diff) {
                    yi_ith[1] = (int16_T)(Height_ith +
                                          c_ROIGeneralConfig_ROIMSIR_Diff);
                  } else {
                    if (Width_ith < (int16_T)-c_ROIGeneralConfig_ROIMSIR_Diff) {
                      yi_ith[1] = (int16_T)(Height_ith -
                                            c_ROIGeneralConfig_ROIMSIR_Diff);
                    }
                  }
                }

                /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                /* If arbitary check enabled */
                /* %%%%% Assign %%%%%% */
                /* Scalar; type int16. */
                /* y value that comes before time point to be interpolated */
                /* Scalar; type int16. */
                Height_ith =
                  e_NoPrevCallsBlock_ROIDetection[d_NoPrevCallsBlock_ROIDetection
                  * 2];

                /* y value that comes after time point to be interpolated */
                /* Scalar; type int16. */
                Width_ith =
                  e_NoPrevCallsBlock_ROIDetection[d_NoPrevCallsBlock_ROIDetection
                  * 2 + 1];

                /* %%%%% Skip extrapolation %%%%%% */
                /* If y values same, assign one of them as extrapolated value */
                if (Height_ith == Width_ith) {
                  yi_ith[2] = Height_ith;

                  /* %%%%% Extrapolate %%%%%%          */
                } else {
                  /* Step 1 */
                  /* Extrapolated distance of y. */
                  /* Multipy interpolated time-interval proportion by actual change in y. */
                  /* Cast to floating-point type to multiply.  */
                  /* Scalar; type single. */
                  /* Step 2 */
                  /* Add distance to most immediate previous actual y value. */
                  /* As extrapolation could result in extreme value for y, conduct operation so that it can be */
                  /* determined whether type int16 could overflow; specifically, cast to type int32 to prepare */
                  /* for later check. */
                  /* Scalar; type int32. */
                  winNew = Height_ith + (int32_T)muSingleScalarRound((real32_T)
                    (int16_T)(Width_ith - Height_ith) * b_r);

                  /* Check if extrapolated value will cause int16 type to overflow */
                  /* If so, assign maximum or minimum value. */
                  /* If positive value  */
                  if (winNew > 0) {
                    /* If exceeds maximum value of type             */
                    if (winNew >= 32767) {
                      winNew = 32767;
                    }

                    /* If negative value */
                  } else {
                    /* If exceeds minimum value of type */
                    if (winNew <= -32767) {
                      winNew = -32767;
                    }
                  }

                  /* Cast back to type int16 */
                  yi_ith[2] = (int16_T)winNew;

                  /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                  /* Local function. */
                  /* Scalar; type int16. */
                  /* end local function */
                  /* ============================================================================================= */
                  /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                  /* Inline function */
                  /* Switch according to column */
                  /* width column */
                  /* Local function. */
                  /* end local function */
                  /* ============================================================================================= */
                  /* ValidityCheck_WH   Validity check for width or height. */
                  /*  */
                  /*     Description: */
                  /*  */
                  /*     Check whether width or height value is less than 20. If so, then substitute the  */
                  /*     nearest-neighbor method in place of the linear method. */
                  /* Inline function */
                  if (winNew < 20) {
                    /* Determine whether x_after or x_before nearest and assign. */
                    /* x_after nearest */
                    if (muSingleScalarAbs(c_TimestampBlockDetections_FR_d[1] -
                                          xi_ith_tmp) <= muSingleScalarAbs
                        (c_TimestampBlockDetections_FR_d[0] - xi_ith_tmp)) {
                      yi_ith[2] = Width_ith;

                      /* x_before nearest */
                    } else {
                      yi_ith[2] = Height_ith;
                    }
                  }
                }

                /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                /* If arbitary check enabled */
                /* %%%%% Assign %%%%%% */
                /* Scalar; type int16. */
                /* y value that comes before time point to be interpolated */
                /* Scalar; type int16. */
                Height_ith =
                  e_NoPrevCallsBlock_ROIDetection[d_NoPrevCallsBlock_ROIDetection
                  * 3];

                /* y value that comes after time point to be interpolated */
                /* Scalar; type int16. */
                Width_ith =
                  e_NoPrevCallsBlock_ROIDetection[d_NoPrevCallsBlock_ROIDetection
                  * 3 + 1];

                /* %%%%% Skip extrapolation %%%%%% */
                /* If y values same, assign one of them as extrapolated value */
                if (Height_ith == Width_ith) {
                  yi_ith[3] = Height_ith;

                  /* %%%%% Extrapolate %%%%%%          */
                } else {
                  /* Step 1 */
                  /* Extrapolated distance of y. */
                  /* Multipy interpolated time-interval proportion by actual change in y. */
                  /* Cast to floating-point type to multiply.  */
                  /* Scalar; type single. */
                  /* Step 2 */
                  /* Add distance to most immediate previous actual y value. */
                  /* As extrapolation could result in extreme value for y, conduct operation so that it can be */
                  /* determined whether type int16 could overflow; specifically, cast to type int32 to prepare */
                  /* for later check. */
                  /* Scalar; type int32. */
                  winNew = Height_ith + (int32_T)muSingleScalarRound((real32_T)
                    (int16_T)(Width_ith - Height_ith) * b_r);

                  /* Check if extrapolated value will cause int16 type to overflow */
                  /* If so, assign maximum or minimum value. */
                  /* If positive value  */
                  if (winNew > 0) {
                    /* If exceeds maximum value of type             */
                    if (winNew >= 32767) {
                      winNew = 32767;
                    }

                    /* If negative value */
                  } else {
                    /* If exceeds minimum value of type */
                    if (winNew <= -32767) {
                      winNew = -32767;
                    }
                  }

                  /* Cast back to type int16 */
                  yi_ith[3] = (int16_T)winNew;

                  /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                  /* Local function. */
                  /* Scalar; type int16. */
                  /* end local function */
                  /* ============================================================================================= */
                  /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                  /* Inline function */
                  /* Switch according to column */
                  /* height column */
                  /* Local function. */
                  /* end local function */
                  /* ============================================================================================= */
                  /* ValidityCheck_WH   Validity check for width or height. */
                  /*  */
                  /*     Description: */
                  /*  */
                  /*     Check whether width or height value is less than 20. If so, then substitute the  */
                  /*     nearest-neighbor method in place of the linear method. */
                  /* Inline function */
                  if (winNew < 20) {
                    /* Determine whether x_after or x_before nearest and assign. */
                    /* x_after nearest */
                    if (muSingleScalarAbs(c_TimestampBlockDetections_FR_d[1] -
                                          xi_ith_tmp) <= muSingleScalarAbs
                        (c_TimestampBlockDetections_FR_d[0] - xi_ith_tmp)) {
                      yi_ith[3] = Width_ith;

                      /* x_before nearest */
                    } else {
                      yi_ith[3] = Height_ith;
                    }
                  }
                }

                /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                /* If arbitary check enabled */
                /* %%%%% Assign %%%%%% */
                /* Scalar; type int16. */
                /* If ith xi value is either within domain of x or to right of domain of x       */
              } else {
                /* If xi is within the domain of x, ... */
                /*  - x_before_idx is the index of x where x is less than xi. */
                /*  - x_after_idx is the index of x where x is greater than or equal to xi. */
                /* If xi is to right of the domain of x, ... */
                /*  - both x_before_idx and x_after_idx index x where x is less than xi.  */
                /*  - x at x_before_idx is less than x at x_after_idx. */
                do {
                  exitg2 = 0;
                  Start++;

                  /* If ith xi value is to right of domain of x */
                  /* Case of extrapolation. */
                  if (Start + 1 >= c_TimestampBlockDetections_FR_s) {
                    /* If linear extrapolation permitted */
                    /* Assign x indices */
                    /* Linear extrapolation */
                    /* Local function. */
                    /* 1 x nColsY row vector; type int16. */
                    /* end local function */
                    /* ============================================================================================= */
                    /* ExtrapLinear   Linear extrapolation of y at a single time point (xi). */
                    /*  */
                    /*     Note: */
                    /*  */
                    /*     Same as function InterpLinear except that an integer overflow check is also conducted. */
                    /* Inline function */
                    /* Preallocate output for ith yi values */
                    /* Assign x values    */
                    /* Scalars; type single. */
                    HeightRatio_Single =
                      c_TimestampBlockDetections_FR_d[c_TimestampBlockDetections_FR_s
                      - 2];
                    WidthRatio_Single =
                      c_TimestampBlockDetections_FR_d[c_TimestampBlockDetections_FR_s
                      - 1];

                    /* Proportion of interpolated time interval to actual time interval */
                    /* Scalar; type single. */
                    b_r = (xi_ith_tmp -
                           c_TimestampBlockDetections_FR_d[c_TimestampBlockDetections_FR_s
                           - 2]) / (WidthRatio_Single -
                                    c_TimestampBlockDetections_FR_d[c_TimestampBlockDetections_FR_s
                                    - 2]);

                    /* Loop across columns of y */
                    /* y value that comes before time point to be interpolated */
                    /* Scalar; type int16. */
                    Height_ith =
                      e_NoPrevCallsBlock_ROIDetection[c_TimestampBlockDetections_FR_s
                      - 2];

                    /* y value that comes after time point to be interpolated */
                    /* Scalar; type int16. */
                    Width_ith =
                      e_NoPrevCallsBlock_ROIDetection[c_TimestampBlockDetections_FR_s
                      - 1];

                    /* %%%%% Skip extrapolation %%%%%% */
                    /* If y values same, assign one of them as extrapolated value */
                    if (Height_ith == Width_ith) {
                      yi_ith[0] = Height_ith;

                      /* %%%%% Extrapolate %%%%%%          */
                    } else {
                      /* Step 1 */
                      /* Extrapolated distance of y. */
                      /* Multipy interpolated time-interval proportion by actual change in y. */
                      /* Cast to floating-point type to multiply.  */
                      /* Scalar; type single. */
                      /* Step 2 */
                      /* Add distance to most immediate previous actual y value. */
                      /* As extrapolation could result in extreme value for y, conduct operation so that it can be */
                      /* determined whether type int16 could overflow; specifically, cast to type int32 to prepare */
                      /* for later check. */
                      /* Scalar; type int32. */
                      winNew = Height_ith + (int32_T)muSingleScalarRound
                        ((real32_T)(int16_T)(Width_ith - Height_ith) * b_r);

                      /* Check if extrapolated value will cause int16 type to overflow */
                      /* If so, assign maximum or minimum value. */
                      /* If positive value  */
                      if (winNew > 0) {
                        /* If exceeds maximum value of type             */
                        if (winNew >= 32767) {
                          winNew = 32767;
                        }

                        /* If negative value */
                      } else {
                        /* If exceeds minimum value of type */
                        if (winNew <= -32767) {
                          winNew = -32767;
                        }
                      }

                      /* Cast back to type int16 */
                      yi_ith[0] = (int16_T)winNew;

                      /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                      /* Local function. */
                      /* Scalar; type int16. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                      /* Inline function */
                      /* Switch according to column */
                      /* x-coordinate column */
                      /* Local function. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck_XY   Validity check for X- or Y-coordinate. */
                      /*  */
                      /*     Description: */
                      /*  */
                      /*     Check whether difference between before-value and interpolated / extrapolated value is greater   */
                      /*     than specified threshold. If so, set value at maximum of threshold.  */
                      /* Inline function */
                      Width_ith = (int16_T)(winNew - Height_ith);
                      if (Width_ith > c_ROIGeneralConfig_ROIMSIR_Diff) {
                        yi_ith[0] = (int16_T)(Height_ith +
                                              c_ROIGeneralConfig_ROIMSIR_Diff);
                      } else {
                        if (Width_ith < (int16_T)
                            -c_ROIGeneralConfig_ROIMSIR_Diff) {
                          yi_ith[0] = (int16_T)(Height_ith -
                                                c_ROIGeneralConfig_ROIMSIR_Diff);
                        }
                      }
                    }

                    /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                    /* If arbitary check enabled */
                    /* %%%%% Assign %%%%%% */
                    /* Scalar; type int16. */
                    /* y value that comes before time point to be interpolated */
                    /* Scalar; type int16. */
                    VideoReadConfig_FrameIdx_Length =
                      (c_TimestampBlockDetections_FR_s +
                       d_NoPrevCallsBlock_ROIDetection) - 2;
                    Height_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length];

                    /* y value that comes after time point to be interpolated */
                    /* Scalar; type int16. */
                    Width_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length
                      + 1];

                    /* %%%%% Skip extrapolation %%%%%% */
                    /* If y values same, assign one of them as extrapolated value */
                    if (Height_ith == Width_ith) {
                      yi_ith[1] = Height_ith;

                      /* %%%%% Extrapolate %%%%%%          */
                    } else {
                      /* Step 1 */
                      /* Extrapolated distance of y. */
                      /* Multipy interpolated time-interval proportion by actual change in y. */
                      /* Cast to floating-point type to multiply.  */
                      /* Scalar; type single. */
                      /* Step 2 */
                      /* Add distance to most immediate previous actual y value. */
                      /* As extrapolation could result in extreme value for y, conduct operation so that it can be */
                      /* determined whether type int16 could overflow; specifically, cast to type int32 to prepare */
                      /* for later check. */
                      /* Scalar; type int32. */
                      winNew = Height_ith + (int32_T)muSingleScalarRound
                        ((real32_T)(int16_T)(Width_ith - Height_ith) * b_r);

                      /* Check if extrapolated value will cause int16 type to overflow */
                      /* If so, assign maximum or minimum value. */
                      /* If positive value  */
                      if (winNew > 0) {
                        /* If exceeds maximum value of type             */
                        if (winNew >= 32767) {
                          winNew = 32767;
                        }

                        /* If negative value */
                      } else {
                        /* If exceeds minimum value of type */
                        if (winNew <= -32767) {
                          winNew = -32767;
                        }
                      }

                      /* Cast back to type int16 */
                      yi_ith[1] = (int16_T)winNew;

                      /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                      /* Local function. */
                      /* Scalar; type int16. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                      /* Inline function */
                      /* Switch according to column */
                      /* y-coordinate column */
                      /* Local function. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck_XY   Validity check for X- or Y-coordinate. */
                      /*  */
                      /*     Description: */
                      /*  */
                      /*     Check whether difference between before-value and interpolated / extrapolated value is greater   */
                      /*     than specified threshold. If so, set value at maximum of threshold.  */
                      /* Inline function */
                      Width_ith = (int16_T)(winNew - Height_ith);
                      if (Width_ith > c_ROIGeneralConfig_ROIMSIR_Diff) {
                        yi_ith[1] = (int16_T)(Height_ith +
                                              c_ROIGeneralConfig_ROIMSIR_Diff);
                      } else {
                        if (Width_ith < (int16_T)
                            -c_ROIGeneralConfig_ROIMSIR_Diff) {
                          yi_ith[1] = (int16_T)(Height_ith -
                                                c_ROIGeneralConfig_ROIMSIR_Diff);
                        }
                      }
                    }

                    /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                    /* If arbitary check enabled */
                    /* %%%%% Assign %%%%%% */
                    /* Scalar; type int16. */
                    /* y value that comes before time point to be interpolated */
                    /* Scalar; type int16. */
                    VideoReadConfig_FrameIdx_Length =
                      (c_TimestampBlockDetections_FR_s +
                       d_NoPrevCallsBlock_ROIDetection * 2) - 2;
                    Height_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length];

                    /* y value that comes after time point to be interpolated */
                    /* Scalar; type int16. */
                    Width_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length
                      + 1];

                    /* %%%%% Skip extrapolation %%%%%% */
                    /* If y values same, assign one of them as extrapolated value */
                    if (Height_ith == Width_ith) {
                      yi_ith[2] = Height_ith;

                      /* %%%%% Extrapolate %%%%%%          */
                    } else {
                      /* Step 1 */
                      /* Extrapolated distance of y. */
                      /* Multipy interpolated time-interval proportion by actual change in y. */
                      /* Cast to floating-point type to multiply.  */
                      /* Scalar; type single. */
                      /* Step 2 */
                      /* Add distance to most immediate previous actual y value. */
                      /* As extrapolation could result in extreme value for y, conduct operation so that it can be */
                      /* determined whether type int16 could overflow; specifically, cast to type int32 to prepare */
                      /* for later check. */
                      /* Scalar; type int32. */
                      winNew = Height_ith + (int32_T)muSingleScalarRound
                        ((real32_T)(int16_T)(Width_ith - Height_ith) * b_r);

                      /* Check if extrapolated value will cause int16 type to overflow */
                      /* If so, assign maximum or minimum value. */
                      /* If positive value  */
                      if (winNew > 0) {
                        /* If exceeds maximum value of type             */
                        if (winNew >= 32767) {
                          winNew = 32767;
                        }

                        /* If negative value */
                      } else {
                        /* If exceeds minimum value of type */
                        if (winNew <= -32767) {
                          winNew = -32767;
                        }
                      }

                      /* Cast back to type int16 */
                      yi_ith[2] = (int16_T)winNew;

                      /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                      /* Local function. */
                      /* Scalar; type int16. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                      /* Inline function */
                      /* Switch according to column */
                      /* width column */
                      /* Local function. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck_WH   Validity check for width or height. */
                      /*  */
                      /*     Description: */
                      /*  */
                      /*     Check whether width or height value is less than 20. If so, then substitute the  */
                      /*     nearest-neighbor method in place of the linear method. */
                      /* Inline function */
                      if (winNew < 20) {
                        /* Determine whether x_after or x_before nearest and assign. */
                        /* x_after nearest */
                        if (muSingleScalarAbs(WidthRatio_Single - xi_ith_tmp) <=
                            muSingleScalarAbs(HeightRatio_Single - xi_ith_tmp))
                        {
                          yi_ith[2] = Width_ith;

                          /* x_before nearest */
                        } else {
                          yi_ith[2] = Height_ith;
                        }
                      }
                    }

                    /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                    /* If arbitary check enabled */
                    /* %%%%% Assign %%%%%% */
                    /* Scalar; type int16. */
                    /* y value that comes before time point to be interpolated */
                    /* Scalar; type int16. */
                    VideoReadConfig_FrameIdx_Length =
                      (c_TimestampBlockDetections_FR_s +
                       d_NoPrevCallsBlock_ROIDetection * 3) - 2;
                    Height_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length];

                    /* y value that comes after time point to be interpolated */
                    /* Scalar; type int16. */
                    Width_ith =
                      e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length
                      + 1];

                    /* %%%%% Skip extrapolation %%%%%% */
                    /* If y values same, assign one of them as extrapolated value */
                    if (Height_ith == Width_ith) {
                      yi_ith[3] = Height_ith;

                      /* %%%%% Extrapolate %%%%%%          */
                    } else {
                      /* Step 1 */
                      /* Extrapolated distance of y. */
                      /* Multipy interpolated time-interval proportion by actual change in y. */
                      /* Cast to floating-point type to multiply.  */
                      /* Scalar; type single. */
                      /* Step 2 */
                      /* Add distance to most immediate previous actual y value. */
                      /* As extrapolation could result in extreme value for y, conduct operation so that it can be */
                      /* determined whether type int16 could overflow; specifically, cast to type int32 to prepare */
                      /* for later check. */
                      /* Scalar; type int32. */
                      winNew = Height_ith + (int32_T)muSingleScalarRound
                        ((real32_T)(int16_T)(Width_ith - Height_ith) * b_r);

                      /* Check if extrapolated value will cause int16 type to overflow */
                      /* If so, assign maximum or minimum value. */
                      /* If positive value  */
                      if (winNew > 0) {
                        /* If exceeds maximum value of type             */
                        if (winNew >= 32767) {
                          winNew = 32767;
                        }

                        /* If negative value */
                      } else {
                        /* If exceeds minimum value of type */
                        if (winNew <= -32767) {
                          winNew = -32767;
                        }
                      }

                      /* Cast back to type int16 */
                      yi_ith[3] = (int16_T)winNew;

                      /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                      /* Local function. */
                      /* Scalar; type int16. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                      /* Inline function */
                      /* Switch according to column */
                      /* height column */
                      /* Local function. */
                      /* end local function */
                      /* ============================================================================================= */
                      /* ValidityCheck_WH   Validity check for width or height. */
                      /*  */
                      /*     Description: */
                      /*  */
                      /*     Check whether width or height value is less than 20. If so, then substitute the  */
                      /*     nearest-neighbor method in place of the linear method. */
                      /* Inline function */
                      if (winNew < 20) {
                        /* Determine whether x_after or x_before nearest and assign. */
                        /* x_after nearest */
                        if (muSingleScalarAbs(WidthRatio_Single - xi_ith_tmp) <=
                            muSingleScalarAbs(HeightRatio_Single - xi_ith_tmp))
                        {
                          yi_ith[3] = Width_ith;

                          /* x_before nearest */
                        } else {
                          yi_ith[3] = Height_ith;
                        }
                      }
                    }

                    /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                    /* If arbitary check enabled */
                    /* %%%%% Assign %%%%%% */
                    /* Scalar; type int16. */
                    /* Set back x_idx by one for use for i+1th xi element. */
                    /* xi is assumed to be sorted, but the values are not assumed to be unique, so x_idx */
                    /* should start back by one in case the next value of xi is the same as the current. */
                    /* Even is all values are unique, floating-point imprecision could effectively cause */
                    /* some to be non-unique. */
                    Start--;
                    exitg2 = 1;
                  } else {
                    if (c_TimestampBlockDetections_FR_d[Start] >= xi_ith_tmp) {
                      /* Assign x indices */
                      /* Linear interpolation */
                      /* Local function. */
                      /* 1 x nColsY row vector; type int16.                 */
                      /* end main function */
                      /* ============================================================================================= */
                      /* Local functions */
                      /* ============================================================================================= */
                      /* ============================================================================================= */
                      /* InterpLinear   Linear interpolation of y at a single time point (xi). */
                      /* Inline function */
                      /* Preallocate output for ith yi values */
                      /* Assign x values   */
                      /* Scalars; type single. */
                      WidthRatio_Single = c_TimestampBlockDetections_FR_d[Start
                        - 1];
                      x_after = c_TimestampBlockDetections_FR_d[Start];

                      /* Proportion of interpolated time interval to actual time interval */
                      /* Scalar; type single. */
                      b_r = (xi_ith_tmp - WidthRatio_Single) /
                        (c_TimestampBlockDetections_FR_d[Start] -
                         WidthRatio_Single);

                      /* Loop across columns of y */
                      /* y value that comes before time point to be interpolated */
                      /* Scalar; type int16. */
                      Height_ith = e_NoPrevCallsBlock_ROIDetection[Start - 1];

                      /* y value that comes after time point to be interpolated */
                      /* Scalar; type int16. */
                      Width_ith = e_NoPrevCallsBlock_ROIDetection[Start];

                      /* %%%%% Skip interpolation %%%%%% */
                      /* If y values same, assign one of them as interpolated value */
                      if (Height_ith == Width_ith) {
                        WidthNew_ith = Height_ith;

                        /* %%%%% Interpolate %%%%%%          */
                      } else {
                        /* Step 1 */
                        /* Interpolated distance of y. */
                        /* Multipy interpolated time-interval proportion by actual change in y. */
                        /* Cast to floating-point type to multiply.   */
                        /* Step 2 */
                        /* Add distance to most immediate previous actual y value. */
                        WidthNew_ith = (int16_T)(Height_ith + (int16_T)
                          muSingleScalarRound((real32_T)(int16_T)(Width_ith -
                          Height_ith) * b_r));

                        /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                        /* Local function. */
                        /* Scalar; type int16. */
                        /* end local function */
                        /* ============================================================================================= */
                        /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                        /* Inline function */
                        /* Switch according to column */
                        /* x-coordinate column */
                        /* Local function. */
                        /* end local function */
                        /* ============================================================================================= */
                        /* ValidityCheck_XY   Validity check for X- or Y-coordinate. */
                        /*  */
                        /*     Description: */
                        /*  */
                        /*     Check whether difference between before-value and interpolated / extrapolated value is greater   */
                        /*     than specified threshold. If so, set value at maximum of threshold.  */
                        /* Inline function */
                        Width_ith = (int16_T)(WidthNew_ith - Height_ith);
                        if (Width_ith > c_ROIGeneralConfig_ROIMSIR_Diff) {
                          WidthNew_ith = (int16_T)(Height_ith +
                            c_ROIGeneralConfig_ROIMSIR_Diff);
                        } else {
                          if (Width_ith < (int16_T)
                              -c_ROIGeneralConfig_ROIMSIR_Diff) {
                            WidthNew_ith = (int16_T)(Height_ith -
                              c_ROIGeneralConfig_ROIMSIR_Diff);
                          }
                        }
                      }

                      /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                      /* If arbitary check enabled    */
                      /* %%%%% Assign %%%%%% */
                      yi_ith[0] = WidthNew_ith;

                      /* y value that comes before time point to be interpolated */
                      /* Scalar; type int16. */
                      VideoReadConfig_FrameIdx_Length = Start +
                        d_NoPrevCallsBlock_ROIDetection;
                      Height_ith =
                        e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length
                        - 1];

                      /* y value that comes after time point to be interpolated */
                      /* Scalar; type int16. */
                      Width_ith =
                        e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length];

                      /* %%%%% Skip interpolation %%%%%% */
                      /* If y values same, assign one of them as interpolated value */
                      if (Height_ith == Width_ith) {
                        WidthNew_ith = Height_ith;

                        /* %%%%% Interpolate %%%%%%          */
                      } else {
                        /* Step 1 */
                        /* Interpolated distance of y. */
                        /* Multipy interpolated time-interval proportion by actual change in y. */
                        /* Cast to floating-point type to multiply.   */
                        /* Step 2 */
                        /* Add distance to most immediate previous actual y value. */
                        WidthNew_ith = (int16_T)(Height_ith + (int16_T)
                          muSingleScalarRound((real32_T)(int16_T)(Width_ith -
                          Height_ith) * b_r));

                        /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                        /* Local function. */
                        /* Scalar; type int16. */
                        /* end local function */
                        /* ============================================================================================= */
                        /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                        /* Inline function */
                        /* Switch according to column */
                        /* y-coordinate column */
                        /* Local function. */
                        /* end local function */
                        /* ============================================================================================= */
                        /* ValidityCheck_XY   Validity check for X- or Y-coordinate. */
                        /*  */
                        /*     Description: */
                        /*  */
                        /*     Check whether difference between before-value and interpolated / extrapolated value is greater   */
                        /*     than specified threshold. If so, set value at maximum of threshold.  */
                        /* Inline function */
                        Width_ith = (int16_T)(WidthNew_ith - Height_ith);
                        if (Width_ith > c_ROIGeneralConfig_ROIMSIR_Diff) {
                          WidthNew_ith = (int16_T)(Height_ith +
                            c_ROIGeneralConfig_ROIMSIR_Diff);
                        } else {
                          if (Width_ith < (int16_T)
                              -c_ROIGeneralConfig_ROIMSIR_Diff) {
                            WidthNew_ith = (int16_T)(Height_ith -
                              c_ROIGeneralConfig_ROIMSIR_Diff);
                          }
                        }
                      }

                      /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                      /* If arbitary check enabled    */
                      /* %%%%% Assign %%%%%% */
                      yi_ith[1] = WidthNew_ith;

                      /* y value that comes before time point to be interpolated */
                      /* Scalar; type int16. */
                      VideoReadConfig_FrameIdx_Length = Start +
                        d_NoPrevCallsBlock_ROIDetection * 2;
                      Height_ith =
                        e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length
                        - 1];

                      /* y value that comes after time point to be interpolated */
                      /* Scalar; type int16. */
                      Width_ith =
                        e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length];

                      /* %%%%% Skip interpolation %%%%%% */
                      /* If y values same, assign one of them as interpolated value */
                      if (Height_ith == Width_ith) {
                        WidthNew_ith = Height_ith;

                        /* %%%%% Interpolate %%%%%%          */
                      } else {
                        /* Step 1 */
                        /* Interpolated distance of y. */
                        /* Multipy interpolated time-interval proportion by actual change in y. */
                        /* Cast to floating-point type to multiply.   */
                        /* Step 2 */
                        /* Add distance to most immediate previous actual y value. */
                        WidthNew_ith = (int16_T)(Height_ith + (int16_T)
                          muSingleScalarRound((real32_T)(int16_T)(Width_ith -
                          Height_ith) * b_r));

                        /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                        /* Local function. */
                        /* Scalar; type int16. */
                        /* end local function */
                        /* ============================================================================================= */
                        /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                        /* Inline function */
                        /* Switch according to column */
                        /* width column */
                        /* Local function. */
                        /* end local function */
                        /* ============================================================================================= */
                        /* ValidityCheck_WH   Validity check for width or height. */
                        /*  */
                        /*     Description: */
                        /*  */
                        /*     Check whether width or height value is less than 20. If so, then substitute the  */
                        /*     nearest-neighbor method in place of the linear method. */
                        /* Inline function */
                        if (WidthNew_ith < 20) {
                          /* Determine whether x_after or x_before nearest and assign. */
                          /* x_after nearest */
                          if (muSingleScalarAbs(x_after - xi_ith_tmp) <=
                              muSingleScalarAbs(WidthRatio_Single - xi_ith_tmp))
                          {
                            WidthNew_ith = Width_ith;

                            /* x_before nearest */
                          } else {
                            WidthNew_ith = Height_ith;
                          }
                        }
                      }

                      /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                      /* If arbitary check enabled    */
                      /* %%%%% Assign %%%%%% */
                      yi_ith[2] = WidthNew_ith;

                      /* y value that comes before time point to be interpolated */
                      /* Scalar; type int16. */
                      VideoReadConfig_FrameIdx_Length = Start +
                        d_NoPrevCallsBlock_ROIDetection * 3;
                      Height_ith =
                        e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length
                        - 1];

                      /* y value that comes after time point to be interpolated */
                      /* Scalar; type int16. */
                      Width_ith =
                        e_NoPrevCallsBlock_ROIDetection[VideoReadConfig_FrameIdx_Length];

                      /* %%%%% Skip interpolation %%%%%% */
                      /* If y values same, assign one of them as interpolated value */
                      if (Height_ith == Width_ith) {
                        WidthNew_ith = Height_ith;

                        /* %%%%% Interpolate %%%%%%          */
                      } else {
                        /* Step 1 */
                        /* Interpolated distance of y. */
                        /* Multipy interpolated time-interval proportion by actual change in y. */
                        /* Cast to floating-point type to multiply.   */
                        /* Step 2 */
                        /* Add distance to most immediate previous actual y value. */
                        WidthNew_ith = (int16_T)(Height_ith + (int16_T)
                          muSingleScalarRound((real32_T)(int16_T)(Width_ith -
                          Height_ith) * b_r));

                        /* %%%%% --- Check whether interpolated value appears valid %%%%%% */
                        /* Local function. */
                        /* Scalar; type int16. */
                        /* end local function */
                        /* ============================================================================================= */
                        /* ValidityCheck   Check whether interpolated / extrapolated value appears valid. */
                        /* Inline function */
                        /* Switch according to column */
                        /* height column */
                        /* Local function. */
                        /* end local function */
                        /* ============================================================================================= */
                        /* ValidityCheck_WH   Validity check for width or height. */
                        /*  */
                        /*     Description: */
                        /*  */
                        /*     Check whether width or height value is less than 20. If so, then substitute the  */
                        /*     nearest-neighbor method in place of the linear method. */
                        /* Inline function */
                        if (WidthNew_ith < 20) {
                          /* Determine whether x_after or x_before nearest and assign. */
                          /* x_after nearest */
                          if (muSingleScalarAbs(x_after - xi_ith_tmp) <=
                              muSingleScalarAbs(WidthRatio_Single - xi_ith_tmp))
                          {
                            WidthNew_ith = Width_ith;

                            /* x_before nearest */
                          } else {
                            WidthNew_ith = Height_ith;
                          }
                        }
                      }

                      /* %%%%% Check whether interpolated value within specified distance from arbitrary value %%%%%%  */
                      /* If arbitary check enabled    */
                      /* %%%%% Assign %%%%%% */
                      yi_ith[3] = WidthNew_ith;

                      /* Set back x_idx by one for use for i+1th xi element. */
                      /* xi is assumed to be sorted, but the values are not assumed to be unique, so x_idx */
                      /* should start back by one in case the next value of xi is the same as the current. */
                      /* Even is all values are unique, floating-point imprecision could effectively cause */
                      /* some to be non-unique. */
                      Start--;
                      exitg2 = 1;
                    }
                  }
                } while (exitg2 == 0);
              }

              /* Check whether interpolated values are within frame dimensions */
              /* If not, adjust to be within frame dimensions.         */
              /* Note: ROIAdjustIfExceedsFrameDims is a custom function located within folder */
              /* 'FacePulseRate'. */
              /* 1 x nColsY row vector; type int16. */
              /* ROIAdjustIfExceedsFrameDims   Verify whether proposed widths and heights of ROIs exceed frame  */
              /*                               dimensions and, if so, modify them to conform to frame dimensions. */
              /*                                */
              /*     Helper function to function FacePulseRate. */
              /*     Within function FacePulseRate, called by functions ROIResize, ROIMeans_FirstRead_Extrapolate, */
              /*     SkinDetect_EnlargeROI, ROIMSIR, ROIMSIR_MatchSize, ROIMSIR_DetectionSmooth,   */
              /*     ROIMSIR_Interpolate, and ROIMSIR_FrameByFrameSmooth.    */
              /*  */
              /*  */
              /*     Code Generation */
              /*     --------------- */
              /*  */
              /*     Can be called as a Matlab function or used for C-language code generation. */
              /*  */
              /*  */
              /*     Description */
              /*     ----------- */
              /*  */
              /*     This function verifies that ROIs that have had modifications to their sizes are still within */
              /*     the dimensions of the frame. If not, this function adjusts the dimensions (and, consequently,   */
              /*     the spatial coordinates) to conform to the frame dimensions. */
              /*  */
              /*     Note:  */
              /*  */
              /*     Intended only for use with integer types as rounding is not conducted. For modification for  */
              /*     use with floating-point types, rounding would be necessary as ROI values should be integers. */
              /*  */
              /*  */
              /*     Copyright */
              /*     --------- */
              /*  */
              /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
              /*     the Responsible AI License (RAIL). */
              /* %%%%% Validate inputs %%%%%% */
              /* Exit if empty */
              /* Validate whether input ROIsProposed is type int16. */
              /* Must be an integer type because no rounding is conducted. */
              /* Should be type int16 because the function is implemented to assign values of this type. */
              /* A non-matching type would be due to an implementation error. */
              /* %%%%% Running in code generation %%%%%% */
              /* When running in code generation, use for-loops. When running in Matlab code, use vectorization. */
              /* code generation running */
              /* Inline function */
              /* %%%%% --- Verify, and adjust if necessary, X-coordinates and widths %%%%%% */
              /* Adjust left-side X-coordinate if exceeds frame dimensions: */
              WidthNew_ith = (int16_T)(yi_ith[0] - 1);
              if (yi_ith[0] < 1) {
                WidthNew_ith = 0;

                /* recent code mod */
                yi_ith[0] = 1;
              } else {
                if (yi_ith[0] > VidObjWidth) {
                  WidthNew_ith = (int16_T)(VidObjWidth - 1);

                  /* recent code mod */
                  yi_ith[0] = VidObjWidth;
                }
              }

              /* Adjust right-side X-coordinate if exceeds frame dimensions: */
              Width_ith = (int16_T)(WidthNew_ith + yi_ith[2]);
              if (Width_ith > VidObjWidth) {
                Width_ith = VidObjWidth;
                yi_ith[2] = (int16_T)(VidObjWidth - WidthNew_ith);
              } else {
                if (Width_ith < 1) {
                  Width_ith = 1;
                  WidthNew_ith = 0;
                  yi_ith[0] = 1;
                  yi_ith[2] = 1;
                }
              }

              /* Adjust width if exceeds frame dimensions: */
              Width_ith -= WidthNew_ith;
              if (Width_ith > VidObjWidth) {
                yi_ith[2] = VidObjWidth;
              } else {
                if (Width_ith < 1) {
                  yi_ith[2] = 1;
                }
              }

              /* %%%%% --- Verify, and adjust if necessary, Y-coordinates and heights %%%%%% */
              /* Adjust top-side Y-coordinate if exceeds frame dimensions: */
              Height_ith = (int16_T)(yi_ith[1] - 1);
              if (yi_ith[1] < 1) {
                Height_ith = 0;

                /* recent code mod */
                yi_ith[1] = 1;
              } else {
                if (yi_ith[1] > VidObjHeight) {
                  Height_ith = (int16_T)(VidObjHeight - 1);

                  /* recent code mod */
                  yi_ith[1] = VidObjHeight;
                }
              }

              /* Adjust bottom-side Y-coordinate if exceeds frame dimensions: */
              Width_ith = (int16_T)(Height_ith + yi_ith[3]);
              if (Width_ith > VidObjHeight) {
                Width_ith = VidObjHeight;
                yi_ith[3] = (int16_T)(VidObjHeight - Height_ith);
              } else {
                if (Width_ith < 1) {
                  Width_ith = 1;
                  Height_ith = 0;
                  yi_ith[1] = 1;
                  yi_ith[3] = 1;
                }
              }

              /* Adjust height value if exceeds frame dimensions: */
              HeightNew_ith = (int16_T)(Width_ith - Height_ith);
              if (HeightNew_ith > VidObjHeight) {
                yi_ith[3] = VidObjHeight;
              } else {
                if (HeightNew_ith < 1) {
                  yi_ith[3] = 1;
                }
              }

              /* %%%%% Code generation not running %%%%%% */
              /* end function */
              /* ============================================================================================= */
              /* Code-generation and build script */
              /* ============================================================================================= */
              /* Code-generation and build script used to generate C-language code and create the compiled version  */
              /* (ROIAdjustIfExceedsFrameDims_mex) of the function. */
              /* { */
              /*  */
              /* %%%%% Specify variable-size input arguments %%%%%% */
              /*  */
              /* See Matlab documentation for coder.typeof. */
              /*  */
              /*                                   Example Code               Upp. Bounds   Var. Size (T/F)  Type */
              /* ROIsProposedCode   = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],     [1, 0] );        %int16 */
              /*            */
              /*        */
              /* %%%%% Specify fixed-size input arguments %%%%%% */
              /*  */
              /* VidObjWidthCode  = int16(0);          */
              /* VidObjHeightCode = int16(0); */
              /*                    */
              /*  */
              /* %%%%% Set configurations to increase performance %%%%%% */
              /*  */
              /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
              /* "Optimization Strategies" */
              /*  */
              /* cfg = coder.config('mex'); */
              /* cfg.GlobalDataSyncMethod = 'NoSync'; */
              /* cfg.ConstantInputs = 'IgnoreValues'; */
              /* cfg.ExtrinsicCalls = true; %permit to show assert error */
              /* cfg.SaturateOnIntegerOverflow = false; */
              /* cfg.IntegrityChecks = false; */
              /* cfg.ResponsivenessChecks = false; */
              /*  */
              /*  */
              /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
              /*  */
              /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
              /*  */
              /* The flags are specified as part of the code-generation configuration object. A custom function, */
              /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
              /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
              /* Matlab guidance found in */
              /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
              /*  */
              /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
              /* a character vector prior to execution of the codegen command. */
              /*  */
              /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
              /*  */
              /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
              /* is not present in the base workspace. */
              /*  */
              /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
              /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
              /* character vector to maintain the charater vector, */
              /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
              /*  */
              /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
              /*  */
              /* Assign to code-generation configuration object */
              /* cfg.PostCodeGenCommand = setbuildargsAsText; */
              /*  */
              /*  */
              /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
              /*  */
              /* codegen ROIAdjustIfExceedsFrameDims.m -report -config cfg -args {ROIsProposedCode, VidObjWidthCode, VidObjHeightCode} */
              /*                  */
              /* } */
              /* Assign interpolated / extrapolated values of yi at xi */
              ROIBlockFaceSkin_Temp_data[Sum] = yi_ith[0];
              ROIBlockFaceSkin_Temp_data[Sum + Idx] = yi_ith[1];
              ROIBlockFaceSkin_Temp_data[Sum + Idx * 2] = yi_ith[2];
              ROIBlockFaceSkin_Temp_data[Sum + Idx * 3] = yi_ith[3];
            }

            for (i = 0; i < Idx; i++) {
              e_NoPrevCallsBlock_ROIDetection[c_ROIBlockDetectionSkinLinIdx_F[i]
                - 1] = ROIBlockFaceSkin_Temp_data[i];
            }

            for (i = 0; i < Idx; i++) {
              e_NoPrevCallsBlock_ROIDetection[c_ROIBlockDetectionSkinLinIdx_F[i]
                + 228] = ROIBlockFaceSkin_Temp_data[i + Idx];
            }

            for (i = 0; i < Idx; i++) {
              e_NoPrevCallsBlock_ROIDetection[c_ROIBlockDetectionSkinLinIdx_F[i]
                + 457] = ROIBlockFaceSkin_Temp_data[i + Idx * 2];
            }

            for (i = 0; i < Idx; i++) {
              e_NoPrevCallsBlock_ROIDetection[c_ROIBlockDetectionSkinLinIdx_F[i]
                + 686] = ROIBlockFaceSkin_Temp_data[i + Idx * 3];
            }

            /* %%%%% --- X- and Y-coordinates adjacent ROI check and adjustment %%%%%%     */
            /* *** Testing in progress *** */
            /* Note: a suitable implementation has not yet been identified. */
            /*     %{ */
            /*      */
            /*     %Recall that the purpose of interpolating these ROIs is to predict what ROIs function */
            /*     %ROIMSIR_Interpolate will return in later calls. As ROIMSIR_Interpolate will conduct adjacent  */
            /*     %ROI checks and adjustments, they are conducted here to increase the prediction accuracy.  */
            /*      */
            /*     %If the linear index of interpolated ROIs includes 1         */
            /*     if InterpTheseLinIdx(1) == 1 */
            /*  */
            /*         %Exclude 1 from the loop as the first ROI cannot be compared to a previous ROI */
            /*         Start = int32(2); */
            /*  */
            /*     else */
            /*  */
            /*         Start = int32(1); */
            /*     end */
            /*  */
            /*     Interp_Length = int32( length(InterpTheseLinIdx) ); */
            /*      */
            /*     %Assert value to prevent dymanic memory allocation when the colon operator is used */
            /*     assert(Interp_Length <= 229); */
            /*  */
            /*     ROIBlockFrameByFrameSmoothAdjust = zeros(Interp_Length, 2, 'int16'); */
            /*      */
            /*     %Loop across X-coordinate and Y-coordinate columns */
            /*     for i = 1 : 2  */
            /*  */
            /*         %Loop across ROI rows corresponding to frames that were interpolated / extrapolated */
            /*         for j = Start : Interp_Length  */
            /*  */
            /*             jj = InterpTheseLinIdx(j);   */
            /*  */
            /*             %Find difference between jjth and jj-1th rows */
            /*             %Type int16. */
            /*             Diff = ROIBlockFrameByFrameSmooth(jj, i) - ROIBlockFrameByFrameSmooth(jj - 1, i); */
            /*  */
            /*             %If difference greater than threshold */
            /*             if Diff > ROIGeneralConfig_ROIMSIR_DiffMaxAdjacent    */
            /*                  */
            /*                 %Replace with jj-1th plus threshold */
            /*                 ROIBlockFrameByFrameSmoothAdjust(j, i) = ... */
            /*                     ROIBlockFrameByFrameSmooth(jj - 1, i) + ... */
            /*                     ROIGeneralConfig_ROIMSIR_DiffMaxAdjacent;         */
            /*  */
            /*             %If difference less than negative of threshold */
            /*             elseif Diff < -ROIGeneralConfig_ROIMSIR_DiffMaxAdjacent */
            /*  */
            /*                 %Replace with jj-1th minus threshold */
            /*                 ROIBlockFrameByFrameSmoothAdjust(j, i) = ... */
            /*                     ROIBlockFrameByFrameSmooth(jj - 1, i) - ... */
            /*                     ROIGeneralConfig_ROIMSIR_DiffMaxAdjacent;             */
            /*             end                                  */
            /*         end */
            /*     end   */
            /*      */
            /*     for i = 1 : 2 */
            /*  */
            /*         for j = Start : Interp_Length */
            /*  */
            /*             jj = InterpTheseLinIdx(j); */
            /*  */
            /*             ji = ROIBlockFrameByFrameSmoothAdjust(j, i); */
            /*              */
            /*             if ji ~= 0 */
            /*                  */
            /*                 ROIBlockFrameByFrameSmooth(jj, i) = ji; */
            /*             end */
            /*         end */
            /*     end    */
            /*      */
            /*     %} */
            /* *** End testing *** */
          }

          /* end function */
          /* %%%%% --- Frame-by-frame smoothing of ROI values %%%%%%    */
          /* 1 x 4 row vector; type int16. */
          /* Note: ROIMSIR_FrameByFrameSmooth_SmoothFR is a custom function located within folder  */
          /* 'FacePulseRate'. */
          /* ROIMSIR_FrameByFrameSmooth_SmoothFR    Frame-by-frame smoothing of ROIs for first-read operations. */
          /*  */
          /*     Helper function to function FacePulseRate.  */
          /*     Within function FacePulseRate, called by function ROIMSIR_FrameByFrameSmooth. */
          /*  */
          /*  */
          /*     Code Generation */
          /*     --------------- */
          /*  */
          /*     Can be called as a Matlab function or used for C-language code generation.                                                                          */
          /*  */
          /*     */
          /*     Copyright */
          /*     --------- */
          /*  */
          /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), September, 2020. Licensed under the MIT License    */
          /*     and the Responsible AI License (RAIL). */
          /* %%%%% Code-generation settings %%%%%% */
          /* Inline function */
          /* Call function as extrinsic */
          /* See notes where warning() used. */
          /* Call function as extrinsic so that stack trace can be displayed */
          /* Declare variables: */
          /* Note: constant 229 assumes that the length of BlockFullLinIdx == 229. If the length of this  */
          /* variable were to change, the constant would need to be modified. */
          /*                                                   Upp. Bounds  Var. Size (T/F) */
          /* %%%%% Input validation %%%%%% */
          /* Confirm that RowToReturnBlockLinIdx_FR == 115 */
          /* Only in the case of an implementation error would this not be the case. */
          if (RowToReturnBlockLinIdx_FR + 2 != 115) {
            /* Throw error */
            /* Called as extrinsic so that stack trace can be displayed. */
            b_sprintf(VideoReadConfig_FrameIdx_FR->data[RowToReturnFullLinIdx_FR
                      - 1], r1);
            i = varargin_2->size[0] * varargin_2->size[1];
            varargin_2->size[0] = 1;
            varargin_2->size[1] = r1->size[1] + 246;
            emxEnsureCapacity_char_T(varargin_2, i);
            for (i = 0; i < 82; i++) {
              varargin_2->data[i] = cv47[i];
            }

            for (i = 0; i < 45; i++) {
              varargin_2->data[i + 82] = cv48[i];
            }

            Sum = r1->size[1];
            for (i = 0; i < Sum; i++) {
              varargin_2->data[i + 127] = r1->data[i];
            }

            for (i = 0; i < 82; i++) {
              varargin_2->data[(i + r1->size[1]) + 127] = cv52[i];
            }

            for (i = 0; i < 37; i++) {
              varargin_2->data[(i + r1->size[1]) + 209] = cv53[i];
            }

            error(emlrt_marshallOut(cv3), b_emlrt_marshallOut(varargin_2),
                  &v_emlrtMCI);

            /* Note: if this error is thrown, then find all values of 115 in the code in this file and  */
            /* replace with the value of RowToReturnBlockLinIdx_FR. */
          }

          /* %%%%% Insert ROIs corresponding to frames before current frame %%%%%% */
          /* If block contains ROIs before first function call to ROIMSIR   */
          if (FaceOrSkinTF) {
            /* Insert ROIs corresponding to frames before first function call to ROIMSIR that have a  */
            /* detection. */
            /* If at least one ROI in block with a detection */
            /* Linear index of frames before first call that have a detection */
            /* Column vector; type double. */
            VideoReadConfig_FrameIdx_Length = d_ROIBlockDetectionFaceSkinLinI -
              1;
            Start = 0;
            winNew = 0;
            for (b_i = 0; b_i <= VideoReadConfig_FrameIdx_Length; b_i++) {
              u = f_ROIBlockDetectionFaceSkinLinI[b_i];
              if (u < NDetectionsSkin_SR) {
                Start++;
                c_ROIBlockBeforeFirstCallDetect[winNew] = u;
                winNew++;
              }
            }

            /* Insert ROIs corresponding to frames before first function call that have a detection.  */
            /* Type int16. */
            /* Note: these are not the final version of these ROIs; these ROIs will not be finalized */
            /* until they are reprocessed in function ROIMeans_SecondRead. They may approximate the final */
            /* ROIs because they were size-matched and smoothed in functions ROIMSIR_SizeMatch and    */
            /* ROIMSIR_DetectionSmooth, respectively.  */
            /* M x 4 matrix; type int16. */
            for (i = 0; i < Start; i++) {
              winNew = c_ROIBlockBeforeFirstCallDetect[i] - 1;
              e_NoPrevCallsBlock_ROIDetection[winNew] =
                ROINoPrevCallsBlock_FR[winNew];
            }

            for (i = 0; i < Start; i++) {
              winNew = c_ROIBlockBeforeFirstCallDetect[i] + 228;
              e_NoPrevCallsBlock_ROIDetection[winNew] =
                ROINoPrevCallsBlock_FR[winNew];
            }

            for (i = 0; i < Start; i++) {
              winNew = c_ROIBlockBeforeFirstCallDetect[i] + 457;
              e_NoPrevCallsBlock_ROIDetection[winNew] =
                ROINoPrevCallsBlock_FR[winNew];
            }

            for (i = 0; i < Start; i++) {
              winNew = c_ROIBlockBeforeFirstCallDetect[i] + 686;
              e_NoPrevCallsBlock_ROIDetection[winNew] =
                ROINoPrevCallsBlock_FR[winNew];
            }

            /* Insert ROIs for frames before current frame that were processed by previous calls */
            /* These may come from a detection or come from interpolation / extrapolation from a previous */
            /* call. */
            /* Note: these are the final version of these ROIs. */
            /* Assert length to prevent dynamic memory allocation for colon operator */
            /* Note: constant 229 assumes that the length of BlockFullLinIdx == 229. If the length of this  */
            /* variable were to change, the constant would need to be modified. */
            /* M x 4 matrix; type int16.     */
            if (NDetectionsSkin_SR > RowToReturnBlockLinIdx_FR + 1) {
              i = 0;
              i1 = -1;
              b_i = 1;
            } else {
              i = NDetectionsSkin_SR - 1;
              i1 = RowToReturnBlockLinIdx_FR;
              b_i = NDetectionsSkin_SR;
            }

            Sum = i1 - i;
            for (i1 = 0; i1 <= Sum; i1++) {
              e_NoPrevCallsBlock_ROIDetection[(b_i + i1) - 1] = ROIBlock_FR[i +
                i1];
            }

            for (i1 = 0; i1 <= Sum; i1++) {
              e_NoPrevCallsBlock_ROIDetection[(b_i + i1) + 228] = ROIBlock_FR[(i
                + i1) + 229];
            }

            for (i1 = 0; i1 <= Sum; i1++) {
              e_NoPrevCallsBlock_ROIDetection[(b_i + i1) + 457] = ROIBlock_FR[(i
                + i1) + 458];
            }

            for (i1 = 0; i1 <= Sum; i1++) {
              e_NoPrevCallsBlock_ROIDetection[(b_i + i1) + 686] = ROIBlock_FR[(i
                + i1) + 687];
            }

            /* If block does not contain ROIs before first function call     */
          } else {
            /* Insert ROIs for frames before current frame that were returned by previous calls to function */
            /* ROIMSIR. Use the version of the ROIs that were not resized. The ROIs before resizing are used  */
            /* because the target ROI has not yet been resized (it will be in the final step of function  */
            /* ROIMSIR). */
            /* ROIs from previous calls without resizing */
            if (1 > RowToReturnBlockLinIdx_FR + 1) {
              Sum = -1;
            } else {
              Sum = RowToReturnBlockLinIdx_FR;
            }

            /* Insert these ROIs into matrix used in interpolation / extrapolation */
            /* Note: these are the final version of these ROIs.              */
            if (0 <= Sum) {
              memcpy(&e_NoPrevCallsBlock_ROIDetection[0], &ROINoResizeBlock_FR[0],
                     (Sum + 1) * sizeof(int16_T));
              memcpy(&e_NoPrevCallsBlock_ROIDetection[229],
                     &ROINoResizeBlock_FR[229], (Sum + 1) * sizeof(int16_T));
              memcpy(&e_NoPrevCallsBlock_ROIDetection[458],
                     &ROINoResizeBlock_FR[458], (Sum + 1) * sizeof(int16_T));
              memcpy(&e_NoPrevCallsBlock_ROIDetection[687],
                     &ROINoResizeBlock_FR[687], (Sum + 1) * sizeof(int16_T));
            }
          }

          /* %%%%% Insert ROI corresponding to current frame %%%%%%       */
          /* 229 x 4 matrix; type int16. */
          /* Note: constant 229 assumes that the length of BlockFullLinIdx == 229. If the length of this  */
          /* variable were to change, the constant would need to be modified. */
          e_NoPrevCallsBlock_ROIDetection[RowToReturnBlockLinIdx_FR + 1] =
            ROIOut_FR[0];
          e_NoPrevCallsBlock_ROIDetection[RowToReturnBlockLinIdx_FR + 230] =
            ROIOut_FR[1];
          e_NoPrevCallsBlock_ROIDetection[RowToReturnBlockLinIdx_FR + 459] =
            ROIOut_FR[2];
          e_NoPrevCallsBlock_ROIDetection[RowToReturnBlockLinIdx_FR + 688] =
            ROIOut_FR[3];

          /* %%%%% Insert ROIs corresponding to frames after current frame that have a detection %%%%%%                */
          /* Insert ROIs corresponding to detections for frames after current frame */
          /* Note: ROIs have only been modified in the current function and not in previous calls to the  */
          /* function; this removes the positive-feedback loop effect (see note in the file for function  */
          /* ROIMSIR).  */
          /* Linear index of detections present in frames after current frame */
          /* Note: SetDiff is a custom function located within folder 'FacePulseRate'. */
          /* SetDiff   Return the elements of set A that are different from set B, assuming elements within    */
          /*           each set do not repeat and monotonically increase. */
          /*  */
          /*     Helper function to function FacePulseRate.  */
          /*     Within function FacePulseRate, called by functions ROIMSIR_FrameByFrameSmooth_InterpFR and */
          /*     ROIMSIR_FrameByFrameSmooth_SmoothFR. */
          /*  */
          /*     Code generation:  */
          /*  */
          /*     Can be called as a Matlab function or used for C-language code generation. */
          /*  */
          /*     Description: */
          /*  */
          /*     Optimized algorithm for returning the elements of set A that are different from set B.  */
          /*     Optimized by assuming that, within each set, elements do not repeat and monotonically  */
          /*     increase. */
          /* Inline function */
          /* Preallocate output */
          /* Index of A of elements that are different from B */
          /* The elements of A corresponding to this index will be returned as output Set. */
          winNew = 0;

          /* Index of B where last match made with A */
          Idx = 0;

          /* Loop across elements of A */
          for (b_i = 0; b_i < NDetectionsFaceSkin_FR; b_i++) {
            /* Reset match flag */
            MatchTF = false;

            /* On first iteration of each while-loop, start after the element of B where the last match was */
            /* made. This increases efficiency by skipping elements of B where a match was already made. This  */
            /* is only possible when the values within each input are sorted and unique. */
            j = Idx;

            /* Loop across elements of B */
            /* Note: once all elements of B have been iterated across, all remaining elements of A are  */
            /* considered different than B. This is only possible when all values of A are unique. */
            exitg1 = false;
            while ((!exitg1) && (j < 115)) {
              j++;

              /* If B(j) matches A(i) */
              if (f_ROIBlockDetectionFaceSkinLinI[b_i] == (int8_T)((int8_T)(j -
                    1) + 1)) {
                MatchTF = true;
                Idx = j;

                /* With assumption that only unique values within each set, the remaining elements in B */
                /* can be skipped for this element of A. */
                exitg1 = true;
              }
            }

            /* Assign A(i) if no match with B */
            if (!MatchTF) {
              winNew++;

              /* Assign value of A(i) */
              c_ROIBlockDetectionSkinLinIdx_F[winNew - 1] =
                f_ROIBlockDetectionFaceSkinLinI[b_i];
            }
          }

          /* Trim preallocated rows that were not assigned */
          if (1 > winNew) {
            Sum = 0;
          } else {
            Sum = winNew;
          }

          /* end function */
          /* Insert ROIs from detections after current frame  */
          /* M x 4 matrix; type int16. */
          if (Sum != 0) {
            for (i = 0; i < Sum; i++) {
              i1 = c_ROIBlockDetectionSkinLinIdx_F[i];
              e_NoPrevCallsBlock_ROIDetection[i1 - 1] =
                ROINoPrevCallsBlock_FR[i1 - 1];
            }

            for (i = 0; i < Sum; i++) {
              i1 = c_ROIBlockDetectionSkinLinIdx_F[i];
              e_NoPrevCallsBlock_ROIDetection[i1 + 228] =
                ROINoPrevCallsBlock_FR[i1 + 228];
            }

            for (i = 0; i < Sum; i++) {
              i1 = c_ROIBlockDetectionSkinLinIdx_F[i];
              e_NoPrevCallsBlock_ROIDetection[i1 + 457] =
                ROINoPrevCallsBlock_FR[i1 + 457];
            }

            for (i = 0; i < Sum; i++) {
              i1 = c_ROIBlockDetectionSkinLinIdx_F[i];
              e_NoPrevCallsBlock_ROIDetection[i1 + 686] =
                ROINoPrevCallsBlock_FR[i1 + 686];
            }
          }

          /* %%%%% Error checking %%%%%%                */
          /* Verify that ROIs to be included in smoothing do not contain zeros */
          /* The smoothing operation is intended to be conducted only on non-zeros ROIs. Such a value is likely */
          /* due to an implementation error in this function. */
          /* Loop across elements */
          /* Note: constant 229 assumes that the length of BlockFullLinIdx == 229. If the length of this  */
          /* variable were to change, the constant would need to be modified. */
          for (b_i = 0; b_i < 916; b_i++) {
            if (e_NoPrevCallsBlock_ROIDetection[b_i] == 0) {
              /* Throw exception */
              /* Called as extrinsic so that stack trace can be displayed. */
              b_sprintf(VideoReadConfig_FrameIdx_FR->
                        data[RowToReturnFullLinIdx_FR - 1], r1);
              i = varargin_2->size[0] * varargin_2->size[1];
              varargin_2->size[0] = 1;
              varargin_2->size[1] = r1->size[1] + 222;
              emxEnsureCapacity_char_T(varargin_2, i);
              for (i = 0; i < 74; i++) {
                varargin_2->data[i] = cv59[i];
              }

              for (i = 0; i < 29; i++) {
                varargin_2->data[i + 74] = cv60[i];
              }

              Sum = r1->size[1];
              for (i = 0; i < Sum; i++) {
                varargin_2->data[i + 103] = r1->data[i];
              }

              for (i = 0; i < 73; i++) {
                varargin_2->data[(i + r1->size[1]) + 103] = cv61[i];
              }

              for (i = 0; i < 46; i++) {
                varargin_2->data[(i + r1->size[1]) + 176] = cv62[i];
              }

              error(emlrt_marshallOut(cv3), b_emlrt_marshallOut(varargin_2),
                    &w_emlrtMCI);
            }
          }

          /* Check whether the ROI size is unreasonably small */
          /* Such a small size is likely due to an implementation error in this function. */
          /* This check is intended to be run when testing new implementations, as small ROI sizes are an */
          /* indication of a implementation error. As occassional values below 20 may be considered */
          /* acceptable, this check is not intended for use outside of testing. "Occassional" in this case    */
          /* might be defined as a few occurances out of 10,000. Flag ExpectedBehaviorTestTF enables the */
          /* check. */
          if (ExpectedBehaviorTestTF) {
            for (i = 0; i < 2; i++) {
              for (i1 = 0; i1 < 229; i1++) {
                HasROI_TF_data[i1 + 229 * i] =
                  (e_NoPrevCallsBlock_ROIDetection[i1 + 229 * (i + 2)] < 20);
              }
            }

            if (vectorAny(HasROI_TF_data, iv)) {
              /* Display warning indicating frame index */
              /* Note: function warning() not available for code generation, so it must have previously been */
              /* declared as extrinsic. */
              /* Function fprintf can not be used as a substitute for warning() in this case because fprintf  */
              /* can not accept variable-length arguments.        */
              b_sprintf(VideoReadConfig_FrameIdx_FR->
                        data[RowToReturnFullLinIdx_FR - 1], r1);
              i = varargin_2->size[0] * varargin_2->size[1];
              varargin_2->size[0] = 1;
              varargin_2->size[1] = r1->size[1] + 304;
              emxEnsureCapacity_char_T(varargin_2, i);
              for (i = 0; i < 80; i++) {
                varargin_2->data[i] = cv63[i];
                varargin_2->data[i + 80] = cv64[i];
              }

              for (i = 0; i < 61; i++) {
                varargin_2->data[i + 160] = cv65[i];
              }

              Sum = r1->size[1];
              for (i = 0; i < Sum; i++) {
                varargin_2->data[i + 221] = r1->data[i];
              }

              for (i = 0; i < 83; i++) {
                varargin_2->data[(i + r1->size[1]) + 221] = cv66[i];
              }

              warning(emlrt_marshallOut(cv3), b_emlrt_marshallOut(varargin_2),
                      &x_emlrtMCI);
            }
          }

          /* %%%%% Smooth target ROI X- and Y-coordinates %%%%%% */
          /* Smooth X- and Y-coordinates with mean */
          /* Equivalent to moving-mean smoothing but for a single ROI. */
          /* Linear index of X- and Y-coordinates to smooth */
          /* Row vector; type int32. */
          /* Note: using a constant rather than a variable may prevent dynamic memory allocation from the colon */
          /* operator. */
          /* 115 is a constant, which represents RowToReturnBlockLinIdx_FR. */
          /* Assert length to prevent dynamic memory allocation for colon operator */
          /* Case with variable */
          /* FrameByFrameSmoothingWin_XYLinIdx = ... */
          /*     RowToReturnBlockLinIdx_FR - FrameByFrameSmoothingWin_XYHalf : ... */
          /*     RowToReturnBlockLinIdx_FR + FrameByFrameSmoothingWin_XYHalf; */
          /* Case with constant */
          eml_integer_colon_dispatcher(115 - n, n + 115, FramesToAdjust);
          Sum = FramesToAdjust->size[0] * FramesToAdjust->size[1];
          for (i = 0; i < Sum; i++) {
            f_ROIBlockNoDetectionFaceSkinLi[i] = FramesToAdjust->data[i];
          }

          /* Length of vector FrameByFrameSmoothingWin_XYLinIdx */
          Idx = (n << 1) + 1;

          /* Assert length to prevent dynamic memory allocation for colon operator */
          /* Columns means of X and Y columns: */
          /* Initialize sum accumulators */
          /* Note: for accumulating across 229 rows, type int32 is not expected to overflow. */
          winNew = 0;
          VideoReadConfig_FrameIdx_Length = 0;
          for (j = 0; j < Idx; j++) {
            /* Convert from subscript indices to a linear index for more efficient indexing */
            /* Scalar; type int32. */
            /* Accumulate */
            /* Cast to type int32 to avoid overflow with type int16. */
            /* Index using a linear index rather than subscripts; In compiled C code, the faster indexing  */
            /* outweighs the cost of the conversion. */
            /* Note: constant 229 assumes that the length of BlockFullLinIdx == 229. If the length of this  */
            /* variable were to change, the constant would need to be modified. */
            i = f_ROIBlockNoDetectionFaceSkinLi[j];
            winNew += e_NoPrevCallsBlock_ROIDetection[i - 1];

            /* subscript indexing: (j, 1)       */
            VideoReadConfig_FrameIdx_Length += e_NoPrevCallsBlock_ROIDetection[i
              + 228];

            /* subscript indexing: (j, 2)             */
          }

          /* Take means */
          if (Idx == 0) {
            if (winNew == 0) {
              z = 0;
            } else if (winNew < 0) {
              z = MIN_int32_T;
            } else {
              z = MAX_int32_T;
            }

            if (VideoReadConfig_FrameIdx_Length == 0) {
              winNew = 0;
            } else if (VideoReadConfig_FrameIdx_Length < 0) {
              winNew = MIN_int32_T;
            } else {
              winNew = MAX_int32_T;
            }
          } else if (Idx == 1) {
            z = winNew;
            winNew = VideoReadConfig_FrameIdx_Length;
          } else if (Idx == -1) {
            z = -winNew;
            winNew = -VideoReadConfig_FrameIdx_Length;
          } else {
            if (winNew >= 0) {
              d_x = (uint32_T)winNew;
            } else if (winNew == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-winNew;
            }

            if (Idx >= 0) {
              b_y = (uint32_T)Idx;
            } else if (Idx == MIN_int32_T) {
              b_y = 2147483648U;
            } else {
              b_y = (uint32_T)-Idx;
            }

            if (b_y == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / b_y;
            }

            d_x -= q * b_y;
            if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
              q++;
            }

            z = (int32_T)q;
            if ((winNew < 0) != (Idx < 0)) {
              z = -(int32_T)q;
            }

            if (VideoReadConfig_FrameIdx_Length >= 0) {
              d_x = (uint32_T)VideoReadConfig_FrameIdx_Length;
            } else if (VideoReadConfig_FrameIdx_Length == MIN_int32_T) {
              d_x = 2147483648U;
            } else {
              d_x = (uint32_T)-VideoReadConfig_FrameIdx_Length;
            }

            if (Idx >= 0) {
              b_y = (uint32_T)Idx;
            } else if (Idx == MIN_int32_T) {
              b_y = 2147483648U;
            } else {
              b_y = (uint32_T)-Idx;
            }

            if (b_y == 0U) {
              q = MAX_uint32_T;
            } else {
              q = d_x / b_y;
            }

            d_x -= q * b_y;
            if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
              q++;
            }

            winNew = (int32_T)q;
            if ((VideoReadConfig_FrameIdx_Length < 0) != (Idx < 0)) {
              winNew = -(int32_T)q;
            }
          }

          ROIOut_FR[0] = (int16_T)z;
          ROIOut_FR[1] = (int16_T)winNew;

          /* %%%%% Smooth target ROI width and height %%%%%%  */
          /* %%%%% --- Smooth with moving median to apply strong smoothing to widths and heights %%%%%% */
          /* Assign unsmoothed widths and heights for later step  */
          /* 1 x 2 row vector; type int16. */
          /* Linear index of width and height to smooth */
          /* Row vector; type int32. */
          /* Note: using a constant rather than a variable may prevent dynamic memory allocation from the colon */
          /* operator. */
          /* 115 is a constant, which represents RowToReturnBlockLinIdx_FR. */
          /* Also use assert to prevent dynamic memory allocation from the colon operator. */
          /* Case with variable */
          /* FrameByFrameSmoothingWin_WHLinIdx = ... */
          /*     RowToReturnBlockLinIdx_FR - FrameByFrameSmoothingWin_WHHalf : ... */
          /*     RowToReturnBlockLinIdx_FR + FrameByFrameSmoothingWin_WHHalf; */
          /* Case with constant */
          /* Length of vector FrameByFrameSmoothingWin_WHHalf */
          HeightRatio_Single = (real32_T)((FrameByFrameSmoothingWin_WHHalf << 1)
            + 1);

          /* Smooth width and height with median */
          /* Equivalent to moving-median smoothing but for a single ROI.  */
          /* 1 x 4 row vector; type int16. */
          /* Local function. */
          /*  number of rows */
          /*  number of columns */
          eml_integer_colon_dispatcher(115 - FrameByFrameSmoothingWin_WHHalf,
            FrameByFrameSmoothingWin_WHHalf + 115, FramesToAdjust);
          ROIWidthHeightPreSmooth_size[0] = FramesToAdjust->size[1];
          ROIWidthHeightPreSmooth_size[1] = 2;
          Sum = FramesToAdjust->size[1];
          WidthNew_ith = ROIOut_FR[2];
          for (i = 0; i < Sum; i++) {
            ROIWidthHeightPreSmooth_data[i] =
              e_NoPrevCallsBlock_ROIDetection[FramesToAdjust->data[i] + 457];
          }

          HeightNew_ith = ROIOut_FR[3];
          for (i = 0; i < Sum; i++) {
            ROIWidthHeightPreSmooth_data[i + ROIWidthHeightPreSmooth_size[0]] =
              e_NoPrevCallsBlock_ROIDetection[FramesToAdjust->data[i] + 686];
          }

          /* end main function */
          /* ============================================================================================= */
          /* Local functions */
          /* ============================================================================================= */
          /* ============================================================================================= */
          /* medianByColumn   Find the median of each column. */
          /*                                  */
          /*     Notes:  */
          /*  */
          /*     Adapted from the Matlab function 'median'. */
          /*  */
          /*     This function relies on the maximum value of an ROI being 16384. This is because the data type   */
          /*     used for the ROI is int16, which has a maximum value of 32768. In order to allow two variables */
          /*     to be added without exceeding 32768, the maximum value may be half of 32768 (16384). This  */
          /*     constraint is noted in the description of function FacePulseRate; if the current function is  */
          /*     to be removed, the description in function FacePulseRate should be modified. */
          /* Inline function */
          /* Sort by column */
          sort(ROIWidthHeightPreSmooth_data, ROIWidthHeightPreSmooth_size);

          /* Center row */
          winNew = (int32_T)muSingleScalarFloor(HeightRatio_Single / 2.0F);

          /* Median */
          Width_ith = ROIWidthHeightPreSmooth_data[winNew];
          Idx = winNew + ROIWidthHeightPreSmooth_size[0];
          Height_ith = ROIWidthHeightPreSmooth_data[Idx];

          /* If even number of rows */
          /* Optimize multiplication by two using bit-wise division */
          /* Non-optimized: 2 * centerRow == nRows. */
          if ((real_T)(winNew << 1) == HeightRatio_Single) {
            /* Take average of two center rows          */
            /* Optimize division by two using bit-wise division */
            Width_ith = (int16_T)((int16_T)(Width_ith +
              ROIWidthHeightPreSmooth_data[winNew - 1]) >> 1);

            /* Optimize division by two using bit-wise division */
            Height_ith = (int16_T)((int16_T)(Height_ith +
              ROIWidthHeightPreSmooth_data[Idx - 1]) >> 1);
          }

          /* end local function */
          ROIOut_FR[2] = Width_ith;
          ROIOut_FR[3] = Height_ith;

          /* %%%%% --- Resmooth widths and heights to remove any sudden jumps %%%%%%   */
          /* Resmooth to reduce sudden changes due to the moving-median smoothing. */
          /* Smooth using ROIs from immediately previous ROIs (these ROIs were returned by previous calls to */
          /* function ROIMSIR). Use ROIs from ROINoResizeBlock_FR because these ROIs were not resized;  */
          /* non-resized ROIs are used because the target ROI has not yet been resized (it will be in the final  */
          /* step of function ROIMSIR). */
          /* Use window of 3.     */
          /* Linear index of previous ROIs to include in resmoothing */
          /* 1 x 2 row vector; type int32. */
          /* Note: using a constant rather than a variable prevents dynamic memory allocation from the colon */
          /* operator. */
          /* Case with variable */
          /* ResmoothWHLinIdx = RowToReturnBlockLinIdx_FR - 2 : RowToReturnBlockLinIdx_FR - 1; */
          /* Case with constant */
          /* Only resmooth if the ROIs in ROINoResizeBlock_FR corresponding to the resmoothing index have been   */
          /* previously processed by the function. Otherwise, the ROIs corresponding to the index might have    */
          /* values of zero. This logical value will only be false on two occassions (two is the length of the  */
          /* resmoothing index) */
          if (113 >= NDetectionsSkin_SR) {
            /* Preallocate ROI matrix for use in resmoothing */
            /* 3 x 2 matrix; type int16. */
            /* Insert widths and heights of previous ROIs without resizing into matrix to be used for  */
            /* resmoothing. */
            /* Index 1 : 2 assumes two previous ROIs are used. */
            /* Insert widths and heights of target ROI into matrix to be used for resmoothing */
            /* Index 3 assumes span of 3. */
            /* Remooth target ROI width and height with mean */
            /* Similar to moving-mean smoothing but for a single ROI. */
            /* 1 x 4 row vector; type int16.  */
            for (b_i = 0; b_i < 2; b_i++) {
              winNew = 229 * (b_i + 2);

              /* Initialize sum accumulator */
              /* Note: as only three rows are accumulated, type int16 is not expected to overflow.  */
              /* Accumulate */
              /* Accumulate */
              /* Accumulate */
              Width_ith = (int16_T)((int16_T)(ROINoResizeBlock_FR[winNew + 112]
                + ROINoResizeBlock_FR[winNew + 113]) + ROIOut_FR[b_i + 2]);

              /* Take mean */
              if (Width_ith >= 0) {
                e_x = (uint16_T)Width_ith;
              } else if (Width_ith == -32768) {
                e_x = 32768U;
              } else {
                e_x = (uint16_T)-Width_ith;
              }

              b_q = (uint16_T)(e_x / 3U);
              e_x = (uint16_T)((uint32_T)e_x - b_q * 3);
              if ((e_x > 0) && (e_x >= 2)) {
                b_q++;
              }

              ROIOut_FR[b_i + 2] = (int16_T)b_q;
              if (Width_ith < 0) {
                ROIOut_FR[b_i + 2] = (int16_T)-b_q;
              }
            }
          }

          /* %%%%% Adjust X- and Y-coordinates to correspond to adjustments in width and height %%%%%% */
          /* Loop across X and Y columns */
          /* 1 x 4 row vector; type int16. */
          /*  Add the half-difference to the X- or Y-coordinate */
          /*  (If there were a negative difference, this would imply the abs value of the */
          /*  Take half of the difference (optimize division by 2 with bit-wise division) */
          /*  Difference between unsmoothed width and height and smoothed width and height */
          ROIOut_FR[0] = (int16_T)(ROIOut_FR[0] + ((int16_T)(WidthNew_ith -
            ROIOut_FR[2]) >> 1));

          /* 1 x 4 row vector; type int16. */
          /*  Add the half-difference to the X- or Y-coordinate */
          /*  (If there were a negative difference, this would imply the abs value of the */
          /*  Take half of the difference (optimize division by 2 with bit-wise division) */
          /*  Difference between unsmoothed width and height and smoothed width and height */
          ROIOut_FR[1] = (int16_T)(ROIOut_FR[1] + ((int16_T)(HeightNew_ith -
            ROIOut_FR[3]) >> 1));
        }

        /* %%%%% Second-read operations %%%%%%    */
        /* To apply smoothing to ROIs only once, the function is called during the second-read operations (by  */
        /* function ROIMeans_SecondRead) only for the post-processing (but not pre-processing) step.     */
        /* %%%%% Adjust ROI(s) that exceed frame dimensions %%%%%%     */
        /* Although it may seem unlikely for the smoothing of ROIs to result in values outside of frame */
        /* dimensions, this might occur when, for example, both the width and the X-coordinate increased or  */
        /* both the height and the Y-coordinate increased. */
        /* First-read operations */
        /* 1 x 4 row vector; type int16. */
        /* Note: ROIAdjustIfExceedsFrameDims is a custom function located within folder 'FacePulseRate'. */
        /* ROIAdjustIfExceedsFrameDims   Verify whether proposed widths and heights of ROIs exceed frame  */
        /*                               dimensions and, if so, modify them to conform to frame dimensions. */
        /*                                */
        /*     Helper function to function FacePulseRate. */
        /*     Within function FacePulseRate, called by functions ROIResize, ROIMeans_FirstRead_Extrapolate, */
        /*     SkinDetect_EnlargeROI, ROIMSIR, ROIMSIR_MatchSize, ROIMSIR_DetectionSmooth,   */
        /*     ROIMSIR_Interpolate, and ROIMSIR_FrameByFrameSmooth.    */
        /*  */
        /*  */
        /*     Code Generation */
        /*     --------------- */
        /*  */
        /*     Can be called as a Matlab function or used for C-language code generation. */
        /*  */
        /*  */
        /*     Description */
        /*     ----------- */
        /*  */
        /*     This function verifies that ROIs that have had modifications to their sizes are still within */
        /*     the dimensions of the frame. If not, this function adjusts the dimensions (and, consequently,   */
        /*     the spatial coordinates) to conform to the frame dimensions. */
        /*  */
        /*     Note:  */
        /*  */
        /*     Intended only for use with integer types as rounding is not conducted. For modification for  */
        /*     use with floating-point types, rounding would be necessary as ROI values should be integers. */
        /*  */
        /*  */
        /*     Copyright */
        /*     --------- */
        /*  */
        /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
        /*     the Responsible AI License (RAIL). */
        /* %%%%% Validate inputs %%%%%% */
        /* Exit if empty */
        /* Validate whether input ROIsProposed is type int16. */
        /* Must be an integer type because no rounding is conducted. */
        /* Should be type int16 because the function is implemented to assign values of this type. */
        /* A non-matching type would be due to an implementation error. */
        /* %%%%% Running in code generation %%%%%% */
        /* When running in code generation, use for-loops. When running in Matlab code, use vectorization. */
        /* code generation running */
        /* Inline function */
        /* %%%%% --- Verify, and adjust if necessary, X-coordinates and widths %%%%%% */
        /* Adjust left-side X-coordinate if exceeds frame dimensions: */
        WidthNew_ith = (int16_T)(ROIOut_FR[0] - 1);
        if (ROIOut_FR[0] < 1) {
          WidthNew_ith = 0;

          /* recent code mod */
          ROIOut_FR[0] = 1;
        } else {
          if (ROIOut_FR[0] > VidObjWidth) {
            WidthNew_ith = (int16_T)(VidObjWidth - 1);

            /* recent code mod */
            ROIOut_FR[0] = VidObjWidth;
          }
        }

        /* Adjust right-side X-coordinate if exceeds frame dimensions: */
        Width_ith = (int16_T)(WidthNew_ith + ROIOut_FR[2]);
        if (Width_ith > VidObjWidth) {
          Width_ith = VidObjWidth;
          ROIOut_FR[2] = (int16_T)(VidObjWidth - WidthNew_ith);
        } else {
          if (Width_ith < 1) {
            Width_ith = 1;
            WidthNew_ith = 0;
            ROIOut_FR[0] = 1;
            ROIOut_FR[2] = 1;
          }
        }

        /* Adjust width if exceeds frame dimensions: */
        Width_ith -= WidthNew_ith;
        if (Width_ith > VidObjWidth) {
          ROIOut_FR[2] = VidObjWidth;
        } else {
          if (Width_ith < 1) {
            ROIOut_FR[2] = 1;
          }
        }

        /* %%%%% --- Verify, and adjust if necessary, Y-coordinates and heights %%%%%% */
        /* Adjust top-side Y-coordinate if exceeds frame dimensions: */
        Height_ith = (int16_T)(ROIOut_FR[1] - 1);
        if (ROIOut_FR[1] < 1) {
          Height_ith = 0;

          /* recent code mod */
          ROIOut_FR[1] = 1;
        } else {
          if (ROIOut_FR[1] > VidObjHeight) {
            Height_ith = (int16_T)(VidObjHeight - 1);

            /* recent code mod */
            ROIOut_FR[1] = VidObjHeight;
          }
        }

        /* Adjust bottom-side Y-coordinate if exceeds frame dimensions: */
        Width_ith = (int16_T)(Height_ith + ROIOut_FR[3]);
        if (Width_ith > VidObjHeight) {
          Width_ith = VidObjHeight;
          ROIOut_FR[3] = (int16_T)(VidObjHeight - Height_ith);
        } else {
          if (Width_ith < 1) {
            Width_ith = 1;
            Height_ith = 0;
            ROIOut_FR[1] = 1;
            ROIOut_FR[3] = 1;
          }
        }

        /* Adjust height value if exceeds frame dimensions: */
        HeightNew_ith = (int16_T)(Width_ith - Height_ith);
        if (HeightNew_ith > VidObjHeight) {
          ROIOut_FR[3] = VidObjHeight;
        } else {
          if (HeightNew_ith < 1) {
            ROIOut_FR[3] = 1;
          }
        }

        /* %%%%% Code generation not running %%%%%% */
        /* end function */
        /* ============================================================================================= */
        /* Code-generation and build script */
        /* ============================================================================================= */
        /* Code-generation and build script used to generate C-language code and create the compiled version  */
        /* (ROIAdjustIfExceedsFrameDims_mex) of the function. */
        /* { */
        /*  */
        /* %%%%% Specify variable-size input arguments %%%%%% */
        /*  */
        /* See Matlab documentation for coder.typeof. */
        /*  */
        /*                                   Example Code               Upp. Bounds   Var. Size (T/F)  Type */
        /* ROIsProposedCode   = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],     [1, 0] );        %int16 */
        /*            */
        /*        */
        /* %%%%% Specify fixed-size input arguments %%%%%% */
        /*  */
        /* VidObjWidthCode  = int16(0);          */
        /* VidObjHeightCode = int16(0); */
        /*                    */
        /*  */
        /* %%%%% Set configurations to increase performance %%%%%% */
        /*  */
        /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
        /* "Optimization Strategies" */
        /*  */
        /* cfg = coder.config('mex'); */
        /* cfg.GlobalDataSyncMethod = 'NoSync'; */
        /* cfg.ConstantInputs = 'IgnoreValues'; */
        /* cfg.ExtrinsicCalls = true; %permit to show assert error */
        /* cfg.SaturateOnIntegerOverflow = false; */
        /* cfg.IntegrityChecks = false; */
        /* cfg.ResponsivenessChecks = false; */
        /*  */
        /*  */
        /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
        /*  */
        /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
        /*  */
        /* The flags are specified as part of the code-generation configuration object. A custom function, */
        /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
        /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
        /* Matlab guidance found in */
        /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
        /*  */
        /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
        /* a character vector prior to execution of the codegen command. */
        /*  */
        /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
        /*  */
        /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
        /* is not present in the base workspace. */
        /*  */
        /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
        /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
        /* character vector to maintain the charater vector, */
        /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
        /*  */
        /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
        /*  */
        /* Assign to code-generation configuration object */
        /* cfg.PostCodeGenCommand = setbuildargsAsText; */
        /*  */
        /*  */
        /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
        /*  */
        /* codegen ROIAdjustIfExceedsFrameDims.m -report -config cfg -args {ROIsProposedCode, VidObjWidthCode, VidObjHeightCode} */
        /*                  */
        /* } */
        /* Second-read operations    */
        /* %%%%% Output validation %%%%%% */
        /* For first-read operations */
        /* Assert row size as zero because this variable not used in first-read operations */
        /* This may help remove dynamic memory allocation for this variable. */
        /* Check whether any ROI value is zero */
        /* The operations of this function were intended to prevent values of zero, so such a value is */
        /* likely due to an implementation error in this function.  */
        if ((ROIOut_FR[0] == 0) || (ROIOut_FR[1] == 0) || (ROIOut_FR[2] == 0) ||
            (ROIOut_FR[3] == 0)) {
          /* Throw error */
          /* Called as extrinsic so that stack trace can be displayed. */
          b_sprintf(VideoReadConfig_FrameIdx_FR->data[RowToReturnFullLinIdx_FR -
                    1], r1);
          i = varargin_2->size[0] * varargin_2->size[1];
          varargin_2->size[0] = 1;
          varargin_2->size[1] = r1->size[1] + 247;
          emxEnsureCapacity_char_T(varargin_2, i);
          for (i = 0; i < 73; i++) {
            varargin_2->data[i] = cv43[i];
          }

          for (i = 0; i < 75; i++) {
            varargin_2->data[i + 73] = cv45[i];
          }

          for (i = 0; i < 25; i++) {
            varargin_2->data[i + 148] = cv32[i];
          }

          Sum = r1->size[1];
          for (i = 0; i < Sum; i++) {
            varargin_2->data[i + 173] = r1->data[i];
          }

          for (i = 0; i < 74; i++) {
            varargin_2->data[(i + r1->size[1]) + 173] = cv50[i];
          }

          error(emlrt_marshallOut(cv3), b_emlrt_marshallOut(varargin_2),
                &r_emlrtMCI);
        }

        /* Check whether the ROI size is unreasonably small */
        /* Such a small size is likely due to an implementation error in this function. */
        /* This check is intended to be run when testing new implementations, as small ROI sizes are an */
        /* indication of a implementation error. As occassional values below 20 may be considered */
        /* acceptable, this check is not intended for use outside of testing. "Occassional" in this case    */
        /* might be defined as a few occurances out of 10,000. Flag ExpectedBehaviorTestTF enables the */
        /* check.     */
        if (ExpectedBehaviorTestTF && ((ROIOut_FR[2] < 20) || (ROIOut_FR[3] < 20)))
        {
          /* Display warning indicating frame index */
          /* Note: function warning() not available for code generation, so it must have previously */
          /* been declared as extrinsic. */
          /* Function fprintf can not be used as a substitute for warning() in this case because  */
          /* fprintf can not accept variable-length arguments.        */
          b_sprintf(VideoReadConfig_FrameIdx_FR->data[RowToReturnFullLinIdx_FR -
                    1], r1);
          i = varargin_2->size[0] * varargin_2->size[1];
          varargin_2->size[0] = 1;
          varargin_2->size[1] = r1->size[1] + 74;
          emxEnsureCapacity_char_T(varargin_2, i);
          Sum = r1->size[1];
          for (i = 0; i < Sum; i++) {
            varargin_2->data[i] = r1->data[i];
          }

          for (i = 0; i < 74; i++) {
            varargin_2->data[i + r1->size[1]] = cv50[i];
          }

          for (i = 0; i < 232; i++) {
            cv54[i << 1] = cv55[i];
          }

          Sum = varargin_2->size[1];
          for (i = 0; i < Sum; i++) {
            cv54[(i << 1) + 1] = varargin_2->data[i];
          }

          warning(emlrt_marshallOut(cv3), k_emlrt_marshallOut(cv54), &s_emlrtMCI);
        }

        /* Check whether ROI type not int16 because other functions are implemented to accept values of   */
        /* this type.  */
        /* A non-matching type would be due to an implementation error. */
        /* For second-read operations     */
      }

      /* end function */
      /* ============================================================================================= */
      /* Code-generation and build script */
      /* ============================================================================================= */
      /* Note: this function is not currently used as a compiled function as it is nested within a */
      /* compiled function, ROIMSIR_mex. */
      /* Code-generation and build script used to generate C-language code and create the compiled version  */
      /* (ROIMSIR_FrameByFrameSmooth_mex) of the function. */
      /* { */
      /*  */
      /*  */
      /* %%%%% Specify variable-size input arguments %%%%%% */
      /*  */
      /* See Matlab documentation for coder.typeof. */
      /*                                                      Example Code                 Upp. Bounds  Var. Size (T/F)  Type */
      /* ROIOutCode                            = coder.typeof( zeros(500, 4, 'int16'),      [inf, 4],    [1, 0] );        %int16 */
      /* ROINoPrevCallsBlockCode               = coder.typeof( zeros(500, 4, 'int16'),      [inf, 4],    [1, 0] );        %int16 */
      /* BlockFullLinIdxCode                   = coder.typeof( zeros(1, 500, 'int32'),      [1, inf],    [0, 1] );        %int32 */
      /* ROIBlockDetectionFaceSkinLogIdxCode   = coder.typeof( false(500, 1),               [inf, 1],    [1, 0] );        %logical  */
      /* ROIBlockCode                          = coder.typeof( zeros(500, 4, 'int16'),      [inf, 4],    [1, 0] );        %int16 */
      /* TimestampBlockCode                    = coder.typeof( zeros(500, 1, 'single'),     [inf, 1],    [1, 0] );        %single   */
      /* TimestampBlockDetectionsCode          = coder.typeof( zeros(500, 1, 'single'),     [inf, 1],    [1, 0] );        %single  */
      /* VideoReadConfig_FrameIdxCode          = coder.typeof( zeros(1, 500, 'uint32'),     [1, inf],    [0, 1] );        %uint32  */
      /*                   */
      /*  */
      /* %%%%% Specify fixed-size input arguments %%%%%% */
      /*  */
      /* ROIGeneralConfig_ROIFinalSmoothingWindowsCode = zeros(1, 2, 'single'); */
      /* ROIGeneralConfig_ROIWidthResizeFactorCode     = double(0); */
      /* ROIGeneralConfig_ROIHeightResizeFactorCode    = double(0); */
      /* VidObjWidthCode                               = int16(0);          */
      /* VidObjHeightCode                              = int16(0); */
      /* FirstReadTFCode                               = false; */
      /* RowToReturnFullLinIdxCode                     = uint32(0); */
      /* RowToReturnBlockLinIdxCode                    = uint32(0); */
      /* FirstFrameMSIRLinIdxCode                      = uint32(0); */
      /*  */
      /*  */
      /* %%%%% Set configurations to increase performance %%%%%% */
      /*  */
      /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
      /* "Optimization Strategies" */
      /* cfg = coder.config('mex'); */
      /* cfg.GlobalDataSyncMethod = 'NoSync'; */
      /* cfg.ConstantInputs = 'IgnoreValues'; */
      /* cfg.ExtrinsicCalls = false; */
      /* cfg.SaturateOnIntegerOverflow = false; */
      /* cfg.IntegrityChecks = false; */
      /* cfg.ResponsivenessChecks = false; */
      /*  */
      /*  */
      /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
      /*  */
      /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
      /*  */
      /* The flags are specified as part of the code-generation configuration object. A custom function, */
      /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
      /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
      /* Matlab guidance found in */
      /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
      /*  */
      /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
      /* a character vector prior to execution of the codegen command. */
      /*  */
      /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
      /*  */
      /* Argument buildInfo: this variable is assign by the caller (the codegen command executed  */
      /* below) and is not present in the base workspace. */
      /*  */
      /* Second argument: specify a cell array of compiler-specific flags, where each flag is a  */
      /* character vector. As function setbuildargs will be evaluated from text, use double ' quotes for  */
      /* each character vector to maintain the charater vector, */
      /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
      /*  */
      /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
      /*  */
      /* Assign to code-generation configuration object */
      /* cfg.PostCodeGenCommand = setbuildargsAsText; */
      /*  */
      /*  */
      /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
      /*  */
      /* codegen ROIMSIR_FrameByFrameSmooth.m -config cfg -args {ROIOutCode, ROINoPrevCallsBlockCode, BlockFullLinIdxCode, ROIBlockDetectionFaceSkinLogIdxCode, ROIBlockCode, TimestampBlockCode, TimestampBlockDetectionsCode, ROIGeneralConfig_ROIFinalSmoothingWindowsCode, ROIGeneralConfig_ROIWidthResizeFactorCode, ROIGeneralConfig_ROIHeightResizeFactorCode, VidObjWidthCode, VidObjHeightCode, FirstReadTFCode, VideoReadConfig_FrameIdxCode, RowToReturnFullLinIdxCode, RowToReturnBlockLinIdxCode, FirstFrameMSIRLinIdxCode} */
      /*               */
      /* } */
      /* Second-read operations post-processing step        */
      /* 1 x 4 row vector; int16. */
      ROIOutNoResize_FR[0] = ROIOut_FR[0];
      ROIOutNoResize_FR[1] = ROIOut_FR[1];
      ROIOutNoResize_FR[2] = ROIOut_FR[2];
      ROIOutNoResize_FR[3] = ROIOut_FR[3];

      /* If at least one ROI within the block corresponds to a detection */
      /* Otherwise, the ROI will have been assigned as the full frame dimensions (see function */
      /* ROIMSIR_InterpolateFR). */
      if (NDetectionsFaceSkin_FR != 0) {
        /* Resize the ROI */
        /* 1 x 4 row vector; int16. */
        /*  ROI(s) to adjust; type int16 */
        /*  ROI index (1 entered if only 1 ROI); */
        /*  type int32. */
        /*  Width resizing scale factor; type */
        /*  double */
        /*  Height resizing scale factor; type */
        /*  double. */
        /*  To keep adjustment within frame */
        /*  dimensions; type int16. */
        yi_ith[0] = ROIOut_FR[0];
        yi_ith[1] = ROIOut_FR[1];
        yi_ith[2] = ROIOut_FR[2];
        yi_ith[3] = ROIOut_FR[3];

        /* ROIResize   Resize ROI(s) according to specifed scaling factors. */
        /*              */
        /*    Helper function to function FacePulseRate. */
        /*    Within function FacePulseRate, called by functions ROIMeans_FirstRead,  */
        /*    ROIMeans_FirstRead_CollectSkinColorSamples, ROIMeans_FirstRead_SetBoundingBoxes,   */
        /*    ROIMeans_SecondRead_SkinDetect, ROIMSIR, ROIMSIR_Interpolate, and ROIMSIR_FrameByFrameSmooth.  */
        /*  */
        /*  */
        /*    Code Generation */
        /*    --------------- */
        /*  */
        /*    Can be called as a Matlab function or used for C-language code generation. */
        /*  */
        /*  */
        /*    Description */
        /*    ----------- */
        /*  */
        /*    Resize the width and height of ROIs (ROI(:, 3 : 4)) of specified frames (ROIsToResizeLinIdx)    */
        /*    by specified scaling factors (ROIWidthResizeFactor and ROIHeightResizeFactor). After modifying  */
        /*    the width and height, adjust the upper-left X- and Y-coordinates (ROI(:, 1 : 2)) so that they */
        /*    are located at half the width and half the height from the unmodified centerpoint; by making  */
        /*    this adjustment, the resizing will have expanded from the centerpoint rather than from the */
        /*    upper-left corner. Then, adjust the ROI values so that none exceed the frame dimensions  */
        /*    (VidObjWidth and VidObjHeight). */
        /*  */
        /*    Inputs: */
        /*  */
        /*       ROI                     = ROI matrix (multiple ROIs) or row vector (one ROI). */
        /*                                 The columns in the ROI matrix or row vector indicate X-upper-left    */
        /*                                 corner, Y-upper-left corner width, and height, in pixels. Note */
        /*                                 that X refers to column indexing and Y refers to row indexing; */
        /*                                 because Y refers to row indexing, Y == 0 is located at the top, */
        /*                                 rather than the bottom, of the plane. */
        /*       ROIsToResizeLinIdx      = Linear index corresponding to the ROI matrix indicating ROIs to */
        /*                                 resize. Index can be non-consecutive. If resizing one ROI (a row */
        /*                                 vector), specify 1 for this argument. */
        /*       ROIWidthResizeFactor    = Width resizing factor. */
        /*       ROIHeightResizeFactor   = Height resizing factor. */
        /*       VidObjWidth             = Frame width (pixels).  */
        /*       VidObjHeight            = Frame height (pixels). */
        /*  */
        /*    Output: */
        /*  */
        /*       ROIResize               = Resized ROI matrix (multiple ROIs) or row vector (one ROI).                                 */
        /*  */
        /*    Note:  */
        /*  */
        /*    Intended only for use with integer types as rounding is not conducted. For modification for use  */
        /*    with floating-point types, rounding would be necessary as ROI values should be integers. */
        /*  */
        /*  */
        /*    Copyright */
        /*    --------- */
        /*  */
        /*    Copyright (c) Douglas Magill (dpmdpm@vt.edu), June, 2020. Licensed under the MIT License and   */
        /*    the Responsible AI License (RAIL). */
        /* %%%%% Input validation %%%%%% */
        /* Validate whether input ROI is type int16. */
        /* Must be an integer type because no rounding is conducted. */
        /* Should be type int16 because the function is implemented to assign values of this type. */
        /* A non-matching type would be due to an implementation error. */
        /* %%%%% Running in code generation %%%%%% */
        /* When running in code generation, use for-loops. When running in Matlab code, use vectorization. */
        /* code generation running */
        /* Inline function */
        /* Preallocate output */
        /* Cast resizing factors to type single for efficiency */
        /* %%%%% --- Resize width(s) and height(s) %%%%%%  */
        /* Convert to index of input ROI */
        Width_ith = (int16_T)muSingleScalarRound((real32_T)yi_ith[2] * (real32_T)
          c_ROIGeneralConfig_ROIWidthResi);
        ROIOut_FR[2] = Width_ith;
        HeightNew_ith = (int16_T)muSingleScalarRound((real32_T)yi_ith[3] *
          (real32_T)c_ROIGeneralConfig_ROIHeightRes);
        ROIOut_FR[3] = HeightNew_ith;

        /* %%%%% Adjust X- and Y-coordinates %%%%%% */
        /* Adjust the upper-left X- and Y-coordinates (ROI(:, 1 : 2)) so that they are located at half the */
        /* width and half the height from the unmodified centerpoint; by making this adjustment, the resizing  */
        /* will have expanded from the centerpoint rather than from the upper-left corner. */
        /* Optimize division by 2 by bit-wise operations. */
        /* Find centerpoint */
        /* Assign new X- and Y-coordinates */
        /* Expand from centerpoint based upon new height and width     */
        ROIOut_FR[0] = (int16_T)((int16_T)(yi_ith[0] + (yi_ith[2] >> 1)) -
          (Width_ith >> 1));
        ROIOut_FR[1] = (int16_T)((int16_T)(yi_ith[1] + (yi_ith[3] >> 1)) -
          (HeightNew_ith >> 1));

        /* %%%%% --- Modify new ROI dimensions that exceed frame dimensions %%%%%%   */
        /* Function ROIAdjustIfExceedsFrameDims verifies if adjusted ROIs are within frame dimensions and, if  */
        /* not, adjusts the ROI values to conform to frame dimensions. */
        /* Note: ROIAdjustIfExceedsFrameDims is a custom function located within folder 'FacePulseRate'. */
        /* ROIAdjustIfExceedsFrameDims   Verify whether proposed widths and heights of ROIs exceed frame  */
        /*                               dimensions and, if so, modify them to conform to frame dimensions. */
        /*                                */
        /*     Helper function to function FacePulseRate. */
        /*     Within function FacePulseRate, called by functions ROIResize, ROIMeans_FirstRead_Extrapolate, */
        /*     SkinDetect_EnlargeROI, ROIMSIR, ROIMSIR_MatchSize, ROIMSIR_DetectionSmooth,   */
        /*     ROIMSIR_Interpolate, and ROIMSIR_FrameByFrameSmooth.    */
        /*  */
        /*  */
        /*     Code Generation */
        /*     --------------- */
        /*  */
        /*     Can be called as a Matlab function or used for C-language code generation. */
        /*  */
        /*  */
        /*     Description */
        /*     ----------- */
        /*  */
        /*     This function verifies that ROIs that have had modifications to their sizes are still within */
        /*     the dimensions of the frame. If not, this function adjusts the dimensions (and, consequently,   */
        /*     the spatial coordinates) to conform to the frame dimensions. */
        /*  */
        /*     Note:  */
        /*  */
        /*     Intended only for use with integer types as rounding is not conducted. For modification for  */
        /*     use with floating-point types, rounding would be necessary as ROI values should be integers. */
        /*  */
        /*  */
        /*     Copyright */
        /*     --------- */
        /*  */
        /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
        /*     the Responsible AI License (RAIL). */
        /* %%%%% Validate inputs %%%%%% */
        /* Exit if empty */
        /* Validate whether input ROIsProposed is type int16. */
        /* Must be an integer type because no rounding is conducted. */
        /* Should be type int16 because the function is implemented to assign values of this type. */
        /* A non-matching type would be due to an implementation error. */
        /* %%%%% Running in code generation %%%%%% */
        /* When running in code generation, use for-loops. When running in Matlab code, use vectorization. */
        /* code generation running */
        /* Inline function */
        /* %%%%% --- Verify, and adjust if necessary, X-coordinates and widths %%%%%% */
        /* Adjust left-side X-coordinate if exceeds frame dimensions: */
        WidthNew_ith = (int16_T)(ROIOut_FR[0] - 1);
        if (ROIOut_FR[0] < 1) {
          WidthNew_ith = 0;

          /* recent code mod */
          ROIOut_FR[0] = 1;
        } else {
          if (ROIOut_FR[0] > VidObjWidth) {
            WidthNew_ith = (int16_T)(VidObjWidth - 1);

            /* recent code mod */
            ROIOut_FR[0] = VidObjWidth;
          }
        }

        /* Adjust right-side X-coordinate if exceeds frame dimensions: */
        Width_ith += WidthNew_ith;
        if (Width_ith > VidObjWidth) {
          Width_ith = VidObjWidth;
          ROIOut_FR[2] = (int16_T)(VidObjWidth - WidthNew_ith);
        } else {
          if (Width_ith < 1) {
            Width_ith = 1;
            WidthNew_ith = 0;
            ROIOut_FR[0] = 1;
            ROIOut_FR[2] = 1;
          }
        }

        /* Adjust width if exceeds frame dimensions: */
        Width_ith -= WidthNew_ith;
        if (Width_ith > VidObjWidth) {
          ROIOut_FR[2] = VidObjWidth;
        } else {
          if (Width_ith < 1) {
            ROIOut_FR[2] = 1;
          }
        }

        /* %%%%% --- Verify, and adjust if necessary, Y-coordinates and heights %%%%%% */
        /* Adjust top-side Y-coordinate if exceeds frame dimensions: */
        Height_ith = (int16_T)(ROIOut_FR[1] - 1);
        if (ROIOut_FR[1] < 1) {
          Height_ith = 0;

          /* recent code mod */
          ROIOut_FR[1] = 1;
        } else {
          if (ROIOut_FR[1] > VidObjHeight) {
            Height_ith = (int16_T)(VidObjHeight - 1);

            /* recent code mod */
            ROIOut_FR[1] = VidObjHeight;
          }
        }

        /* Adjust bottom-side Y-coordinate if exceeds frame dimensions: */
        Width_ith = (int16_T)(Height_ith + HeightNew_ith);
        if (Width_ith > VidObjHeight) {
          Width_ith = VidObjHeight;
          ROIOut_FR[3] = (int16_T)(VidObjHeight - Height_ith);
        } else {
          if (Width_ith < 1) {
            Width_ith = 1;
            Height_ith = 0;
            ROIOut_FR[1] = 1;
            ROIOut_FR[3] = 1;
          }
        }

        /* Adjust height value if exceeds frame dimensions: */
        HeightNew_ith = (int16_T)(Width_ith - Height_ith);
        if (HeightNew_ith > VidObjHeight) {
          ROIOut_FR[3] = VidObjHeight;
        } else {
          if (HeightNew_ith < 1) {
            ROIOut_FR[3] = 1;
          }
        }

        /* %%%%% Code generation not running %%%%%% */
        /* end function */
        /* ============================================================================================= */
        /* Code-generation and build script */
        /* ============================================================================================= */
        /* Code-generation and build script used to generate C-language code and create the compiled version  */
        /* (ROIAdjustIfExceedsFrameDims_mex) of the function. */
        /* { */
        /*  */
        /* %%%%% Specify variable-size input arguments %%%%%% */
        /*  */
        /* See Matlab documentation for coder.typeof. */
        /*  */
        /*                                   Example Code               Upp. Bounds   Var. Size (T/F)  Type */
        /* ROIsProposedCode   = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],     [1, 0] );        %int16 */
        /*            */
        /*        */
        /* %%%%% Specify fixed-size input arguments %%%%%% */
        /*  */
        /* VidObjWidthCode  = int16(0);          */
        /* VidObjHeightCode = int16(0); */
        /*                    */
        /*  */
        /* %%%%% Set configurations to increase performance %%%%%% */
        /*  */
        /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
        /* "Optimization Strategies" */
        /*  */
        /* cfg = coder.config('mex'); */
        /* cfg.GlobalDataSyncMethod = 'NoSync'; */
        /* cfg.ConstantInputs = 'IgnoreValues'; */
        /* cfg.ExtrinsicCalls = true; %permit to show assert error */
        /* cfg.SaturateOnIntegerOverflow = false; */
        /* cfg.IntegrityChecks = false; */
        /* cfg.ResponsivenessChecks = false; */
        /*  */
        /*  */
        /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
        /*  */
        /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
        /*  */
        /* The flags are specified as part of the code-generation configuration object. A custom function, */
        /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
        /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
        /* Matlab guidance found in */
        /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
        /*  */
        /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
        /* a character vector prior to execution of the codegen command. */
        /*  */
        /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
        /*  */
        /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
        /* is not present in the base workspace. */
        /*  */
        /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
        /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
        /* character vector to maintain the charater vector, */
        /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
        /*  */
        /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
        /*  */
        /* Assign to code-generation configuration object */
        /* cfg.PostCodeGenCommand = setbuildargsAsText; */
        /*  */
        /*  */
        /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
        /*  */
        /* codegen ROIAdjustIfExceedsFrameDims.m -report -config cfg -args {ROIsProposedCode, VidObjWidthCode, VidObjHeightCode} */
        /*                  */
        /* } */
        /* %%%%% Code generation not running %%%%%%     */
        /* end function */
        /* ============================================================================================= */
        /* Code-generation and build script */
        /* ============================================================================================= */
        /* Code-generation and build script used to generate C-language code and create the compiled version  */
        /* (ROIResize_mex) of the function. */
        /* { */
        /*  */
        /* %%%%% Specify variable-size input arguments %%%%%% */
        /*  */
        /* See Matlab documentation for coder.typeof. */
        /*  */
        /*                                       Example Code               Upp. Bounds   Var. Size (T/F)  Type */
        /* ROICode                = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],     [1, 0] );        %int16 */
        /* ROIsToResizeLinIdxCode = coder.typeof( zeros(1, 500, 'int32'),   [1, inf],     [0, 1] );        %int32 */
        /*            */
        /*                       */
        /* %%%%% Specify fixed-size input arguments %%%%%% */
        /*  */
        /* ROIWidthResizeFactorCode  = double(0); */
        /* ROIHeightResizeFactorCode = double(0); */
        /* VidObjWidthCode           = int16(0);          */
        /* VidObjHeightCode          = int16(0); */
        /*                    */
        /*  */
        /* %%%%% Set configurations to increase performance %%%%%% */
        /*  */
        /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
        /* "Optimization Strategies" */
        /*  */
        /* cfg = coder.config('mex'); */
        /* cfg.GlobalDataSyncMethod = 'NoSync'; */
        /* cfg.ConstantInputs = 'IgnoreValues'; */
        /* cfg.ExtrinsicCalls = true; %permit to show assert error */
        /* cfg.SaturateOnIntegerOverflow = false; */
        /* cfg.IntegrityChecks = false; */
        /* cfg.ResponsivenessChecks = false; */
        /*  */
        /*  */
        /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
        /*  */
        /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
        /*  */
        /* The flags are specified as part of the code-generation configuration object. A custom function, */
        /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
        /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
        /* Matlab guidance found in */
        /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
        /*  */
        /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
        /* a character vector prior to execution of the codegen command. */
        /*  */
        /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
        /*  */
        /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
        /* is not present in the base workspace. */
        /*  */
        /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
        /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
        /* character vector to maintain the charater vector, */
        /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
        /*  */
        /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
        /*  */
        /* Assign to code-generation configuration object */
        /* cfg.PostCodeGenCommand = setbuildargsAsText; */
        /*  */
        /*  */
        /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
        /*  */
        /* codegen ROIResize.m -report -config cfg -args {ROICode, ROIsToResizeLinIdxCode, ROIWidthResizeFactorCode, ROIHeightResizeFactorCode, VidObjWidthCode, VidObjHeightCode} */
        /*                  */
        /* } */
      }

      /* For call during the second read post-processing step     */
    } else {
      if (SecondReadPostProcessingTF) {
        /* In the second-read operations, smooth ROIs near the beginning of the video based on recent   */
        /* skin-detection algorithm ROI detections made in the second read. To avoid smoothing ROIs    */
        /* twice, only smooth during the post-processing step (not the pre-processing step). */
        /* Note: checking whether the ROI was assigned as the full frame is not needed during the  */
        /* second-read operations because, if that were the case, function ROIMSIR would have already */
        /* exitted before this point is reached (see function ROIMSIR_OutputIfNoDetections_SecondRead). */
        /* Note: during the second-read operations, the following arguments are entered but not used: */
        /* ROINoResizeBlock_FR, VideoReadConfig_FrameIdx_FR, RowToReturnFullLinIdx_FR,   */
        /* RowToReturnBlockLinIdx_FR, ROIMSIR_FirstFrameLinIdx_FR. */
        /* Note: 0 was previously assigned for variables RowToReturnFullLinIdx_FR, */
        /* RowToReturnBlockLinIdx_FR, and ROIMSIR_FirstFrameLinIdx_FR.   */
        /*  M x 4 matrix; type int16 */
        /*  M x 4 matrix; type int16 */
        /* ROIMSIR_FrameByFrameSmooth    Conduct frame-by-frame smoothing of ROIs. */
        /*  */
        /*     Helper function to function FacePulseRate.  */
        /*     Within function FacePulseRate, called by function ROIMSIR. */
        /*  */
        /*  */
        /*     Code Generation */
        /*     --------------- */
        /*  */
        /*     Can be called as a Matlab function or used for C-language code generation. */
        /*  */
        /*  */
        /*     Description */
        /*     ----------- */
        /*   */
        /*     Smooth with nearby frames regardless of whether a face-detection or skin-detection algorithm */
        /*     detection is present in a given nearby frame. That is, include nearby frames even if they have */
        /*     been interpolated or extrapolated rather than contain an ROI from a detection. The objective  */
        /*     is to increase stability in position (X- and Y-coordinates) and size (width and height) */
        /*     across frames. The stability should better reflect actual head movements rather than sudden */
        /*     movements caused by extraneous factors, such as differences in ROIs due to the use of */
        /*     different algorithms or artifacts introduced by the previous smoothing and interpolation  */
        /*     operations. At the same time, over-smoothing should be avoided to allow the ROI to be  */
        /*     responsive to actual head movements across frames. */
        /*  */
        /*     At the point of the current frame, the final ROI values are known only for previous frames  */
        /*     (ROI values before the current frame in ROIBlock). To conduct frame-by-frame smoothing as if   */
        /*     both previous and later ROI values were known, later ROI values are interpolated /  */
        /*     extrapolated for the purpose of frame-by-frame smoothing. Any ROIs values interpolated /   */
        /*     extrapolated for this purpose are not recorded. */
        /*  */
        /*  */
        /*     Copyright */
        /*     --------- */
        /*  */
        /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), September, 2020. Licensed under the MIT License    */
        /*     and the Responsible AI License (RAIL).  */
        /* %%%%% Code-generation settings %%%%%% */
        /* Inline function */
        /* Call function as extrinsic */
        /* See notes where warning() used. */
        /* Call function as extrinsic so that stack trace can be displayed */
        /* Declare variable-size variables: */
        /* Note: constant 229 assumes that the length of BlockFullLinIdx == 229. If the length of this  */
        /* variable were to change, the constant would need to be modified. */
        /*                                                          Upp. Bounds  Var. Size (T/F) */
        /* %%%%% Input validation %%%%%% */
        /* Note: constant 229 assumes that the length of BlockFullLinIdx == 229. If the length of this  */
        /* variable were to change, the constant would need to be modified. If changed to be longer, the   */
        /* bounds on variables FrameByFrameSmoothingWin_XYLinIdx and FrameByFrameSmoothingWin_WHLinIdx should  */
        /* be increased. A low value is currently used to avoid dynamic memory allocation in several  */
        /* variables. The value was determined based upon the maximum length of the frame cache (see function  */
        /* ROIMeans_FirstRead_TakeMeans). An error from these assert statements would likely be due to an */
        /* implementation error because input checking is conducted at the beginning of function */
        /* FacePulseRate. */
        /* %%%%% Specify smoothing windows %%%%%% */
        /* Specify X- and Y-coordinate smoothing window */
        /* Type int32. */
        /* Specify width and height smoothing window */
        /* Type int32. */
        /* Smoothing windows for use in first-read operation: */
        /* Assign half value of smoothing widths for use in some operations */
        /* This is only for convenience; the actual smoothing widths remain the same. */
        /* Type int32. */
        /* %%%%% Assign variables %%%%%% */
        /* First-read operations */
        /* Record ROIs not smoothed by the frame-by-frame smoothing to diagnose false positives or false   */
        /* negatives that may have been caused by this smoothing operation. The ROI coordinates will be  */
        /* superimposed on the output video for assessment. */
        /* Type int16. */
        /* M x 4 matrix; type int16. */
        i = d_ROIOutBeforeFrameByFrameSmoot->size[0] *
          d_ROIOutBeforeFrameByFrameSmoot->size[1];
        d_ROIOutBeforeFrameByFrameSmoot->size[0] = ROIOut_SR->size[0];
        d_ROIOutBeforeFrameByFrameSmoot->size[1] = 4;
        emxEnsureCapacity_int16_T(d_ROIOutBeforeFrameByFrameSmoot, i);
        Sum = ROIOut_SR->size[0] * ROIOut_SR->size[1];
        for (i = 0; i < Sum; i++) {
          d_ROIOutBeforeFrameByFrameSmoot->data[i] = ROIOut_SR->data[i];
        }

        /* Variables unused in second-read operations assigned for code generation purposes: */
        /* Type int32. */
        /* The length of NPrevToCurrentBlockLinIdx. */
        /* Note: constant 115 assumes that RowToReturnBlockLinIdx_FR == 115. If the value of this */
        /* variable were to change, the constant would need to be modified. */
        /* Type int32. */
        /* %%%%% First-read operations %%%%%%    */
        /* Number of rows of ROI matrix */
        VideoReadConfig_FrameIdx_Length = ROIOut_SR->size[0];

        /* Ensure more than one row */
        /* Note: if a smoothing window is larger than rows available, functions MovMean and movmedian */
        /* will adjust to actual length. */
        /* Note: If only one row, Matlab function movmean (not currently used) operates across columns  */
        /* rather than rows, which is not intended.     */
        if (ROIOut_SR->size[0] > 1) {
          /* %%%%% --- Smooth ROI X- and Y-coordinates with moving mean %%%%%% */
          /* M x 4 matrix; type int16.                */
          /* Note: MovMean is a custom function located within folder 'FacePulseRate'. */
          /*  moving-mean window */
          /*  the number or rows of the input matrix */
          /*  the number or columns of the input matrix */
          /* MovMean   Moving mean column-wise smoother. */
          /*  */
          /*     Helper function to function FacePulseRate.  */
          /*     Within function FacePulseRate, called by functions ROIMSIR_DetectionSmooth and */
          /*     ROIMSIR_FrameByFrameSmooth. */
          /*  */
          /*     Code generation:  */
          /*  */
          /*     Can be called as a Matlab function or used for C-language code generation. */
          /*  */
          /*     Description: */
          /*  */
          /*     Use a moving mean to conduct column-wise smoothing to a matrix. Weight rows corresponding to */
          /*     linear index WeightLinIdx by weight Weight. */
          /*  */
          /*     Inputs: */
          /*  */
          /*         ROI          = Matrix of values to be smoothed. M x :4 matrix; type int16.  */
          /*         Win          = Moving-mean window. Scalar; type double. */
          /*         NRowsROI     = The number of rows of the input matrix. Scalar; int32. */
          /*         NColsROI     = The number of columns of the input matrix. Scalar; int32. */
          /*  */
          /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
          /*     the Responsible AI License (RAIL). */
          /* Inline function */
          /* %%%%% Setup %%%%%% */
          /* Take half of window for use during operations */
          Idx = (int32_T)muDoubleScalarRound((real_T)
            c_ROIGeneralConfig_ROIFinalSmoo[0] / 2.0) + 1;

          /* Make the full window equal twice the value of the half-window:  */
          winNew = ((Idx - 1) << 1) + 1;

          /* Assert maximum number of columns to prevent dynamic memory allocation by the colon operator */
          /* Preallocate output */
          i = SmoothedXYColumn->size[0] * SmoothedXYColumn->size[1];
          SmoothedXYColumn->size[0] = ROIOut_SR->size[0];
          SmoothedXYColumn->size[1] = 2;
          emxEnsureCapacity_int16_T(SmoothedXYColumn, i);

          /* %%%%% Reduce size of window if window cannot move %%%%%% */
          if (ROIOut_SR->size[0] <= winNew) {
            /* Take one-fourth of window rather than one-half for use during operations */
            Idx = (int32_T)muDoubleScalarRound((real_T)
              c_ROIGeneralConfig_ROIFinalSmoo[0] / 4.0) + 1;

            /* Make the full window equal twice the value of the half-window:  */
            winNew = ((Idx - 1) << 1) + 1;
          }

          /* %%%%% If window still cannot move %%%%%% */
          if (ROIOut_SR->size[0] <= winNew) {
            /* Loop across columns */
            /* Initialize accumulator */
            Sum = 0;

            /* Sum rows across window           */
            for (j = 0; j < VideoReadConfig_FrameIdx_Length; j++) {
              /* Element cast to type int32. */
              Sum += ROIOut_SR->data[j];
            }

            /* Take the mean */
            Idx = (int32_T)muDoubleScalarRound((real_T)Sum / (real_T)
              ROIOut_SR->size[0]);

            /* Assign the mean to all rows of column i */
            /* Initialize accumulator */
            Sum = 0;

            /* Sum rows across window           */
            for (j = 0; j < VideoReadConfig_FrameIdx_Length; j++) {
              SmoothedXYColumn->data[j] = (int16_T)Idx;

              /* Element cast to type int32. */
              Sum += ROIOut_SR->data[j + ROIOut_SR->size[0]];
            }

            /* Take the mean */
            Idx = (int32_T)muDoubleScalarRound((real_T)Sum / (real_T)
              ROIOut_SR->size[0]);

            /* Assign the mean to all rows of column i */
            for (j = 0; j < VideoReadConfig_FrameIdx_Length; j++) {
              SmoothedXYColumn->data[j + SmoothedXYColumn->size[0]] = (int16_T)
                Idx;
            }

            /* %%%%% If window can move %%%%%%     */
          } else {
            /* Loop across columns */
            i = Idx + 1;
            i1 = ROIOut_SR->size[0] - Idx;
            b_i = (ROIOut_SR->size[0] - Idx) + 2;

            /* Initialize */
            Sum = 0;

            /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
            /* Set intial window end index */
            /* Sum across truncated window           */
            for (j = 0; j < Idx; j++) {
              /* Cast to type int32 and add */
              Sum += ROIOut_SR->data[j];
            }

            /* Take mean */
            if (Idx == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (Idx == 1) {
              z = Sum;
            } else if (Idx == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (Idx >= 0) {
                b_y = (uint32_T)Idx;
              } else {
                b_y = (uint32_T)-Idx;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (Idx < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[0] = (int16_T)z;

            /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
            /* Set initial truncated window length */
            n = Idx;

            /* Loop across rows */
            for (j = 2; j <= Idx; j++) {
              /* Set window end index for jth row */
              /* Add value at end of current window */
              /* Element cast to type int32. */
              Sum += ROIOut_SR->data[(j + Idx) - 2];

              /* Take mean:                 */
              n++;

              /* Mean */
              if (n == 0) {
                if (Sum == 0) {
                  z = 0;
                } else if (Sum < 0) {
                  z = MIN_int32_T;
                } else {
                  z = MAX_int32_T;
                }
              } else if (n == 1) {
                z = Sum;
              } else if (n == -1) {
                z = -Sum;
              } else {
                if (Sum >= 0) {
                  d_x = (uint32_T)Sum;
                } else if (Sum == MIN_int32_T) {
                  d_x = 2147483648U;
                } else {
                  d_x = (uint32_T)-Sum;
                }

                if (n >= 0) {
                  b_y = (uint32_T)n;
                } else if (n == MIN_int32_T) {
                  b_y = 2147483648U;
                } else {
                  b_y = (uint32_T)-n;
                }

                if (b_y == 0U) {
                  q = MAX_uint32_T;
                } else {
                  q = d_x / b_y;
                }

                d_x -= q * b_y;
                if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                  q++;
                }

                z = (int32_T)q;
                if ((Sum < 0) != (n < 0)) {
                  z = -(int32_T)q;
                }
              }

              SmoothedXYColumn->data[j - 1] = (int16_T)z;
            }

            /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
            /* Loop across rows */
            for (j = i; j <= i1 + 1; j++) {
              /* Set window start index for jth row */
              Start = (j - Idx) + 1;

              /* Set window end index for jth row */
              /* Subtract value at start of previous window.  */
              /* Then, add value at end of current window. */
              /* Element cast to type int32. */
              Sum = (Sum - ROIOut_SR->data[Start - 2]) + ROIOut_SR->data[(j +
                Idx) - 2];

              /* Take mean */
              if (winNew == 0) {
                if (Sum == 0) {
                  z = 0;
                } else if (Sum < 0) {
                  z = MIN_int32_T;
                } else {
                  z = MAX_int32_T;
                }
              } else if (winNew == 1) {
                z = Sum;
              } else if (winNew == -1) {
                z = -Sum;
              } else {
                if (Sum >= 0) {
                  d_x = (uint32_T)Sum;
                } else if (Sum == MIN_int32_T) {
                  d_x = 2147483648U;
                } else {
                  d_x = (uint32_T)-Sum;
                }

                if (winNew >= 0) {
                  b_y = (uint32_T)winNew;
                } else if (winNew == MIN_int32_T) {
                  b_y = 2147483648U;
                } else {
                  b_y = (uint32_T)-winNew;
                }

                if (b_y == 0U) {
                  q = MAX_uint32_T;
                } else {
                  q = d_x / b_y;
                }

                d_x -= q * b_y;
                if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                  q++;
                }

                z = (int32_T)q;
                if ((Sum < 0) != (winNew < 0)) {
                  z = -(int32_T)q;
                }
              }

              SmoothedXYColumn->data[j - 1] = (int16_T)z;
            }

            /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
            /* Set intial window length */
            n = winNew;
            Start -= 2;
            for (j = b_i; j <= VideoReadConfig_FrameIdx_Length; j++) {
              Start++;

              /* Subtract value at start of previous window */
              /* Element cast to type int32. */
              Sum -= ROIOut_SR->data[Start - 1];

              /* Take mean:        */
              n--;

              /* Mean */
              if (n == 0) {
                if (Sum == 0) {
                  z = 0;
                } else if (Sum < 0) {
                  z = MIN_int32_T;
                } else {
                  z = MAX_int32_T;
                }
              } else if (n == 1) {
                z = Sum;
              } else if (n == -1) {
                z = -Sum;
              } else {
                if (Sum >= 0) {
                  d_x = (uint32_T)Sum;
                } else if (Sum == MIN_int32_T) {
                  d_x = 2147483648U;
                } else {
                  d_x = (uint32_T)-Sum;
                }

                if (n >= 0) {
                  b_y = (uint32_T)n;
                } else if (n == MIN_int32_T) {
                  b_y = 2147483648U;
                } else {
                  b_y = (uint32_T)-n;
                }

                if (b_y == 0U) {
                  q = MAX_uint32_T;
                } else {
                  q = d_x / b_y;
                }

                d_x -= q * b_y;
                if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                  q++;
                }

                z = (int32_T)q;
                if ((Sum < 0) != (n < 0)) {
                  z = -(int32_T)q;
                }
              }

              SmoothedXYColumn->data[j - 1] = (int16_T)z;
            }

            /* Initialize */
            Sum = 0;

            /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
            /* Set intial window end index */
            /* Sum across truncated window           */
            for (j = 0; j < Idx; j++) {
              /* Cast to type int32 and add */
              Sum += ROIOut_SR->data[j + ROIOut_SR->size[0]];
            }

            /* Take mean */
            if (Idx == 0) {
              if (Sum == 0) {
                z = 0;
              } else if (Sum < 0) {
                z = MIN_int32_T;
              } else {
                z = MAX_int32_T;
              }
            } else if (Idx == 1) {
              z = Sum;
            } else if (Idx == -1) {
              z = -Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              if (Idx >= 0) {
                b_y = (uint32_T)Idx;
              } else {
                b_y = (uint32_T)-Idx;
              }

              if (b_y == 0U) {
                q = MAX_uint32_T;
              } else {
                q = d_x / b_y;
              }

              d_x -= q * b_y;
              if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                q++;
              }

              z = (int32_T)q;
              if ((Sum < 0) != (Idx < 0)) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[SmoothedXYColumn->size[0]] = (int16_T)z;

            /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
            /* Set initial truncated window length */
            n = Idx;

            /* Loop across rows */
            for (j = 2; j <= Idx; j++) {
              /* Set window end index for jth row */
              /* Add value at end of current window */
              /* Element cast to type int32. */
              Sum += ROIOut_SR->data[((j + Idx) + ROIOut_SR->size[0]) - 2];

              /* Take mean:                 */
              n++;

              /* Mean */
              if (n == 0) {
                if (Sum == 0) {
                  z = 0;
                } else if (Sum < 0) {
                  z = MIN_int32_T;
                } else {
                  z = MAX_int32_T;
                }
              } else if (n == 1) {
                z = Sum;
              } else if (n == -1) {
                z = -Sum;
              } else {
                if (Sum >= 0) {
                  d_x = (uint32_T)Sum;
                } else if (Sum == MIN_int32_T) {
                  d_x = 2147483648U;
                } else {
                  d_x = (uint32_T)-Sum;
                }

                if (n >= 0) {
                  b_y = (uint32_T)n;
                } else if (n == MIN_int32_T) {
                  b_y = 2147483648U;
                } else {
                  b_y = (uint32_T)-n;
                }

                if (b_y == 0U) {
                  q = MAX_uint32_T;
                } else {
                  q = d_x / b_y;
                }

                d_x -= q * b_y;
                if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                  q++;
                }

                z = (int32_T)q;
                if ((Sum < 0) != (n < 0)) {
                  z = -(int32_T)q;
                }
              }

              SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
                (int16_T)z;
            }

            /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
            /* Loop across rows */
            for (j = i; j <= i1 + 1; j++) {
              /* Set window start index for jth row */
              Start = (j - Idx) + 1;

              /* Set window end index for jth row */
              /* Subtract value at start of previous window.  */
              /* Then, add value at end of current window. */
              /* Element cast to type int32. */
              Sum = (Sum - ROIOut_SR->data[(Start + ROIOut_SR->size[0]) - 2]) +
                ROIOut_SR->data[((j + Idx) + ROIOut_SR->size[0]) - 2];

              /* Take mean */
              if (winNew == 0) {
                if (Sum == 0) {
                  z = 0;
                } else if (Sum < 0) {
                  z = MIN_int32_T;
                } else {
                  z = MAX_int32_T;
                }
              } else if (winNew == 1) {
                z = Sum;
              } else if (winNew == -1) {
                z = -Sum;
              } else {
                if (Sum >= 0) {
                  d_x = (uint32_T)Sum;
                } else if (Sum == MIN_int32_T) {
                  d_x = 2147483648U;
                } else {
                  d_x = (uint32_T)-Sum;
                }

                if (winNew >= 0) {
                  b_y = (uint32_T)winNew;
                } else if (winNew == MIN_int32_T) {
                  b_y = 2147483648U;
                } else {
                  b_y = (uint32_T)-winNew;
                }

                if (b_y == 0U) {
                  q = MAX_uint32_T;
                } else {
                  q = d_x / b_y;
                }

                d_x -= q * b_y;
                if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                  q++;
                }

                z = (int32_T)q;
                if ((Sum < 0) != (winNew < 0)) {
                  z = -(int32_T)q;
                }
              }

              SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
                (int16_T)z;
            }

            /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
            /* Set intial window length */
            n = winNew;
            Start -= 2;
            for (j = b_i; j <= VideoReadConfig_FrameIdx_Length; j++) {
              Start++;

              /* Subtract value at start of previous window */
              /* Element cast to type int32. */
              Sum -= ROIOut_SR->data[(Start + ROIOut_SR->size[0]) - 1];

              /* Take mean:        */
              n--;

              /* Mean */
              if (n == 0) {
                if (Sum == 0) {
                  z = 0;
                } else if (Sum < 0) {
                  z = MIN_int32_T;
                } else {
                  z = MAX_int32_T;
                }
              } else if (n == 1) {
                z = Sum;
              } else if (n == -1) {
                z = -Sum;
              } else {
                if (Sum >= 0) {
                  d_x = (uint32_T)Sum;
                } else if (Sum == MIN_int32_T) {
                  d_x = 2147483648U;
                } else {
                  d_x = (uint32_T)-Sum;
                }

                if (n >= 0) {
                  b_y = (uint32_T)n;
                } else if (n == MIN_int32_T) {
                  b_y = 2147483648U;
                } else {
                  b_y = (uint32_T)-n;
                }

                if (b_y == 0U) {
                  q = MAX_uint32_T;
                } else {
                  q = d_x / b_y;
                }

                d_x -= q * b_y;
                if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                  q++;
                }

                z = (int32_T)q;
                if ((Sum < 0) != (n < 0)) {
                  z = -(int32_T)q;
                }
              }

              SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
                (int16_T)z;
            }
          }

          /* end function */
          /* ============================================================================================= */
          /* Code-generation and build script */
          /* ============================================================================================= */
          /* Code-generation and build script used to generate C-language code and create the compiled version  */
          /* (MovMean_mex) of the function. */
          /* { */
          /*  */
          /* %%%%% Specify variable-size input arguments %%%%%% */
          /*  */
          /* See Matlab documentation for coder.typeof. */
          /*                         Example Code               Upp. Bounds   Var. Size (T/F)  Type */
          /* ROICode  = coder.typeof( zeros(50, 2, 'int16'),     [500, 2],      [1, 0] );        %int16 */
          /*  */
          /*  */
          /* %%%%% Specify fixed-size input arguments %%%%%% */
          /*  */
          /* winCode = double(0); */
          /* NRowsROI = int32(0); */
          /* NColsROI = int32(0);          */
          /*     */
          /* %%%%% Set configurations to increase performance %%%%%% */
          /*  */
          /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
          /* "Optimization Strategies" */
          /* cfg = coder.config('mex'); */
          /* cfg.GlobalDataSyncMethod = 'NoSync'; */
          /* cfg.ConstantInputs = 'IgnoreValues'; */
          /* cfg.ExtrinsicCalls = false; */
          /* cfg.SaturateOnIntegerOverflow = false; */
          /* cfg.IntegrityChecks = false; */
          /* cfg.ResponsivenessChecks = false; */
          /*  */
          /*  */
          /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
          /*  */
          /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
          /*  */
          /* The flags are specified as part of the code-generation configuration object. A custom function, */
          /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
          /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
          /* Matlab guidance found in */
          /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
          /*  */
          /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
          /* a character vector prior to execution of the codegen command. */
          /*  */
          /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
          /*  */
          /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
          /* is not present in the base workspace. */
          /*  */
          /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
          /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each  */
          /* character vector to maintain the charater vector, */
          /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
          /*  */
          /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
          /*  */
          /* Assign to code-generation configuration object */
          /* cfg.PostCodeGenCommand = setbuildargsAsText; */
          /*  */
          /*  */
          /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
          /*  */
          /* codegen MovMean.m -report -config cfg -args {ROICode, winCode, NRowsROI, NColsROI} */
          /*   */
          /* } */
          Sum = SmoothedXYColumn->size[0];
          for (i = 0; i < Sum; i++) {
            ROIOut_SR->data[i] = SmoothedXYColumn->data[i];
          }

          for (i = 0; i < Sum; i++) {
            ROIOut_SR->data[i + ROIOut_SR->size[0]] = SmoothedXYColumn->data[i +
              SmoothedXYColumn->size[0]];
          }

          /* %%%%% --- Smooth ROI widths and heights %%%%%% */
          /* Assign unsmoothed widths and heights for later step  */
          /* M x 2 matrix; type int16. */
          Sum = ROIOut_SR->size[0];
          i = ROIWidthHeightPreSmooth->size[0] * ROIWidthHeightPreSmooth->size[1];
          ROIWidthHeightPreSmooth->size[0] = ROIOut_SR->size[0];
          ROIWidthHeightPreSmooth->size[1] = 2;
          emxEnsureCapacity_int16_T(ROIWidthHeightPreSmooth, i);

          /* Smooth with moving median to apply strong smoothing to widths and heights: */
          /* M x 4 matrix; type int16. */
          /*  returns type double for integer input; converted to type int16 when assigned */
          /*  moving-median window */
          Idx = ROIOut_SR->size[0];
          i = SmoothedXYColumn->size[0] * SmoothedXYColumn->size[1];
          SmoothedXYColumn->size[0] = ROIOut_SR->size[0];
          SmoothedXYColumn->size[1] = 2;
          emxEnsureCapacity_int16_T(SmoothedXYColumn, i);
          for (i = 0; i < Sum; i++) {
            ROIWidthHeightPreSmooth->data[i] = ROIOut_SR->data[i +
              ROIOut_SR->size[0] * 2];
          }

          for (i = 0; i < Idx; i++) {
            SmoothedXYColumn->data[i] = ROIOut_SR->data[i + ROIOut_SR->size[0] *
              2];
          }

          for (i = 0; i < Sum; i++) {
            ROIWidthHeightPreSmooth->data[i + ROIWidthHeightPreSmooth->size[0]] =
              ROIOut_SR->data[i + ROIOut_SR->size[0] * 3];
          }

          for (i = 0; i < Idx; i++) {
            SmoothedXYColumn->data[i + SmoothedXYColumn->size[0]] =
              ROIOut_SR->data[i + ROIOut_SR->size[0] * 3];
          }

          movmedian(SmoothedXYColumn, c_ROIGeneralConfig_ROIFinalSmoo[1], r);
          Sum = r->size[1];
          for (i = 0; i < Sum; i++) {
            Idx = r->size[0];
            for (i1 = 0; i1 < Idx; i1++) {
              ROIOut_SR->data[i1 + ROIOut_SR->size[0] * (i + 2)] = r->data[i1 +
                r->size[0] * i];
            }
          }

          /* Resmooth widths and heights to remove any sudden jumps:   */
          /* Resmooth to reduce sudden changes due to the moving-median smoothing. */
          /* Use window of 3. */
          /* Smooth with moving mean */
          /* M x 4 matrix; type int16. */
          /* Note: MovMean is a custom function located within folder 'FacePulseRate'. */
          /*  returns type double for integer input; converted to type int16 when assigned */
          /*  moving-mean window */
          /*  the number or rows of the input matrix */
          /*  the number or columns of the input matrix */
          /* MovMean   Moving mean column-wise smoother. */
          /*  */
          /*     Helper function to function FacePulseRate.  */
          /*     Within function FacePulseRate, called by functions ROIMSIR_DetectionSmooth and */
          /*     ROIMSIR_FrameByFrameSmooth. */
          /*  */
          /*     Code generation:  */
          /*  */
          /*     Can be called as a Matlab function or used for C-language code generation. */
          /*  */
          /*     Description: */
          /*  */
          /*     Use a moving mean to conduct column-wise smoothing to a matrix. Weight rows corresponding to */
          /*     linear index WeightLinIdx by weight Weight. */
          /*  */
          /*     Inputs: */
          /*  */
          /*         ROI          = Matrix of values to be smoothed. M x :4 matrix; type int16.  */
          /*         Win          = Moving-mean window. Scalar; type double. */
          /*         NRowsROI     = The number of rows of the input matrix. Scalar; int32. */
          /*         NColsROI     = The number of columns of the input matrix. Scalar; int32. */
          /*  */
          /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
          /*     the Responsible AI License (RAIL). */
          /* Inline function */
          /* %%%%% Setup %%%%%% */
          /* Take half of window for use during operations */
          Idx = 2;

          /* Make the full window equal twice the value of the half-window:  */
          winNew = 3;

          /* Assert maximum number of columns to prevent dynamic memory allocation by the colon operator */
          /* Preallocate output */
          i = SmoothedXYColumn->size[0] * SmoothedXYColumn->size[1];
          SmoothedXYColumn->size[0] = VideoReadConfig_FrameIdx_Length;
          SmoothedXYColumn->size[1] = 2;
          emxEnsureCapacity_int16_T(SmoothedXYColumn, i);

          /* %%%%% Reduce size of window if window cannot move %%%%%% */
          if (VideoReadConfig_FrameIdx_Length <= 3) {
            /* Take one-fourth of window rather than one-half for use during operations */
            Idx = 1;

            /* Make the full window equal twice the value of the half-window:  */
            winNew = 1;
          }

          /* %%%%% If window still cannot move %%%%%% */
          if (VideoReadConfig_FrameIdx_Length <= winNew) {
            /* Loop across columns */
            /* Initialize accumulator */
            Sum = 0;

            /* Sum rows across window           */
            for (j = 0; j < VideoReadConfig_FrameIdx_Length; j++) {
              /* Element cast to type int32. */
              Sum += ROIOut_SR->data[j + ROIOut_SR->size[0] * 2];
            }

            /* Take the mean */
            Idx = (int32_T)muDoubleScalarRound((real_T)Sum / (real_T)
              VideoReadConfig_FrameIdx_Length);

            /* Assign the mean to all rows of column i */
            /* Initialize accumulator */
            Sum = 0;

            /* Sum rows across window           */
            for (j = 0; j < VideoReadConfig_FrameIdx_Length; j++) {
              SmoothedXYColumn->data[j] = (int16_T)Idx;

              /* Element cast to type int32. */
              Sum += ROIOut_SR->data[j + ROIOut_SR->size[0] * 3];
            }

            /* Take the mean */
            Idx = (int32_T)muDoubleScalarRound((real_T)Sum / (real_T)
              VideoReadConfig_FrameIdx_Length);

            /* Assign the mean to all rows of column i */
            for (j = 0; j < VideoReadConfig_FrameIdx_Length; j++) {
              SmoothedXYColumn->data[j + SmoothedXYColumn->size[0]] = (int16_T)
                Idx;
            }

            /* %%%%% If window can move %%%%%%     */
          } else {
            /* Loop across columns */
            i = Idx + 1;
            i1 = VideoReadConfig_FrameIdx_Length - Idx;
            b_i = i1 + 2;

            /* Initialize */
            Sum = 0;

            /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
            /* Set intial window end index */
            /* Sum across truncated window           */
            for (j = 0; j < Idx; j++) {
              /* Cast to type int32 and add */
              Sum += ROIOut_SR->data[j + ROIOut_SR->size[0] * 2];
            }

            /* Take mean */
            if (Idx == 1) {
              z = Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              q = d_x / 2U;
              d_x -= q * 2U;
              if (d_x > 0U) {
                q++;
              }

              z = (int32_T)q;
              if (Sum < 0) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[0] = (int16_T)z;

            /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
            /* Set initial truncated window length */
            n = Idx;

            /* Loop across rows */
            for (j = 2; j <= Idx; j++) {
              /* Set window end index for jth row */
              /* Add value at end of current window */
              /* Element cast to type int32. */
              Sum += ROIOut_SR->data[Idx + ROIOut_SR->size[0] * 2];

              /* Take mean:                 */
              n++;

              /* Mean */
              if (n == 0) {
                if (Sum == 0) {
                  z = 0;
                } else if (Sum < 0) {
                  z = MIN_int32_T;
                } else {
                  z = MAX_int32_T;
                }
              } else if (n == 1) {
                z = Sum;
              } else if (n == -1) {
                z = -Sum;
              } else {
                if (Sum >= 0) {
                  d_x = (uint32_T)Sum;
                } else if (Sum == MIN_int32_T) {
                  d_x = 2147483648U;
                } else {
                  d_x = (uint32_T)-Sum;
                }

                if (n >= 0) {
                  b_y = (uint32_T)n;
                } else if (n == MIN_int32_T) {
                  b_y = 2147483648U;
                } else {
                  b_y = (uint32_T)-n;
                }

                if (b_y == 0U) {
                  q = MAX_uint32_T;
                } else {
                  q = d_x / b_y;
                }

                d_x -= q * b_y;
                if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                  q++;
                }

                z = (int32_T)q;
                if ((Sum < 0) != (n < 0)) {
                  z = -(int32_T)q;
                }
              }

              SmoothedXYColumn->data[1] = (int16_T)z;
            }

            /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
            /* Loop across rows */
            for (j = i; j <= i1 + 1; j++) {
              /* Set window start index for jth row */
              Start = (j - Idx) + 1;

              /* Set window end index for jth row */
              /* Subtract value at start of previous window.  */
              /* Then, add value at end of current window. */
              /* Element cast to type int32. */
              Sum = (Sum - ROIOut_SR->data[(Start + ROIOut_SR->size[0] * 2) - 2])
                + ROIOut_SR->data[((j + Idx) + ROIOut_SR->size[0] * 2) - 2];

              /* Take mean */
              if (winNew == 1) {
                z = Sum;
              } else {
                if (Sum >= 0) {
                  d_x = (uint32_T)Sum;
                } else if (Sum == MIN_int32_T) {
                  d_x = 2147483648U;
                } else {
                  d_x = (uint32_T)-Sum;
                }

                q = d_x / winNew;
                d_x -= q * winNew;
                if ((d_x > 0U) && (d_x >= (winNew & 1U) + 1U)) {
                  q++;
                }

                z = (int32_T)q;
                if (Sum < 0) {
                  z = -(int32_T)q;
                }
              }

              SmoothedXYColumn->data[j - 1] = (int16_T)z;
            }

            /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
            /* Set intial window length */
            n = winNew;
            Start -= 2;
            for (j = b_i; j <= VideoReadConfig_FrameIdx_Length; j++) {
              Start++;

              /* Subtract value at start of previous window */
              /* Element cast to type int32. */
              Sum -= ROIOut_SR->data[(Start + ROIOut_SR->size[0] * 2) - 1];

              /* Take mean:        */
              n--;

              /* Mean */
              if (n == 0) {
                if (Sum == 0) {
                  z = 0;
                } else if (Sum < 0) {
                  z = MIN_int32_T;
                } else {
                  z = MAX_int32_T;
                }
              } else if (n == 1) {
                z = Sum;
              } else if (n == -1) {
                z = -Sum;
              } else {
                if (Sum >= 0) {
                  d_x = (uint32_T)Sum;
                } else if (Sum == MIN_int32_T) {
                  d_x = 2147483648U;
                } else {
                  d_x = (uint32_T)-Sum;
                }

                if (n >= 0) {
                  b_y = (uint32_T)n;
                } else if (n == MIN_int32_T) {
                  b_y = 2147483648U;
                } else {
                  b_y = (uint32_T)-n;
                }

                if (b_y == 0U) {
                  q = MAX_uint32_T;
                } else {
                  q = d_x / b_y;
                }

                d_x -= q * b_y;
                if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                  q++;
                }

                z = (int32_T)q;
                if ((Sum < 0) != (n < 0)) {
                  z = -(int32_T)q;
                }
              }

              SmoothedXYColumn->data[j - 1] = (int16_T)z;
            }

            /* Initialize */
            Sum = 0;

            /* %%%%% --- Apply moving mean to row 1 %%%%%%         */
            /* Set intial window end index */
            /* Sum across truncated window           */
            for (j = 0; j < Idx; j++) {
              /* Cast to type int32 and add */
              Sum += ROIOut_SR->data[j + ROIOut_SR->size[0] * 3];
            }

            /* Take mean */
            if (Idx == 1) {
              z = Sum;
            } else {
              if (Sum >= 0) {
                d_x = (uint32_T)Sum;
              } else if (Sum == MIN_int32_T) {
                d_x = 2147483648U;
              } else {
                d_x = (uint32_T)-Sum;
              }

              q = d_x / 2U;
              d_x -= q * 2U;
              if (d_x > 0U) {
                q++;
              }

              z = (int32_T)q;
              if (Sum < 0) {
                z = -(int32_T)q;
              }
            }

            SmoothedXYColumn->data[SmoothedXYColumn->size[0]] = (int16_T)z;

            /* %%%%% --- Apply moving mean up to first row where full window can be used %%%%%% */
            /* Set initial truncated window length */
            n = Idx;

            /* Loop across rows */
            for (j = 2; j <= Idx; j++) {
              /* Set window end index for jth row */
              /* Add value at end of current window */
              /* Element cast to type int32. */
              Sum += ROIOut_SR->data[Idx + ROIOut_SR->size[0] * 3];

              /* Take mean:                 */
              n++;

              /* Mean */
              if (n == 0) {
                if (Sum == 0) {
                  z = 0;
                } else if (Sum < 0) {
                  z = MIN_int32_T;
                } else {
                  z = MAX_int32_T;
                }
              } else if (n == 1) {
                z = Sum;
              } else if (n == -1) {
                z = -Sum;
              } else {
                if (Sum >= 0) {
                  d_x = (uint32_T)Sum;
                } else if (Sum == MIN_int32_T) {
                  d_x = 2147483648U;
                } else {
                  d_x = (uint32_T)-Sum;
                }

                if (n >= 0) {
                  b_y = (uint32_T)n;
                } else if (n == MIN_int32_T) {
                  b_y = 2147483648U;
                } else {
                  b_y = (uint32_T)-n;
                }

                if (b_y == 0U) {
                  q = MAX_uint32_T;
                } else {
                  q = d_x / b_y;
                }

                d_x -= q * b_y;
                if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                  q++;
                }

                z = (int32_T)q;
                if ((Sum < 0) != (n < 0)) {
                  z = -(int32_T)q;
                }
              }

              SmoothedXYColumn->data[SmoothedXYColumn->size[0] + 1] = (int16_T)z;
            }

            /* %%%%% --- Apply moving mean for rows where full window can be used %%%%%%  */
            /* Loop across rows */
            for (j = i; j <= i1 + 1; j++) {
              /* Set window start index for jth row */
              Start = (j - Idx) + 1;

              /* Set window end index for jth row */
              /* Subtract value at start of previous window.  */
              /* Then, add value at end of current window. */
              /* Element cast to type int32. */
              Sum = (Sum - ROIOut_SR->data[(Start + ROIOut_SR->size[0] * 3) - 2])
                + ROIOut_SR->data[((j + Idx) + ROIOut_SR->size[0] * 3) - 2];

              /* Take mean */
              if (winNew == 1) {
                z = Sum;
              } else {
                if (Sum >= 0) {
                  d_x = (uint32_T)Sum;
                } else if (Sum == MIN_int32_T) {
                  d_x = 2147483648U;
                } else {
                  d_x = (uint32_T)-Sum;
                }

                q = d_x / winNew;
                d_x -= q * winNew;
                if ((d_x > 0U) && (d_x >= (winNew & 1U) + 1U)) {
                  q++;
                }

                z = (int32_T)q;
                if (Sum < 0) {
                  z = -(int32_T)q;
                }
              }

              SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
                (int16_T)z;
            }

            /* %%%%% --- Apply moving mean for rows near end where full window cannot be used %%%%%% */
            /* Set intial window length */
            n = winNew;
            Start -= 2;
            for (j = b_i; j <= VideoReadConfig_FrameIdx_Length; j++) {
              Start++;

              /* Subtract value at start of previous window */
              /* Element cast to type int32. */
              Sum -= ROIOut_SR->data[(Start + ROIOut_SR->size[0] * 3) - 1];

              /* Take mean:        */
              n--;

              /* Mean */
              if (n == 0) {
                if (Sum == 0) {
                  z = 0;
                } else if (Sum < 0) {
                  z = MIN_int32_T;
                } else {
                  z = MAX_int32_T;
                }
              } else if (n == 1) {
                z = Sum;
              } else if (n == -1) {
                z = -Sum;
              } else {
                if (Sum >= 0) {
                  d_x = (uint32_T)Sum;
                } else if (Sum == MIN_int32_T) {
                  d_x = 2147483648U;
                } else {
                  d_x = (uint32_T)-Sum;
                }

                if (n >= 0) {
                  b_y = (uint32_T)n;
                } else if (n == MIN_int32_T) {
                  b_y = 2147483648U;
                } else {
                  b_y = (uint32_T)-n;
                }

                if (b_y == 0U) {
                  q = MAX_uint32_T;
                } else {
                  q = d_x / b_y;
                }

                d_x -= q * b_y;
                if ((d_x > 0U) && (d_x >= (b_y >> 1U) + (b_y & 1U))) {
                  q++;
                }

                z = (int32_T)q;
                if ((Sum < 0) != (n < 0)) {
                  z = -(int32_T)q;
                }
              }

              SmoothedXYColumn->data[(j + SmoothedXYColumn->size[0]) - 1] =
                (int16_T)z;
            }
          }

          /* end function */
          /* ============================================================================================= */
          /* Code-generation and build script */
          /* ============================================================================================= */
          /* Code-generation and build script used to generate C-language code and create the compiled version  */
          /* (MovMean_mex) of the function. */
          /* { */
          /*  */
          /* %%%%% Specify variable-size input arguments %%%%%% */
          /*  */
          /* See Matlab documentation for coder.typeof. */
          /*                         Example Code               Upp. Bounds   Var. Size (T/F)  Type */
          /* ROICode  = coder.typeof( zeros(50, 2, 'int16'),     [500, 2],      [1, 0] );        %int16 */
          /*  */
          /*  */
          /* %%%%% Specify fixed-size input arguments %%%%%% */
          /*  */
          /* winCode = double(0); */
          /* NRowsROI = int32(0); */
          /* NColsROI = int32(0);          */
          /*     */
          /* %%%%% Set configurations to increase performance %%%%%% */
          /*  */
          /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
          /* "Optimization Strategies" */
          /* cfg = coder.config('mex'); */
          /* cfg.GlobalDataSyncMethod = 'NoSync'; */
          /* cfg.ConstantInputs = 'IgnoreValues'; */
          /* cfg.ExtrinsicCalls = false; */
          /* cfg.SaturateOnIntegerOverflow = false; */
          /* cfg.IntegrityChecks = false; */
          /* cfg.ResponsivenessChecks = false; */
          /*  */
          /*  */
          /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
          /*  */
          /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
          /*  */
          /* The flags are specified as part of the code-generation configuration object. A custom function, */
          /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
          /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
          /* Matlab guidance found in */
          /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
          /*  */
          /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
          /* a character vector prior to execution of the codegen command. */
          /*  */
          /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
          /*  */
          /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
          /* is not present in the base workspace. */
          /*  */
          /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
          /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each  */
          /* character vector to maintain the charater vector, */
          /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
          /*  */
          /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
          /*  */
          /* Assign to code-generation configuration object */
          /* cfg.PostCodeGenCommand = setbuildargsAsText; */
          /*  */
          /*  */
          /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
          /*  */
          /* codegen MovMean.m -report -config cfg -args {ROICode, winCode, NRowsROI, NColsROI} */
          /*   */
          /* } */
          Sum = SmoothedXYColumn->size[0];
          for (i = 0; i < Sum; i++) {
            ROIOut_SR->data[i + ROIOut_SR->size[0] * 2] = SmoothedXYColumn->
              data[i];
          }

          for (i = 0; i < Sum; i++) {
            ROIOut_SR->data[i + ROIOut_SR->size[0] * 3] = SmoothedXYColumn->
              data[i + SmoothedXYColumn->size[0]];
          }

          /* %%%%% --- Adjust X- and Y-coordinates to correspond to adjustments in widths and heights %%%%%%   */
          /* Difference between unsmoothed widths and heights and smoothed widths and heights  */
          /* M x 2 matrix; type int16. */
          /* Take half of the differences */
          /* M x 2 matrix; type int16. */
          /* Optimized by bit-wise division. */
          /* Non-bitwise: WidthHeightDiff = WidthHeightDiff / int16(2); */
          /* Add the half-differences to the X- and Y-coordinates */
          /* M x 4 matrix; type int16. */
          /* Note: if there were negative differences, the half-differences will be subtracted from the */
          /* X- and Y-coordinates. */
          i = SmoothedXYColumn->size[0] * SmoothedXYColumn->size[1];
          SmoothedXYColumn->size[0] = ROIWidthHeightPreSmooth->size[0];
          SmoothedXYColumn->size[1] = 2;
          emxEnsureCapacity_int16_T(SmoothedXYColumn, i);
          Sum = ROIWidthHeightPreSmooth->size[0];
          for (i = 0; i < Sum; i++) {
            Width_ith = (int16_T)(ROIWidthHeightPreSmooth->data[i] -
                                  ROIOut_SR->data[i + ROIOut_SR->size[0] * 2]);
            SmoothedXYColumn->data[i] = (int16_T)(Width_ith >> 1);
          }

          for (i = 0; i < Sum; i++) {
            Width_ith = (int16_T)(ROIWidthHeightPreSmooth->data[i +
                                  ROIWidthHeightPreSmooth->size[0]] -
                                  ROIOut_SR->data[i + ROIOut_SR->size[0] * 3]);
            SmoothedXYColumn->data[i + SmoothedXYColumn->size[0]] = (int16_T)
              (Width_ith >> 1);
          }

          winNew = ROIOut_SR->size[0] - 1;
          i = SmoothedXYColumn->size[0] * SmoothedXYColumn->size[1];
          SmoothedXYColumn->size[0] = ROIOut_SR->size[0];
          SmoothedXYColumn->size[1] = 2;
          emxEnsureCapacity_int16_T(SmoothedXYColumn, i);
          for (i = 0; i <= winNew; i++) {
            SmoothedXYColumn->data[i] += ROIOut_SR->data[i];
          }

          for (i = 0; i <= winNew; i++) {
            SmoothedXYColumn->data[i + SmoothedXYColumn->size[0]] +=
              ROIOut_SR->data[i + ROIOut_SR->size[0]];
          }

          Sum = SmoothedXYColumn->size[0];
          for (i = 0; i < Sum; i++) {
            ROIOut_SR->data[i] = SmoothedXYColumn->data[i];
          }

          for (i = 0; i < Sum; i++) {
            ROIOut_SR->data[i + ROIOut_SR->size[0]] = SmoothedXYColumn->data[i +
              SmoothedXYColumn->size[0]];
          }
        }

        /* %%%%% Adjust ROI(s) that exceed frame dimensions %%%%%%     */
        /* Although it may seem unlikely for the smoothing of ROIs to result in values outside of frame */
        /* dimensions, this might occur when, for example, both the width and the X-coordinate increased or  */
        /* both the height and the Y-coordinate increased. */
        /* First-read operations */
        /* M x 4 matrix; type int16. */
        /* Note: ROIAdjustIfExceedsFrameDims is a custom function located within folder 'FacePulseRate'. */
        /* ROIAdjustIfExceedsFrameDims   Verify whether proposed widths and heights of ROIs exceed frame  */
        /*                               dimensions and, if so, modify them to conform to frame dimensions. */
        /*                                */
        /*     Helper function to function FacePulseRate. */
        /*     Within function FacePulseRate, called by functions ROIResize, ROIMeans_FirstRead_Extrapolate, */
        /*     SkinDetect_EnlargeROI, ROIMSIR, ROIMSIR_MatchSize, ROIMSIR_DetectionSmooth,   */
        /*     ROIMSIR_Interpolate, and ROIMSIR_FrameByFrameSmooth.    */
        /*  */
        /*  */
        /*     Code Generation */
        /*     --------------- */
        /*  */
        /*     Can be called as a Matlab function or used for C-language code generation. */
        /*  */
        /*  */
        /*     Description */
        /*     ----------- */
        /*  */
        /*     This function verifies that ROIs that have had modifications to their sizes are still within */
        /*     the dimensions of the frame. If not, this function adjusts the dimensions (and, consequently,   */
        /*     the spatial coordinates) to conform to the frame dimensions. */
        /*  */
        /*     Note:  */
        /*  */
        /*     Intended only for use with integer types as rounding is not conducted. For modification for  */
        /*     use with floating-point types, rounding would be necessary as ROI values should be integers. */
        /*  */
        /*  */
        /*     Copyright */
        /*     --------- */
        /*  */
        /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
        /*     the Responsible AI License (RAIL). */
        /* %%%%% Validate inputs %%%%%% */
        /* Exit if empty */
        if (ROIOut_SR->size[0] != 0) {
          /* Validate whether input ROIsProposed is type int16. */
          /* Must be an integer type because no rounding is conducted. */
          /* Should be type int16 because the function is implemented to assign values of this type. */
          /* A non-matching type would be due to an implementation error. */
          /* %%%%% Running in code generation %%%%%% */
          /* When running in code generation, use for-loops. When running in Matlab code, use vectorization. */
          /* code generation running */
          /* Inline function */
          i = ROIOut_SR->size[0];
          for (b_i = 0; b_i < i; b_i++) {
            /* %%%%% --- Verify, and adjust if necessary, X-coordinates and widths %%%%%% */
            /* Adjust left-side X-coordinate if exceeds frame dimensions: */
            WidthNew_ith = ROIOut_SR->data[b_i];
            if (WidthNew_ith < 1) {
              WidthNew_ith = 1;

              /* recent code mod */
              ROIOut_SR->data[b_i] = 1;
            } else {
              if (WidthNew_ith > VidObjWidth) {
                WidthNew_ith = VidObjWidth;

                /* recent code mod */
                ROIOut_SR->data[b_i] = VidObjWidth;
              }
            }

            /* Adjust right-side X-coordinate if exceeds frame dimensions: */
            Width_ith = (int16_T)((int16_T)(WidthNew_ith + ROIOut_SR->data[b_i +
              ROIOut_SR->size[0] * 2]) - 1);
            if (Width_ith > VidObjWidth) {
              Width_ith = VidObjWidth;
              ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 2] = (int16_T)((int16_T)
                (VidObjWidth - WidthNew_ith) + 1);
            } else {
              if (Width_ith < 1) {
                Width_ith = 1;
                WidthNew_ith = 1;
                ROIOut_SR->data[b_i] = 1;
                ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 2] = 1;
              }
            }

            /* Adjust width if exceeds frame dimensions: */
            Width_ith = (int16_T)((int16_T)(Width_ith - WidthNew_ith) + 1);
            if (Width_ith > VidObjWidth) {
              ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 2] = VidObjWidth;
            } else {
              if (Width_ith < 1) {
                ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 2] = 1;
              }
            }

            /* %%%%% --- Verify, and adjust if necessary, Y-coordinates and heights %%%%%% */
            /* Adjust top-side Y-coordinate if exceeds frame dimensions: */
            Height_ith = ROIOut_SR->data[b_i + ROIOut_SR->size[0]];
            if (Height_ith < 1) {
              Height_ith = 1;

              /* recent code mod */
              ROIOut_SR->data[b_i + ROIOut_SR->size[0]] = 1;
            } else {
              if (Height_ith > VidObjHeight) {
                Height_ith = VidObjHeight;

                /* recent code mod */
                ROIOut_SR->data[b_i + ROIOut_SR->size[0]] = VidObjHeight;
              }
            }

            /* Adjust bottom-side Y-coordinate if exceeds frame dimensions: */
            Width_ith = (int16_T)((int16_T)(Height_ith + ROIOut_SR->data[b_i +
              ROIOut_SR->size[0] * 3]) - 1);
            if (Width_ith > VidObjHeight) {
              Width_ith = VidObjHeight;
              ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 3] = (int16_T)((int16_T)
                (VidObjHeight - Height_ith) + 1);
            } else {
              if (Width_ith < 1) {
                Width_ith = 1;
                Height_ith = 1;
                ROIOut_SR->data[b_i + ROIOut_SR->size[0]] = 1;
                ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 3] = 1;
              }
            }

            /* Adjust height value if exceeds frame dimensions: */
            HeightNew_ith = (int16_T)((int16_T)(Width_ith - Height_ith) + 1);
            if (HeightNew_ith > VidObjHeight) {
              ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 3] = VidObjHeight;
            } else {
              if (HeightNew_ith < 1) {
                ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 3] = 1;
              }
            }
          }

          /* %%%%% Code generation not running %%%%%% */
        } else {
          /* Exit function */
        }

        /* end function */
        /* ============================================================================================= */
        /* Code-generation and build script */
        /* ============================================================================================= */
        /* Code-generation and build script used to generate C-language code and create the compiled version  */
        /* (ROIAdjustIfExceedsFrameDims_mex) of the function. */
        /* { */
        /*  */
        /* %%%%% Specify variable-size input arguments %%%%%% */
        /*  */
        /* See Matlab documentation for coder.typeof. */
        /*  */
        /*                                   Example Code               Upp. Bounds   Var. Size (T/F)  Type */
        /* ROIsProposedCode   = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],     [1, 0] );        %int16 */
        /*            */
        /*        */
        /* %%%%% Specify fixed-size input arguments %%%%%% */
        /*  */
        /* VidObjWidthCode  = int16(0);          */
        /* VidObjHeightCode = int16(0); */
        /*                    */
        /*  */
        /* %%%%% Set configurations to increase performance %%%%%% */
        /*  */
        /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
        /* "Optimization Strategies" */
        /*  */
        /* cfg = coder.config('mex'); */
        /* cfg.GlobalDataSyncMethod = 'NoSync'; */
        /* cfg.ConstantInputs = 'IgnoreValues'; */
        /* cfg.ExtrinsicCalls = true; %permit to show assert error */
        /* cfg.SaturateOnIntegerOverflow = false; */
        /* cfg.IntegrityChecks = false; */
        /* cfg.ResponsivenessChecks = false; */
        /*  */
        /*  */
        /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
        /*  */
        /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
        /*  */
        /* The flags are specified as part of the code-generation configuration object. A custom function, */
        /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
        /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
        /* Matlab guidance found in */
        /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
        /*  */
        /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
        /* a character vector prior to execution of the codegen command. */
        /*  */
        /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
        /*  */
        /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
        /* is not present in the base workspace. */
        /*  */
        /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
        /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
        /* character vector to maintain the charater vector, */
        /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
        /*  */
        /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
        /*  */
        /* Assign to code-generation configuration object */
        /* cfg.PostCodeGenCommand = setbuildargsAsText; */
        /*  */
        /*  */
        /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
        /*  */
        /* codegen ROIAdjustIfExceedsFrameDims.m -report -config cfg -args {ROIsProposedCode, VidObjWidthCode, VidObjHeightCode} */
        /*                  */
        /* } */
        /* %%%%% Output validation %%%%%% */
        /* For first-read operations */
        /* Check whether the size of any ROI is unreasonably small */
        /* Such a small size is likely due to an implementation error in this function. */
        /* This check is intended to be run when testing new implementations, as small ROI sizes are an */
        /* indication of a implementation error. As occassional values below 20 may be considered */
        /* acceptable, this check is not intended for use outside of testing. "Occassional" in this case    */
        /* might be defined as a few occurances out of 10,000. Flag ExpectedBehaviorTestTF enables the */
        /* check.     */
        guard3 = false;
        if (ExpectedBehaviorTestTF) {
          Sum = ROIOut_SR->size[0];
          i = b_HasROI_TF->size[0];
          b_HasROI_TF->size[0] = ROIOut_SR->size[0];
          emxEnsureCapacity_boolean_T(b_HasROI_TF, i);
          for (i = 0; i < Sum; i++) {
            b_HasROI_TF->data[i] = (ROIOut_SR->data[i + ROIOut_SR->size[0] * 2] <
              20);
          }

          if (any(b_HasROI_TF)) {
            /* Display warning */
            /* Note: function warning() not available for code generation, so it must have previously */
            /* been declared as extrinsic. */
            warning(emlrt_marshallOut(cv3), l_emlrt_marshallOut(cv42),
                    &y_emlrtMCI);
          } else {
            guard3 = true;
          }
        } else {
          guard3 = true;
        }

        if (guard3) {
          Sum = ROIOut_SR->size[0];
          i = b_HasROI_TF->size[0];
          b_HasROI_TF->size[0] = ROIOut_SR->size[0];
          emxEnsureCapacity_boolean_T(b_HasROI_TF, i);
          for (i = 0; i < Sum; i++) {
            b_HasROI_TF->data[i] = (ROIOut_SR->data[i + ROIOut_SR->size[0] * 3] <
              20);
          }

          if (any(b_HasROI_TF)) {
            /* Display warning */
            /* Note: function warning() not available for code generation, so it must have previously */
            /* been declared as extrinsic. */
            warning(emlrt_marshallOut(cv3), l_emlrt_marshallOut(cv42),
                    &y_emlrtMCI);
          }
        }

        /* Check if ROI type not int16 because other functions are implemented to accept values of this  */
        /* type.  */
        /* A non-matching type would be due to an implementation error. */
        /* end function */
        /* ============================================================================================= */
        /* Code-generation and build script */
        /* ============================================================================================= */
        /* Note: this function is not currently used as a compiled function as it is nested within a */
        /* compiled function, ROIMSIR_mex. */
        /* Code-generation and build script used to generate C-language code and create the compiled version  */
        /* (ROIMSIR_FrameByFrameSmooth_mex) of the function. */
        /* { */
        /*  */
        /*  */
        /* %%%%% Specify variable-size input arguments %%%%%% */
        /*  */
        /* See Matlab documentation for coder.typeof. */
        /*                                                      Example Code                 Upp. Bounds  Var. Size (T/F)  Type */
        /* ROIOutCode                            = coder.typeof( zeros(500, 4, 'int16'),      [inf, 4],    [1, 0] );        %int16 */
        /* ROINoPrevCallsBlockCode               = coder.typeof( zeros(500, 4, 'int16'),      [inf, 4],    [1, 0] );        %int16 */
        /* BlockFullLinIdxCode                   = coder.typeof( zeros(1, 500, 'int32'),      [1, inf],    [0, 1] );        %int32 */
        /* ROIBlockDetectionFaceSkinLogIdxCode   = coder.typeof( false(500, 1),               [inf, 1],    [1, 0] );        %logical  */
        /* ROIBlockCode                          = coder.typeof( zeros(500, 4, 'int16'),      [inf, 4],    [1, 0] );        %int16 */
        /* TimestampBlockCode                    = coder.typeof( zeros(500, 1, 'single'),     [inf, 1],    [1, 0] );        %single   */
        /* TimestampBlockDetectionsCode          = coder.typeof( zeros(500, 1, 'single'),     [inf, 1],    [1, 0] );        %single  */
        /* VideoReadConfig_FrameIdxCode          = coder.typeof( zeros(1, 500, 'uint32'),     [1, inf],    [0, 1] );        %uint32  */
        /*                   */
        /*  */
        /* %%%%% Specify fixed-size input arguments %%%%%% */
        /*  */
        /* ROIGeneralConfig_ROIFinalSmoothingWindowsCode = zeros(1, 2, 'single'); */
        /* ROIGeneralConfig_ROIWidthResizeFactorCode     = double(0); */
        /* ROIGeneralConfig_ROIHeightResizeFactorCode    = double(0); */
        /* VidObjWidthCode                               = int16(0);          */
        /* VidObjHeightCode                              = int16(0); */
        /* FirstReadTFCode                               = false; */
        /* RowToReturnFullLinIdxCode                     = uint32(0); */
        /* RowToReturnBlockLinIdxCode                    = uint32(0); */
        /* FirstFrameMSIRLinIdxCode                      = uint32(0); */
        /*  */
        /*  */
        /* %%%%% Set configurations to increase performance %%%%%% */
        /*  */
        /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
        /* "Optimization Strategies" */
        /* cfg = coder.config('mex'); */
        /* cfg.GlobalDataSyncMethod = 'NoSync'; */
        /* cfg.ConstantInputs = 'IgnoreValues'; */
        /* cfg.ExtrinsicCalls = false; */
        /* cfg.SaturateOnIntegerOverflow = false; */
        /* cfg.IntegrityChecks = false; */
        /* cfg.ResponsivenessChecks = false; */
        /*  */
        /*  */
        /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
        /*  */
        /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
        /*  */
        /* The flags are specified as part of the code-generation configuration object. A custom function, */
        /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
        /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
        /* Matlab guidance found in */
        /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
        /*  */
        /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
        /* a character vector prior to execution of the codegen command. */
        /*  */
        /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
        /*  */
        /* Argument buildInfo: this variable is assign by the caller (the codegen command executed  */
        /* below) and is not present in the base workspace. */
        /*  */
        /* Second argument: specify a cell array of compiler-specific flags, where each flag is a  */
        /* character vector. As function setbuildargs will be evaluated from text, use double ' quotes for  */
        /* each character vector to maintain the charater vector, */
        /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
        /*  */
        /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
        /*  */
        /* Assign to code-generation configuration object */
        /* cfg.PostCodeGenCommand = setbuildargsAsText; */
        /*  */
        /*  */
        /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
        /*  */
        /* codegen ROIMSIR_FrameByFrameSmooth.m -config cfg -args {ROIOutCode, ROINoPrevCallsBlockCode, BlockFullLinIdxCode, ROIBlockDetectionFaceSkinLogIdxCode, ROIBlockCode, TimestampBlockCode, TimestampBlockDetectionsCode, ROIGeneralConfig_ROIFinalSmoothingWindowsCode, ROIGeneralConfig_ROIWidthResizeFactorCode, ROIGeneralConfig_ROIHeightResizeFactorCode, VidObjWidthCode, VidObjHeightCode, FirstReadTFCode, VideoReadConfig_FrameIdxCode, RowToReturnFullLinIdxCode, RowToReturnBlockLinIdxCode, FirstFrameMSIRLinIdxCode} */
        /*               */
        /* } */
        /* Note: checking whether the ROI was assigned as the full frame is not needed during the  */
        /* second-read operations because, if that were the case, function ROIMSIR would have already */
        /* exitted before this point is reached (see function ROIMSIR_OutputIfNoDetections_SecondRead).        */
        eml_signed_integer_colon(ROIOut_SR->size[0], FramesToAdjust);

        /* Resize the ROI */
        /* M x 4 matrix; int16. */
        /*  ROI(s) to adjust; type int16 */
        /*  ROI index (1 entered if only 1 ROI); */
        /*  type int32. */
        /*  Width resizing scale factor; type */
        /*  double. */
        /*  Height resizing scale factor; type */
        /*  double. */
        /*  To keep adjustment within frame */
        /*  dimensions; type int16. */
        i = ROIBlockFaceSkin_Temp->size[0] * ROIBlockFaceSkin_Temp->size[1];
        ROIBlockFaceSkin_Temp->size[0] = ROIOut_SR->size[0];
        ROIBlockFaceSkin_Temp->size[1] = 4;
        emxEnsureCapacity_int16_T(ROIBlockFaceSkin_Temp, i);
        Sum = ROIOut_SR->size[0] * ROIOut_SR->size[1];
        for (i = 0; i < Sum; i++) {
          ROIBlockFaceSkin_Temp->data[i] = ROIOut_SR->data[i];
        }

        /* ROIResize   Resize ROI(s) according to specifed scaling factors. */
        /*              */
        /*    Helper function to function FacePulseRate. */
        /*    Within function FacePulseRate, called by functions ROIMeans_FirstRead,  */
        /*    ROIMeans_FirstRead_CollectSkinColorSamples, ROIMeans_FirstRead_SetBoundingBoxes,   */
        /*    ROIMeans_SecondRead_SkinDetect, ROIMSIR, ROIMSIR_Interpolate, and ROIMSIR_FrameByFrameSmooth.  */
        /*  */
        /*  */
        /*    Code Generation */
        /*    --------------- */
        /*  */
        /*    Can be called as a Matlab function or used for C-language code generation. */
        /*  */
        /*  */
        /*    Description */
        /*    ----------- */
        /*  */
        /*    Resize the width and height of ROIs (ROI(:, 3 : 4)) of specified frames (ROIsToResizeLinIdx)    */
        /*    by specified scaling factors (ROIWidthResizeFactor and ROIHeightResizeFactor). After modifying  */
        /*    the width and height, adjust the upper-left X- and Y-coordinates (ROI(:, 1 : 2)) so that they */
        /*    are located at half the width and half the height from the unmodified centerpoint; by making  */
        /*    this adjustment, the resizing will have expanded from the centerpoint rather than from the */
        /*    upper-left corner. Then, adjust the ROI values so that none exceed the frame dimensions  */
        /*    (VidObjWidth and VidObjHeight). */
        /*  */
        /*    Inputs: */
        /*  */
        /*       ROI                     = ROI matrix (multiple ROIs) or row vector (one ROI). */
        /*                                 The columns in the ROI matrix or row vector indicate X-upper-left    */
        /*                                 corner, Y-upper-left corner width, and height, in pixels. Note */
        /*                                 that X refers to column indexing and Y refers to row indexing; */
        /*                                 because Y refers to row indexing, Y == 0 is located at the top, */
        /*                                 rather than the bottom, of the plane. */
        /*       ROIsToResizeLinIdx      = Linear index corresponding to the ROI matrix indicating ROIs to */
        /*                                 resize. Index can be non-consecutive. If resizing one ROI (a row */
        /*                                 vector), specify 1 for this argument. */
        /*       ROIWidthResizeFactor    = Width resizing factor. */
        /*       ROIHeightResizeFactor   = Height resizing factor. */
        /*       VidObjWidth             = Frame width (pixels).  */
        /*       VidObjHeight            = Frame height (pixels). */
        /*  */
        /*    Output: */
        /*  */
        /*       ROIResize               = Resized ROI matrix (multiple ROIs) or row vector (one ROI).                                 */
        /*  */
        /*    Note:  */
        /*  */
        /*    Intended only for use with integer types as rounding is not conducted. For modification for use  */
        /*    with floating-point types, rounding would be necessary as ROI values should be integers. */
        /*  */
        /*  */
        /*    Copyright */
        /*    --------- */
        /*  */
        /*    Copyright (c) Douglas Magill (dpmdpm@vt.edu), June, 2020. Licensed under the MIT License and   */
        /*    the Responsible AI License (RAIL). */
        /* %%%%% Input validation %%%%%% */
        /* Validate whether input ROI is type int16. */
        /* Must be an integer type because no rounding is conducted. */
        /* Should be type int16 because the function is implemented to assign values of this type. */
        /* A non-matching type would be due to an implementation error. */
        /* %%%%% Running in code generation %%%%%% */
        /* When running in code generation, use for-loops. When running in Matlab code, use vectorization. */
        /* code generation running */
        /* Inline function */
        /* Preallocate output */
        i = ROIOut_SR->size[0] * ROIOut_SR->size[1];
        ROIOut_SR->size[0] = FramesToAdjust->size[1];
        ROIOut_SR->size[1] = 4;
        emxEnsureCapacity_int16_T(ROIOut_SR, i);

        /* Cast resizing factors to type single for efficiency */
        i = FramesToAdjust->size[1];
        for (b_i = 0; b_i < i; b_i++) {
          /* %%%%% --- Resize width(s) and height(s) %%%%%%  */
          /* Convert to index of input ROI */
          i1 = FramesToAdjust->data[b_i];
          Width_ith = (int16_T)muSingleScalarRound((real32_T)
            ROIBlockFaceSkin_Temp->data[(i1 + ROIBlockFaceSkin_Temp->size[0] * 2)
            - 1] * (real32_T)c_ROIGeneralConfig_ROIWidthResi);
          ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 2] = Width_ith;
          HeightNew_ith = (int16_T)muSingleScalarRound((real32_T)
            ROIBlockFaceSkin_Temp->data[(i1 + ROIBlockFaceSkin_Temp->size[0] * 3)
            - 1] * (real32_T)c_ROIGeneralConfig_ROIHeightRes);
          ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 3] = HeightNew_ith;

          /* %%%%% Adjust X- and Y-coordinates %%%%%% */
          /* Adjust the upper-left X- and Y-coordinates (ROI(:, 1 : 2)) so that they are located at half the */
          /* width and half the height from the unmodified centerpoint; by making this adjustment, the resizing  */
          /* will have expanded from the centerpoint rather than from the upper-left corner. */
          /* Optimize division by 2 by bit-wise operations. */
          /* Find centerpoint */
          /* Assign new X- and Y-coordinates */
          /* Expand from centerpoint based upon new height and width     */
          ROIOut_SR->data[b_i] = (int16_T)((int16_T)(ROIBlockFaceSkin_Temp->
            data[i1 - 1] + (ROIBlockFaceSkin_Temp->data[(i1 +
            ROIBlockFaceSkin_Temp->size[0] * 2) - 1] >> 1)) - (Width_ith >> 1));
          ROIOut_SR->data[b_i + ROIOut_SR->size[0]] = (int16_T)((int16_T)
            (ROIBlockFaceSkin_Temp->data[(i1 + ROIBlockFaceSkin_Temp->size[0]) -
             1] + (ROIBlockFaceSkin_Temp->data[(i1 + ROIBlockFaceSkin_Temp->
            size[0] * 3) - 1] >> 1)) - (HeightNew_ith >> 1));
        }

        /* %%%%% --- Modify new ROI dimensions that exceed frame dimensions %%%%%%   */
        /* Function ROIAdjustIfExceedsFrameDims verifies if adjusted ROIs are within frame dimensions and, if  */
        /* not, adjusts the ROI values to conform to frame dimensions. */
        /* Note: ROIAdjustIfExceedsFrameDims is a custom function located within folder 'FacePulseRate'. */
        /* ROIAdjustIfExceedsFrameDims   Verify whether proposed widths and heights of ROIs exceed frame  */
        /*                               dimensions and, if so, modify them to conform to frame dimensions. */
        /*                                */
        /*     Helper function to function FacePulseRate. */
        /*     Within function FacePulseRate, called by functions ROIResize, ROIMeans_FirstRead_Extrapolate, */
        /*     SkinDetect_EnlargeROI, ROIMSIR, ROIMSIR_MatchSize, ROIMSIR_DetectionSmooth,   */
        /*     ROIMSIR_Interpolate, and ROIMSIR_FrameByFrameSmooth.    */
        /*  */
        /*  */
        /*     Code Generation */
        /*     --------------- */
        /*  */
        /*     Can be called as a Matlab function or used for C-language code generation. */
        /*  */
        /*  */
        /*     Description */
        /*     ----------- */
        /*  */
        /*     This function verifies that ROIs that have had modifications to their sizes are still within */
        /*     the dimensions of the frame. If not, this function adjusts the dimensions (and, consequently,   */
        /*     the spatial coordinates) to conform to the frame dimensions. */
        /*  */
        /*     Note:  */
        /*  */
        /*     Intended only for use with integer types as rounding is not conducted. For modification for  */
        /*     use with floating-point types, rounding would be necessary as ROI values should be integers. */
        /*  */
        /*  */
        /*     Copyright */
        /*     --------- */
        /*  */
        /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
        /*     the Responsible AI License (RAIL). */
        /* %%%%% Validate inputs %%%%%% */
        /* Exit if empty */
        if (ROIOut_SR->size[0] != 0) {
          /* Validate whether input ROIsProposed is type int16. */
          /* Must be an integer type because no rounding is conducted. */
          /* Should be type int16 because the function is implemented to assign values of this type. */
          /* A non-matching type would be due to an implementation error. */
          /* %%%%% Running in code generation %%%%%% */
          /* When running in code generation, use for-loops. When running in Matlab code, use vectorization. */
          /* code generation running */
          /* Inline function */
          i = ROIOut_SR->size[0];
          for (b_i = 0; b_i < i; b_i++) {
            /* %%%%% --- Verify, and adjust if necessary, X-coordinates and widths %%%%%% */
            /* Adjust left-side X-coordinate if exceeds frame dimensions: */
            WidthNew_ith = ROIOut_SR->data[b_i];
            if (WidthNew_ith < 1) {
              WidthNew_ith = 1;

              /* recent code mod */
              ROIOut_SR->data[b_i] = 1;
            } else {
              if (WidthNew_ith > VidObjWidth) {
                WidthNew_ith = VidObjWidth;

                /* recent code mod */
                ROIOut_SR->data[b_i] = VidObjWidth;
              }
            }

            /* Adjust right-side X-coordinate if exceeds frame dimensions: */
            Width_ith = (int16_T)((int16_T)(WidthNew_ith + ROIOut_SR->data[b_i +
              ROIOut_SR->size[0] * 2]) - 1);
            if (Width_ith > VidObjWidth) {
              Width_ith = VidObjWidth;
              ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 2] = (int16_T)((int16_T)
                (VidObjWidth - WidthNew_ith) + 1);
            } else {
              if (Width_ith < 1) {
                Width_ith = 1;
                WidthNew_ith = 1;
                ROIOut_SR->data[b_i] = 1;
                ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 2] = 1;
              }
            }

            /* Adjust width if exceeds frame dimensions: */
            Width_ith = (int16_T)((int16_T)(Width_ith - WidthNew_ith) + 1);
            if (Width_ith > VidObjWidth) {
              ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 2] = VidObjWidth;
            } else {
              if (Width_ith < 1) {
                ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 2] = 1;
              }
            }

            /* %%%%% --- Verify, and adjust if necessary, Y-coordinates and heights %%%%%% */
            /* Adjust top-side Y-coordinate if exceeds frame dimensions: */
            Height_ith = ROIOut_SR->data[b_i + ROIOut_SR->size[0]];
            if (Height_ith < 1) {
              Height_ith = 1;

              /* recent code mod */
              ROIOut_SR->data[b_i + ROIOut_SR->size[0]] = 1;
            } else {
              if (Height_ith > VidObjHeight) {
                Height_ith = VidObjHeight;

                /* recent code mod */
                ROIOut_SR->data[b_i + ROIOut_SR->size[0]] = VidObjHeight;
              }
            }

            /* Adjust bottom-side Y-coordinate if exceeds frame dimensions: */
            Width_ith = (int16_T)((int16_T)(Height_ith + ROIOut_SR->data[b_i +
              ROIOut_SR->size[0] * 3]) - 1);
            if (Width_ith > VidObjHeight) {
              Width_ith = VidObjHeight;
              ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 3] = (int16_T)((int16_T)
                (VidObjHeight - Height_ith) + 1);
            } else {
              if (Width_ith < 1) {
                Width_ith = 1;
                Height_ith = 1;
                ROIOut_SR->data[b_i + ROIOut_SR->size[0]] = 1;
                ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 3] = 1;
              }
            }

            /* Adjust height value if exceeds frame dimensions: */
            HeightNew_ith = (int16_T)((int16_T)(Width_ith - Height_ith) + 1);
            if (HeightNew_ith > VidObjHeight) {
              ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 3] = VidObjHeight;
            } else {
              if (HeightNew_ith < 1) {
                ROIOut_SR->data[b_i + ROIOut_SR->size[0] * 3] = 1;
              }
            }
          }

          /* %%%%% Code generation not running %%%%%% */
        } else {
          /* Exit function */
        }

        /* end function */
        /* ============================================================================================= */
        /* Code-generation and build script */
        /* ============================================================================================= */
        /* Code-generation and build script used to generate C-language code and create the compiled version  */
        /* (ROIAdjustIfExceedsFrameDims_mex) of the function. */
        /* { */
        /*  */
        /* %%%%% Specify variable-size input arguments %%%%%% */
        /*  */
        /* See Matlab documentation for coder.typeof. */
        /*  */
        /*                                   Example Code               Upp. Bounds   Var. Size (T/F)  Type */
        /* ROIsProposedCode   = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],     [1, 0] );        %int16 */
        /*            */
        /*        */
        /* %%%%% Specify fixed-size input arguments %%%%%% */
        /*  */
        /* VidObjWidthCode  = int16(0);          */
        /* VidObjHeightCode = int16(0); */
        /*                    */
        /*  */
        /* %%%%% Set configurations to increase performance %%%%%% */
        /*  */
        /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
        /* "Optimization Strategies" */
        /*  */
        /* cfg = coder.config('mex'); */
        /* cfg.GlobalDataSyncMethod = 'NoSync'; */
        /* cfg.ConstantInputs = 'IgnoreValues'; */
        /* cfg.ExtrinsicCalls = true; %permit to show assert error */
        /* cfg.SaturateOnIntegerOverflow = false; */
        /* cfg.IntegrityChecks = false; */
        /* cfg.ResponsivenessChecks = false; */
        /*  */
        /*  */
        /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
        /*  */
        /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
        /*  */
        /* The flags are specified as part of the code-generation configuration object. A custom function, */
        /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
        /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
        /* Matlab guidance found in */
        /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
        /*  */
        /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
        /* a character vector prior to execution of the codegen command. */
        /*  */
        /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
        /*  */
        /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
        /* is not present in the base workspace. */
        /*  */
        /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
        /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
        /* character vector to maintain the charater vector, */
        /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
        /*  */
        /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
        /*  */
        /* Assign to code-generation configuration object */
        /* cfg.PostCodeGenCommand = setbuildargsAsText; */
        /*  */
        /*  */
        /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
        /*  */
        /* codegen ROIAdjustIfExceedsFrameDims.m -report -config cfg -args {ROIsProposedCode, VidObjWidthCode, VidObjHeightCode} */
        /*                  */
        /* } */
        /* %%%%% Code generation not running %%%%%%     */
        /* end function */
        /* ============================================================================================= */
        /* Code-generation and build script */
        /* ============================================================================================= */
        /* Code-generation and build script used to generate C-language code and create the compiled version  */
        /* (ROIResize_mex) of the function. */
        /* { */
        /*  */
        /* %%%%% Specify variable-size input arguments %%%%%% */
        /*  */
        /* See Matlab documentation for coder.typeof. */
        /*  */
        /*                                       Example Code               Upp. Bounds   Var. Size (T/F)  Type */
        /* ROICode                = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],     [1, 0] );        %int16 */
        /* ROIsToResizeLinIdxCode = coder.typeof( zeros(1, 500, 'int32'),   [1, inf],     [0, 1] );        %int32 */
        /*            */
        /*                       */
        /* %%%%% Specify fixed-size input arguments %%%%%% */
        /*  */
        /* ROIWidthResizeFactorCode  = double(0); */
        /* ROIHeightResizeFactorCode = double(0); */
        /* VidObjWidthCode           = int16(0);          */
        /* VidObjHeightCode          = int16(0); */
        /*                    */
        /*  */
        /* %%%%% Set configurations to increase performance %%%%%% */
        /*  */
        /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
        /* "Optimization Strategies" */
        /*  */
        /* cfg = coder.config('mex'); */
        /* cfg.GlobalDataSyncMethod = 'NoSync'; */
        /* cfg.ConstantInputs = 'IgnoreValues'; */
        /* cfg.ExtrinsicCalls = true; %permit to show assert error */
        /* cfg.SaturateOnIntegerOverflow = false; */
        /* cfg.IntegrityChecks = false; */
        /* cfg.ResponsivenessChecks = false; */
        /*  */
        /*  */
        /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
        /*  */
        /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
        /*  */
        /* The flags are specified as part of the code-generation configuration object. A custom function, */
        /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
        /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
        /* Matlab guidance found in */
        /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
        /*  */
        /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
        /* a character vector prior to execution of the codegen command. */
        /*  */
        /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
        /*  */
        /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
        /* is not present in the base workspace. */
        /*  */
        /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
        /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
        /* character vector to maintain the charater vector, */
        /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
        /*  */
        /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
        /*  */
        /* Assign to code-generation configuration object */
        /* cfg.PostCodeGenCommand = setbuildargsAsText; */
        /*  */
        /*  */
        /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
        /*  */
        /* codegen ROIResize.m -report -config cfg -args {ROICode, ROIsToResizeLinIdxCode, ROIWidthResizeFactorCode, ROIHeightResizeFactorCode, VidObjWidthCode, VidObjHeightCode} */
        /*                  */
        /* } */
      }
    }

    /*  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
    /* %% Change size of ROI(s) according to ROIWidthResizeFactor and ROIHeightResizeFactor %%% */
    /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
    /* ROIWidthResizeFactor and ROIHeightResizeFactor are arguments to function FacePulseRate. */
    /* Only apply size adjustments to ROIs once. To do so, apply when the call is from the first read or  */
    /* when the call is from second read during the post-processing (but not pre-processing) step. */
    /* Note: during the first read, called by function ROIMeans_FirstRead_TakeMeans; during the second   */
    /* read, called by function ROIMeans_SecondRead.     */
    /* Function ROIResize scales ROI as specified and also prevents scaled ROI from exceeding frame */
    /* dimensions. */
    /* Note: ROIResize is a custom function located within folder 'FacePulseRate'. */
    /* For calls during first read */
    /*  %%%%%%%%%%%%%%%%%%%%%% */
    /* %% Output validation %%% */
    /* %%%%%%%%%%%%%%%%%%%%%%%% */
    /* Validate output arguments. */
    /* This validation provides a safeguard against unexpected errors that may arise from implementation */
    /* changes. */
    /* Note: ROIMSIR_OutputValidate is a custom function located within folder 'FacePulseRate'. */
    /* ROIMSIR_OutputValidate    Validate output arguments in function ROIMSIR. */
    /*  */
    /*     Helper function to function FacePulseRate.  */
    /*     Within function FacePulseRate, called by function ROIMSIR. */
    /*  */
    /*  */
    /*     Code Generation */
    /*     --------------- */
    /*  */
    /*     Can be called as a Matlab function or used for C-language code generation. */
    /*  */
    /*  */
    /*     Description */
    /*     ----------- */
    /*  */
    /*     Validate output arguments in function ROIMSIR. */
    /*  */
    /*  */
    /*     Copyright */
    /*     --------- */
    /*  */
    /*     Copyright (c) Douglas Magill (dpmdpm@vt.edu), August, 2020. Licensed under the MIT License and   */
    /*     the Responsible AI License (RAIL). */
    /* %%%%% Code generation settings %%%%%% */
    /* Inline function */
    /* Call function as extrinsic */
    /* See note where warning() is used. */
    /* Call function as extrinsic so that stack trace can be displayed */
    /* %%%%% For first-read operations %%%%%% */
    if (FirstReadTF) {
      /* Assert empty size for ROIOut_SR as this variable not used in first-read operations */
      /* Check whether any ROI value is zero */
      /* The operations of this function were intended to prevent values of zero, so such a value is */
      /* likely due to an implementation error in this function.  */
      if ((ROIOut_FR[0] == 0) || (ROIOut_FR[1] == 0) || (ROIOut_FR[2] == 0) ||
          (ROIOut_FR[3] == 0)) {
        /* Throw error    */
        /* Called as extrinsic so that stack trace can be displayed. */
        b_sprintf(VideoReadConfig_FrameIdx_FR->data[RowToReturnFullLinIdx_FR - 1],
                  r1);
        i = varargin_2->size[0] * varargin_2->size[1];
        varargin_2->size[0] = 1;
        varargin_2->size[1] = r1->size[1] + 243;
        emxEnsureCapacity_char_T(varargin_2, i);
        for (i = 0; i < 79; i++) {
          varargin_2->data[i] = cv38[i];
        }

        for (i = 0; i < 69; i++) {
          varargin_2->data[i + 79] = cv31[i];
        }

        for (i = 0; i < 25; i++) {
          varargin_2->data[i + 148] = cv32[i];
        }

        Sum = r1->size[1];
        for (i = 0; i < Sum; i++) {
          varargin_2->data[i + 173] = r1->data[i];
        }

        for (i = 0; i < 70; i++) {
          varargin_2->data[(i + r1->size[1]) + 173] = cv40[i];
        }

        error(emlrt_marshallOut(cv3), b_emlrt_marshallOut(varargin_2),
              &ab_emlrtMCI);
      }

      /* Check whether the ROI size is unreasonably small */
      /* Such a small size is likely due to an implementation error in this function. */
      /* This check is intended to be run when testing new implementations, as small ROI sizes are an */
      /* indication of a implementation error. As occassional values below 20 may be considered */
      /* acceptable, this check is not intended for use outside of testing. "Occassional" in this case    */
      /* might be defined as a few occurances out of 10,000. Flag ExpectedBehaviorTestTF enables the */
      /* check.     */
      if (ExpectedBehaviorTestTF && ((ROIOut_FR[2] < 20) || (ROIOut_FR[3] < 20)))
      {
        /* Note: function warning() not available for code generation, so it must have previously */
        /* been declared as extrinsic. */
        /* Function fprintf can not be used as a substitute for warning() in this case because  */
        /* fprintf can not accept variable-length arguments.         */
        b_sprintf(VideoReadConfig_FrameIdx_FR->data[RowToReturnFullLinIdx_FR - 1],
                  r1);
        i = varargin_2->size[0] * varargin_2->size[1];
        varargin_2->size[0] = 1;
        varargin_2->size[1] = r1->size[1] + 302;
        emxEnsureCapacity_char_T(varargin_2, i);
        for (i = 0; i < 72; i++) {
          varargin_2->data[i] = cv41[i];
        }

        for (i = 0; i < 74; i++) {
          varargin_2->data[i + 72] = cv27[i];
        }

        for (i = 0; i < 75; i++) {
          varargin_2->data[i + 146] = cv35[i];
        }

        for (i = 0; i < 11; i++) {
          varargin_2->data[i + 221] = cv29[i];
        }

        Sum = r1->size[1];
        for (i = 0; i < Sum; i++) {
          varargin_2->data[i + 232] = r1->data[i];
        }

        for (i = 0; i < 70; i++) {
          varargin_2->data[(i + r1->size[1]) + 232] = cv40[i];
        }

        warning(emlrt_marshallOut(cv3), b_emlrt_marshallOut(varargin_2),
                &cb_emlrtMCI);
      }

      /* Check whether ROI type not int16 because other functions are implemented to accept values of   */
      /* this type.  */
      /* A non-matching type would be due to an implementation error. */
      /* %%%%% For second-read operations %%%%%%     */
    } else {
      /* Check whether the size of any ROI is unreasonably small */
      /* Such a small size is likely due to an implementation error in this function. */
      /* This check is intended to be run when testing new implementations, as small ROI sizes are an */
      /* indication of a implementation error. As occassional values below 20 may be considered */
      /* acceptable, this check is not intended for use outside of testing. "Occassional" in this case    */
      /* might be defined as a few occurances out of 10,000. Flag ExpectedBehaviorTestTF enables the */
      /* check.     */
      guard3 = false;
      if (ExpectedBehaviorTestTF) {
        Sum = ROIOut_SR->size[0];
        i = b_HasROI_TF->size[0];
        b_HasROI_TF->size[0] = ROIOut_SR->size[0];
        emxEnsureCapacity_boolean_T(b_HasROI_TF, i);
        for (i = 0; i < Sum; i++) {
          b_HasROI_TF->data[i] = (ROIOut_SR->data[i + ROIOut_SR->size[0] * 2] <
            20);
        }

        if (any(b_HasROI_TF)) {
          /* Display warning */
          /* Note: function warning() not available for code generation, so it must have previously */
          /* been declared as extrinsic. */
          warning(emlrt_marshallOut(cv3), m_emlrt_marshallOut(cv39),
                  &bb_emlrtMCI);
        } else {
          guard3 = true;
        }
      } else {
        guard3 = true;
      }

      if (guard3) {
        Sum = ROIOut_SR->size[0];
        i = b_HasROI_TF->size[0];
        b_HasROI_TF->size[0] = ROIOut_SR->size[0];
        emxEnsureCapacity_boolean_T(b_HasROI_TF, i);
        for (i = 0; i < Sum; i++) {
          b_HasROI_TF->data[i] = (ROIOut_SR->data[i + ROIOut_SR->size[0] * 3] <
            20);
        }

        if (any(b_HasROI_TF)) {
          /* Display warning */
          /* Note: function warning() not available for code generation, so it must have previously */
          /* been declared as extrinsic. */
          warning(emlrt_marshallOut(cv3), m_emlrt_marshallOut(cv39),
                  &bb_emlrtMCI);
        }
      }

      /* Check if ROI type not int16 because other functions are implemented to accept values of this  */
      /* type.  */
      /* A non-matching type would be due to an implementation error. */
    }

    /* end function */
  }

  emxFree_boolean_T(&b_HasROI_TF);
  emxFree_char_T(&r1);
  emxFree_boolean_T(&b_x);
  emxFree_boolean_T(&x);
  emxFree_char_T(&varargin_2);
  emxFree_int16_T(&SmoothedXYColumn);
  emxFree_int16_T(&r);
  emxFree_int16_T(&ROIBlockFaceSkin_Temp);
  emxFree_int32_T(&SkinIdxFit);
  emxFree_int16_T(&ROIWidthHeightPreSmooth);
  emxFree_int32_T(&FramesToAdjust);
  emxFree_int32_T(&c_ROIBlockDetectionFaceSkinLinI);
  emxFree_int32_T(&ROIBlockDetectionSkinLinIdx_SR);
  emxFree_int32_T(&ROIBlockDetectionFaceLinIdx_SR);
  emxFree_int16_T(&c_NoPrevCallsBlock_ROIDetection);
  emxFree_int16_T(&ROINoPrevCallsBlock_SR);
  emxFree_real32_T(&TimestampBlockDetections_SR);
  emxFree_real32_T(&TimestampBlock_SR);
  emxFree_int32_T(&BlockFullLinIdx_SR);

  /* end function  */
  /* ============================================================================================= */
  /* Code-generation and build script */
  /* ============================================================================================= */
  /* Code-generation and build script used to generate C-language code and create the compiled version  */
  /* (ROIMSIR_mex) of the function. */
  /* { */
  /*  */
  /* %%%%% Specify variable-size input arguments %%%%%% */
  /*  */
  /* See Matlab documentation for coder.typeof. */
  /*  */
  /* Specify struct variable-size element properties */
  /* Element1 = ... */
  /*     coder.typeof(false(500, 1), ... example code */
  /*                  [inf, 1],      ... upper bounds */
  /*                  [1, 0]         ... variable size (T/F) */
  /*     ); */
  /*  */
  /* Struct with variable-size elements */
  /* Note: the number, names, and order of fields are compile-time constants. */
  /*  */
  /* HasROI_TFCode = ... */
  /*     struct( ...   */
  /*         'FacePrimary',                      Element1, ... */
  /*         'FacePrimaryAttempted',             Element1, ... */
  /*         'SkinNotPresent_Pri',               Element1, ... */
  /*         'ProfileEyesPresent_Pri',           Element1, ... */
  /*         'FaceSecondary1',                   Element1, ... */
  /*         'FaceSecondary1Attempted',          Element1, ... */
  /*         'SkinNotPresent_Sec1',              Element1, ... */
  /*         'ProfileEyesPresent_Sec1',          Element1, ... */
  /*         'FaceSecondary2',                   Element1, ... */
  /*         'FaceSecondary2Attempted',          Element1, ... */
  /*         'SkinNotPresent_Sec2',              Element1, ... */
  /*         'ProfileEyesPresent_Sec2',          Element1, ... */
  /*         'Skipped',                          Element1, ... */
  /*         'Skin',                             Element1, ... */
  /*         'SkinAttempted',                    Element1, ... */
  /*         'SkinNotPresent_Skin',              Element1, ... */
  /*         'Interpolated',                     Element1, ...       */
  /*         'AdjustedBecauseLowSkinProportion', Element1, ... */
  /*         'ROISpecifiedByArgument',           Element1, ... */
  /*         'ROIIgnoreByArgument',              Element1 ... */
  /*     ); */
  /*  */
  /*                                                Example Code               Upp. Bounds  Var. Size (T/F)  Type */
  /* BlockFullLinIdx_InCode          = coder.typeof( zeros(500, 1, 'int32'),    [inf, 1],    [1, 0] );        %int32 */
  /* ROICode                         = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],    [1, 0] );        %int16 */
  /* TimestampCode                   = coder.typeof( zeros(500, 1, 'single'),   [inf, 1],    [1, 0] );        %single  */
  /* VideoReadConfig_FrameIdx_FRCode = coder.typeof( zeros(1, 500, 'int32'),    [1, inf],    [0, 1] );        %int32 */
  /* ROINoModsCode                   = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],    [1, 0] );        %int16 */
  /* ROINoResizeCode                 = coder.typeof( zeros(500, 4, 'int16'),    [inf, 4],    [1, 0] );        %int16 */
  /*            */
  /*        */
  /* %%%%% Specify fixed-size input arguments %%%%%% */
  /*  */
  /* ROIGeneralConfig_ROIMSIR_DiffMaxDetectionCode = int16(0); */
  /* ROIGeneralConfig_ROIMSIR_DiffMaxAdjacentCode  = int16(0); */
  /* ROIGeneralConfig_ROIWidthResizeFactorCode     = double(0); */
  /* ROIGeneralConfig_ROIHeightResizeFactorCode    = double(0); */
  /* FaceDetectConfig_ROIFaceSmoothingWindowCode   = double(0); */
  /* FaceDetectConfig_ROIFaceSecondary1TFCode      = false; */
  /* FaceDetectConfig_ROIFaceSecondary2TFCode      = false; */
  /* SkinDetectConfig_ROISkinSmoothingWindowCode   = double(0); */
  /* ROIGeneralConfig_ROIFinalSmoothingWindowsCode = zeros(1, 2, 'int32'); */
  /* VidObjWidthCode                               = int16(0);          */
  /* VidObjHeightCode                              = int16(0); */
  /* ExpectedBehaviorTestTFCode                    = false; */
  /* FirstReadTFCode                               = false; */
  /* FirstCallTFCode                               = false;   */
  /* RowToReturnFullLinIdx_FRCode                  = int32(0); */
  /* FirstFrameMSIRLinIdx_FRCode                   = int32(0); */
  /* SecondReadPostProcessingTFCode                = false;                            */
  /*  */
  /* ROIMatchSizeDataCode = ... */
  /*     struct( ... */
  /*         'SumW_Pri', single(0), ... */
  /*         'SumH_Pri', single(0), ... */
  /*         'AlgN_Pri', single(0), ... */
  /*         'ROIMeanWidthPri', single(0), ... */
  /*         'ROIMeanHeightPri', single(0), ... */
  /*         'SumW_Sec1', single(0), ...  */
  /*         'SumH_Sec1', single(0), ... */
  /*         'AlgN_Sec1', single(0), ... */
  /*         'ROIMeanWidthSec1', single(0), ... */
  /*         'ROIMeanHeightSec1', single(0), ... */
  /*         'SumW_Sec2', single(0), ... */
  /*         'SumH_Sec2', single(0), ... */
  /*         'AlgN_Sec2', single(0), ... */
  /*         'ROIMeanWidthSec2', single(0), ... */
  /*         'ROIMeanHeightSec2', single(0), ... */
  /*         'SumW_Skin', single(0), ... */
  /*         'SumH_Skin', single(0), ... */
  /*         'AlgN_Skin', single(0), ... */
  /*         'ROIMeanWidthSkin', single(0), ... */
  /*         'ROIMeanHeightSkin', single(0) ...  */
  /*     );         */
  /*  */
  /*  */
  /* %%%%% Set configurations to increase performance %%%%%% */
  /*  */
  /* Note: see Matlab Coder documention for coder.MexCodeConfig and documentation topic  */
  /* "Optimization Strategies" */
  /*  */
  /* cfg = coder.config('mex'); */
  /* cfg.GlobalDataSyncMethod = 'NoSync'; */
  /* cfg.ConstantInputs = 'IgnoreValues'; */
  /* cfg.ExtrinsicCalls = true; %permit extrinsic calls to permit functions warning() and error() to operate */
  /* cfg.SaturateOnIntegerOverflow = false; */
  /* cfg.IntegrityChecks = false;  */
  /* cfg.ResponsivenessChecks = false; */
  /*  */
  /*  */
  /* %%%%% Specify flags to minGW compiler to optimize execution speed %%%%%% */
  /*  */
  /* For documentation on minGW compiler flags, see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html */
  /*  */
  /* The flags are specified as part of the code-generation configuration object. A custom function, */
  /* setbuildargs, is used to specify these flags. For details on the function implementation, see the  */
  /* function file, which is located within folder FacePulseRate. This custom function is based upon  */
  /* Matlab guidance found in */
  /* https://www.mathworks.com/matlabcentral/answers/345549-how-can-i-modify-the-build-information-for-mex-code-generation-with-the-codegen-function */
  /*  */
  /* setbuildargs will be evaluated from text within the code-generation object, so it is converted to  */
  /* a character vector prior to execution of the codegen command. */
  /*  */
  /* %%%%% --- Specify the flags as arguments to function setbuildargs %%%%%% */
  /*  */
  /* Argument buildInfo: this variable is assign by the caller (the codegen command executed below) and  */
  /* is not present in the base workspace. */
  /*  */
  /* Second argument: specify a cell array of compiler-specific flags, where each flag is a character  */
  /* vector. As function setbuildargs will be evaluated from text, use double ' quotes for each */
  /* character vector to maintain the charater vector, */
  /* e.g., {''-Ofast'' ''-fsingle-precision-constant''}. */
  /*  */
  /* setbuildargsAsText = 'setbuildargs(buildInfo, {''-Ofast''})'; */
  /*  */
  /* Assign to code-generation configuration object */
  /* cfg.PostCodeGenCommand = setbuildargsAsText; */
  /*  */
  /*  */
  /* %%%%% Execute codegen command to generate code and build compiled mex file %%%%%% */
  /*  */
  /* codegen ROIMSIR.m -report -config cfg -args {BlockFullLinIdx_InCode, ROICode, TimestampCode, HasROI_TFCode, ROIGeneralConfig_ROIMSIR_DiffMaxDetectionCode, ROIGeneralConfig_ROIMSIR_DiffMaxAdjacentCode, ROIGeneralConfig_ROIWidthResizeFactorCode, ROIGeneralConfig_ROIHeightResizeFactorCode, FaceDetectConfig_ROIFaceSmoothingWindowCode, FaceDetectConfig_ROIFaceSecondary1TFCode, FaceDetectConfig_ROIFaceSecondary2TFCode, SkinDetectConfig_ROISkinSmoothingWindowCode, ROIGeneralConfig_ROIFinalSmoothingWindowsCode, VidObjWidthCode, VidObjHeightCode, ExpectedBehaviorTestTFCode, FirstReadTFCode, FirstCallTFCode, VideoReadConfig_FrameIdx_FRCode, RowToReturnFullLinIdx_FRCode, FirstFrameMSIRLinIdx_FRCode, ROINoModsCode, ROINoResizeCode, ROIMatchSizeDataCode, SecondReadPostProcessingTFCode} */
  /*                  */
  /* } */
  emlrtHeapReferenceStackLeaveFcnR2012b(emlrtRootTLSGlobal);
}

/* End of code generation (ROIMSIR.c) */
